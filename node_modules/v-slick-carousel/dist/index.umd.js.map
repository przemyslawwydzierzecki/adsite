{"version":3,"file":"index.umd.js","sources":["../lib/types/enums.ts","../lib/utils/carousel-utils.ts","../lib/utils/index.ts","../lib/components/props.ts","../../../node_modules/.pnpm/@dcufo+enquire.js@2.1.9/node_modules/@dcufo/enquire.js/src/QueryHandler.js","../../../node_modules/.pnpm/@dcufo+enquire.js@2.1.9/node_modules/@dcufo/enquire.js/src/Util.js","../../../node_modules/.pnpm/@dcufo+enquire.js@2.1.9/node_modules/@dcufo/enquire.js/src/MediaQuery.js","../../../node_modules/.pnpm/@dcufo+enquire.js@2.1.9/node_modules/@dcufo/enquire.js/src/MediaQueryDispatch.js","../../../node_modules/.pnpm/@dcufo+enquire.js@2.1.9/node_modules/@dcufo/enquire.js/src/index.js","../../../node_modules/.pnpm/string-convert@0.2.1/node_modules/string-convert/camel2hyphen.js","../../../node_modules/.pnpm/json2mq@0.2.0/node_modules/json2mq/index.js","../lib/components/VSlickArrow.vue","../lib/components/VSlickTrack.vue","../lib/components/VSlickDots.vue","../../../node_modules/.pnpm/lodash.debounce@4.0.8/node_modules/lodash.debounce/index.js","../lib/components/VSlickCarousel.vue"],"sourcesContent":["export enum PlayingType {\r\n  play = 'play',\r\n  playing = 'playing',\r\n  paused = 'paused',\r\n  hovered = 'hovered',\r\n  focused = 'focused',\r\n  update = 'update',\r\n  leave = 'leave',\r\n  blur = 'blur'\r\n}\r\n\r\nexport enum LazyLoadType {\r\n  ondemand = 'ondemand',\r\n  progressive = 'progressive'\r\n}\r\n\r\nexport enum SwipeDirection {\r\n  left = 'left',\r\n  right = 'right',\r\n  up = 'up',\r\n  down = 'down',\r\n  vertical = 'vertical'\r\n}\r\n\r\nexport enum SlideNavigation {\r\n  next = 'next',\r\n  previous = 'previous'\r\n}\r\n\r\nexport enum WidthDetection {\r\n  auto = 'auto',\r\n  manual = 'manual'\r\n}\r\n","import { VNode } from 'vue'\r\nimport {\r\n  CloneInfoSpec,\r\n  GoNextSpec,\r\n  GoPrevSpec,\r\n  LazyInfoSpec,\r\n  NavigableSpec,\r\n  OnSlideSpec,\r\n  PlayingType,\r\n  SlideGroupChangeOptions,\r\n  SlideGroupChangeSpec,\r\n  SlideGroupCountSpec,\r\n  SlideNavigation,\r\n  SliderState,\r\n  SliderStateInfoSpec,\r\n  SwipeDirection,\r\n  SwipeEndSpec,\r\n  SwipeEndState,\r\n  SwipeEvent,\r\n  SwipeMoveSpec,\r\n  SwipeMoveState,\r\n  TouchObject,\r\n  TrackInfoSpec\r\n} from '../types'\r\nimport { MarkRequiredWithPartialBase } from '@lib/types/helpers'\r\n\r\nexport const extractSlides = (vnodes: VNode[]): VNode[] => {\r\n  return vnodes.flatMap((vnode) =>\r\n    isSlide(vnode)\r\n      ? [vnode]\r\n      : Array.isArray(vnode.children) && vnode.children.length > 0\r\n        ? extractSlides(vnode.children as VNode[])\r\n        : []\r\n  )\r\n}\r\n\r\nfunction isSlide(vnode: VNode): boolean {\r\n  return !vnode.type.toString().startsWith('Symbol')\r\n}\r\n\r\nexport const getNavigationOnKeyType = (\r\n  e: KeyboardEvent,\r\n  accessibility: boolean,\r\n  rtl: boolean\r\n) => {\r\n  if (\r\n    (e.target as HTMLElement)?.tagName.match('TEXTAREA|INPUT|SELECT') ||\r\n    !accessibility\r\n  )\r\n    return ''\r\n  if (e.key === 'ArrowLeft')\r\n    return rtl ? SlideNavigation.next : SlideNavigation.previous\r\n  if (e.key === 'ArrowRight')\r\n    return rtl ? SlideNavigation.previous : SlideNavigation.next\r\n  return ''\r\n}\r\n\r\nexport const getChangedSlideGroupIndex = (\r\n  spec: SlideGroupChangeSpec,\r\n  options: SlideGroupChangeOptions\r\n) => {\r\n  let indexOffset,\r\n    previousInt,\r\n    slideGroupOffset,\r\n    unevenOffset,\r\n    targetSlideGroupIndex\r\n  const {\r\n    groupsToScroll,\r\n    groupsToShow,\r\n    slideGroupCount,\r\n    currentSlideGroupIndex,\r\n    lazyLoad,\r\n    infinite\r\n  } = spec\r\n  unevenOffset = slideGroupCount % groupsToScroll !== 0\r\n  indexOffset = unevenOffset\r\n    ? 0\r\n    : (slideGroupCount - currentSlideGroupIndex) % groupsToScroll\r\n\r\n  if (options.message === SlideNavigation.previous) {\r\n    slideGroupOffset =\r\n      indexOffset === 0 ? groupsToScroll : groupsToShow - indexOffset\r\n    targetSlideGroupIndex = currentSlideGroupIndex - slideGroupOffset\r\n    if (lazyLoad && !infinite) {\r\n      previousInt = currentSlideGroupIndex - slideGroupOffset\r\n      targetSlideGroupIndex =\r\n        previousInt === -1 ? slideGroupCount - 1 : previousInt\r\n    }\r\n  } else if (options.message === SlideNavigation.next) {\r\n    slideGroupOffset = indexOffset === 0 ? groupsToScroll : indexOffset\r\n    targetSlideGroupIndex = currentSlideGroupIndex + slideGroupOffset\r\n    if (lazyLoad && !infinite) {\r\n      targetSlideGroupIndex =\r\n        ((currentSlideGroupIndex + groupsToScroll) % slideGroupCount) +\r\n        indexOffset\r\n    }\r\n  } else if (options.message === 'dots') {\r\n    // Click on dots\r\n    targetSlideGroupIndex = (options.index || 0) * groupsToScroll\r\n    if (targetSlideGroupIndex === currentSlideGroupIndex) {\r\n      return null\r\n    }\r\n  } else if (options.message === 'children') {\r\n    // Click on the slides\r\n    targetSlideGroupIndex = options.index || 0\r\n    if (targetSlideGroupIndex === currentSlideGroupIndex) {\r\n      return null\r\n    }\r\n    if (infinite) {\r\n      let direction = siblingDirection({ ...spec, targetSlideGroupIndex })\r\n      if (\r\n        targetSlideGroupIndex > currentSlideGroupIndex &&\r\n        direction === 'left'\r\n      ) {\r\n        targetSlideGroupIndex = targetSlideGroupIndex - slideGroupCount\r\n      } else if (\r\n        targetSlideGroupIndex < currentSlideGroupIndex &&\r\n        direction === 'right'\r\n      ) {\r\n        targetSlideGroupIndex = targetSlideGroupIndex + slideGroupCount\r\n      }\r\n    }\r\n  } else if (options.message === 'index') {\r\n    targetSlideGroupIndex = Number(options.index)\r\n    if (targetSlideGroupIndex === currentSlideGroupIndex) {\r\n      return null\r\n    }\r\n  }\r\n  return targetSlideGroupIndex\r\n}\r\n\r\nexport const siblingDirection = (\r\n  spec: SlideGroupChangeSpec & { targetSlideGroupIndex: number }\r\n) => {\r\n  if (spec.targetSlideGroupIndex > spec.currentSlideGroupIndex) {\r\n    if (\r\n      spec.targetSlideGroupIndex >\r\n      spec.currentSlideGroupIndex + totalVisibleGroupsOnRightOfCurrGroup(spec)\r\n    ) {\r\n      return 'left'\r\n    }\r\n    return 'right'\r\n  } else {\r\n    if (\r\n      spec.targetSlideGroupIndex <\r\n      spec.currentSlideGroupIndex - totalVisibleGroupsOnLeftOfCurrGroup(spec)\r\n    ) {\r\n      return 'right'\r\n    }\r\n    return 'left'\r\n  }\r\n}\r\n\r\nconst totalVisibleGroupsOnRightOfCurrGroup = ({\r\n  groupsToShow,\r\n  centerMode,\r\n  rtl,\r\n  centerPadding\r\n}: SlideGroupChangeSpec) => {\r\n  if (centerMode) {\r\n    let right = (groupsToShow - 1) / 2 + 1\r\n    if (parseInt(centerPadding) > 0) right += 1\r\n    if (rtl && groupsToShow % 2 === 0) right += 1\r\n    return right\r\n  }\r\n  if (rtl) {\r\n    return 0\r\n  }\r\n  return groupsToShow - 1\r\n}\r\n\r\nconst totalVisibleGroupsOnLeftOfCurrGroup = ({\r\n  groupsToShow,\r\n  centerMode,\r\n  rtl,\r\n  centerPadding\r\n}: SlideGroupChangeSpec) => {\r\n  if (centerMode) {\r\n    let left = (groupsToShow - 1) / 2 + 1\r\n    if (parseInt(centerPadding) > 0) left += 1\r\n    if (!rtl && groupsToShow % 2 === 0) left += 1\r\n    return left\r\n  }\r\n  if (rtl) {\r\n    return groupsToShow - 1\r\n  }\r\n  return 0\r\n}\r\n\r\nexport const getNavigableIndexes = (spec: NavigableSpec) => {\r\n  let max = spec.infinite ? spec.slideGroupCount * 2 : spec.slideGroupCount\r\n  let breakpoint = spec.infinite ? spec.groupsToShow * -1 : 0\r\n  let counter = spec.infinite ? spec.groupsToShow * -1 : 0\r\n  let indexes = []\r\n  while (breakpoint < max) {\r\n    indexes.push(breakpoint)\r\n    breakpoint = counter + spec.groupsToScroll\r\n    counter += Math.min(spec.groupsToScroll, spec.groupsToShow)\r\n  }\r\n  return indexes\r\n}\r\n\r\nexport const checkNavigable = (spec: NavigableSpec, index: number) => {\r\n  const navigables = getNavigableIndexes(spec)\r\n  let prevNavigable = 0\r\n  if (index > navigables[navigables.length - 1]) {\r\n    index = navigables[navigables.length - 1]\r\n  } else {\r\n    for (let n in navigables) {\r\n      if (index < navigables[n]) {\r\n        index = prevNavigable\r\n        break\r\n      }\r\n      prevNavigable = navigables[n]\r\n    }\r\n  }\r\n  return index\r\n}\r\n\r\nexport const getSwipeStartState = (\r\n  e: SwipeEvent,\r\n  swipe: boolean,\r\n  draggable: boolean\r\n) => {\r\n  if (!swipe || (!draggable && e.type.indexOf('mouse') !== -1)) return\r\n  return {\r\n    dragging: true,\r\n    touchObject: {\r\n      startX:\r\n        window.TouchEvent && e instanceof TouchEvent\r\n          ? e.touches[0].pageX\r\n          : (e as MouseEvent).clientX,\r\n      startY:\r\n        window.TouchEvent && e instanceof TouchEvent\r\n          ? e.touches[0].pageY\r\n          : (e as MouseEvent).clientY,\r\n      curX:\r\n        window.TouchEvent && e instanceof TouchEvent\r\n          ? e.touches[0].pageX\r\n          : (e as MouseEvent).clientX,\r\n      curY:\r\n        window.TouchEvent && e instanceof TouchEvent\r\n          ? e.touches[0].pageY\r\n          : (e as MouseEvent).clientY\r\n    }\r\n  }\r\n}\r\n\r\nexport const getTraversedSlideGroupCount = (spec: SlideGroupCountSpec) => {\r\n  const centerOffset = spec.centerMode\r\n    ? +spec.slideGroupWidth * Math.floor(spec.groupsToShow / 2)\r\n    : 0\r\n  let swipedSlideGroup\r\n  const slickList = spec.listEl\r\n  const slideGroups = slickList.querySelectorAll<HTMLElement>(\r\n    '.v-slick-slide-group'\r\n  )\r\n  Array.from(slideGroups).every((grp) => {\r\n    if (!spec.vertical) {\r\n      if (\r\n        grp.offsetLeft - centerOffset + grp.offsetWidth / 2 >\r\n        spec.swipeLeft * -1\r\n      ) {\r\n        swipedSlideGroup = grp\r\n        return false\r\n      }\r\n    } else {\r\n      if (grp.offsetTop + grp.offsetHeight / 2 > spec.swipeLeft * -1) {\r\n        swipedSlideGroup = grp\r\n        return false\r\n      }\r\n    }\r\n\r\n    return true\r\n  })\r\n\r\n  if (!swipedSlideGroup) {\r\n    return 0\r\n  }\r\n  const currentIndex =\r\n    spec.rtl === true\r\n      ? spec.slideGroupCount - spec.currentSlideGroupIndex\r\n      : spec.currentSlideGroupIndex\r\n  const swipedSlideGroupIndex = (swipedSlideGroup as HTMLElement)?.dataset\r\n    ?.index\r\n  const groupsTraversed = Math.abs(\r\n    swipedSlideGroupIndex ? parseInt(swipedSlideGroupIndex) : 0 - currentIndex\r\n  )\r\n  return groupsTraversed\r\n}\r\n\r\nexport const getSwipeDirection = (\r\n  touchObject: TouchObject,\r\n  verticalSwiping = false\r\n): SwipeDirection => {\r\n  let xDist, yDist, r, swipeAngle\r\n  xDist = touchObject.startX - touchObject.curX\r\n  yDist = touchObject.startY - touchObject.curY\r\n  r = Math.atan2(yDist, xDist)\r\n  swipeAngle = Math.round((r * 180) / Math.PI)\r\n  if (swipeAngle < 0) {\r\n    swipeAngle = 360 - Math.abs(swipeAngle)\r\n  }\r\n  if (\r\n    (swipeAngle <= 45 && swipeAngle >= 0) ||\r\n    (swipeAngle <= 360 && swipeAngle >= 315)\r\n  ) {\r\n    return SwipeDirection.left\r\n  }\r\n  if (swipeAngle >= 135 && swipeAngle <= 225) {\r\n    return SwipeDirection.right\r\n  }\r\n  if (verticalSwiping === true) {\r\n    if (swipeAngle >= 35 && swipeAngle <= 135) {\r\n      return SwipeDirection.up\r\n    } else {\r\n      return SwipeDirection.down\r\n    }\r\n  }\r\n\r\n  return SwipeDirection.vertical\r\n}\r\n\r\nexport const getSwipeEndState = (\r\n  e: SwipeEvent,\r\n  spec: SwipeEndSpec\r\n): SwipeEndState | undefined => {\r\n  const {\r\n    dragging,\r\n    swipe,\r\n    touchObject,\r\n    listWidth,\r\n    touchThreshold,\r\n    verticalSwiping,\r\n    listHeight,\r\n    currentSlideGroupIndex,\r\n    swipeToSlide,\r\n    scrolling,\r\n    onSwipe,\r\n    rtl\r\n  } = spec\r\n  if (!dragging) {\r\n    if (swipe) e.preventDefault()\r\n    return\r\n  }\r\n  let minSwipe = verticalSwiping\r\n    ? listHeight / touchThreshold\r\n    : listWidth / touchThreshold\r\n  let swipeDirection = getSwipeDirection(touchObject, verticalSwiping)\r\n  if (rtl) {\r\n    if (swipeDirection === SwipeDirection.left) {\r\n      swipeDirection = SwipeDirection.right\r\n    } else if (swipeDirection === SwipeDirection.right) {\r\n      swipeDirection = SwipeDirection.left\r\n    }\r\n  }\r\n  // reset the state of touch related state variables.\r\n  let state: SwipeEndState = {\r\n    dragging: false,\r\n    edgeDragged: false,\r\n    scrolling: false,\r\n    swiping: false,\r\n    swiped: false,\r\n    swipeLeft: null,\r\n    touchObject: {}\r\n  }\r\n  if (scrolling) {\r\n    return state\r\n  }\r\n  if (!touchObject.swipeLength) {\r\n    return state\r\n  }\r\n  if (touchObject.swipeLength > minSwipe) {\r\n    e.preventDefault()\r\n    if (onSwipe) {\r\n      onSwipe(swipeDirection)\r\n    }\r\n    let slideGroupCount, newSlideGroupIndex\r\n    switch (swipeDirection) {\r\n      case 'left':\r\n      case 'up':\r\n        newSlideGroupIndex = spec.swipeToSlide\r\n          ? getTraversedSlideGroupCount(spec)\r\n          : currentSlideGroupIndex + spec.groupsToScroll\r\n        slideGroupCount = swipeToSlide\r\n          ? checkNavigable(spec, newSlideGroupIndex)\r\n          : newSlideGroupIndex\r\n        state.currentDirection = 0\r\n        break\r\n      case 'right':\r\n      case 'down':\r\n        newSlideGroupIndex = spec.swipeToSlide\r\n          ? getTraversedSlideGroupCount(spec)\r\n          : currentSlideGroupIndex - spec.groupsToScroll\r\n        slideGroupCount = swipeToSlide\r\n          ? checkNavigable(spec, newSlideGroupIndex)\r\n          : newSlideGroupIndex\r\n        state.currentDirection = 1\r\n        break\r\n      default:\r\n        slideGroupCount = currentSlideGroupIndex\r\n    }\r\n    state.triggerSlideGroupHandler = slideGroupCount\r\n  } else {\r\n    // Adjust the track back to its original position.\r\n    let currentLeft = getTrackLeft(spec)\r\n    state.trackStyle = getTrackAnimateCSS(spec, currentLeft)\r\n  }\r\n  return state\r\n}\r\n\r\nexport function getLazySlidesOnLeft(spec: LazyInfoSpec) {\r\n  return spec.centerMode\r\n    ? Math.floor(spec.groupsToShow / 2) +\r\n        (parseInt(spec.centerPadding) > 0 ? 1 : 0)\r\n    : 0\r\n}\r\n\r\nexport function getLazySlidesOnRight(spec: LazyInfoSpec) {\r\n  return spec.centerMode\r\n    ? Math.floor((spec.groupsToShow - 1) / 2) +\r\n        1 +\r\n        (parseInt(spec.centerPadding) > 0 ? 1 : 0)\r\n    : spec.groupsToShow\r\n}\r\n\r\nexport function getLazyStartIndex(spec: LazyInfoSpec) {\r\n  return spec.currentSlideGroupIndex - getLazySlidesOnLeft(spec)\r\n}\r\n\r\nexport function getLazyEndIndex(spec: LazyInfoSpec) {\r\n  return spec.currentSlideGroupIndex + getLazySlidesOnRight(spec)\r\n}\r\n\r\nexport function getOnDemandLazySlideGroups(spec: LazyInfoSpec) {\r\n  let onDemandSlideGroups = []\r\n  const startIndex = getLazyStartIndex(spec)\r\n  const endIndex = getLazyEndIndex(spec)\r\n  for (\r\n    let slideGroupIndex = startIndex;\r\n    slideGroupIndex < endIndex;\r\n    slideGroupIndex++\r\n  ) {\r\n    if (spec.lazyLoadedList?.indexOf(slideGroupIndex) < 0) {\r\n      onDemandSlideGroups.push(slideGroupIndex)\r\n    }\r\n  }\r\n  return onDemandSlideGroups\r\n}\r\n\r\nexport function getTrackCSS(spec: TrackInfoSpec, left: number) {\r\n  let trackWidth, trackHeight\r\n  const trackChildren = spec.slideGroupCount + 2 * spec.groupsToShow\r\n  if (!spec.vertical) {\r\n    trackWidth =\r\n      getTotalSlideGroups(spec) * parseInt(`${spec.slideGroupWidth || 0}`)\r\n  } else {\r\n    trackHeight = trackChildren * parseInt(`${spec.slideGroupHeight || 0}`)\r\n  }\r\n  let style: Record<string, string | number> = {\r\n    opacity: 1,\r\n    transition: ''\r\n  }\r\n  if (spec.useCSSTransform) {\r\n    let transform = !spec.vertical\r\n      ? 'translate3d(' + left + 'px, 0px, 0px)'\r\n      : 'translate3d(0px, ' + left + 'px, 0px)'\r\n    style = {\r\n      ...style,\r\n      transform\r\n    }\r\n  } else {\r\n    if (spec.vertical) {\r\n      style['top'] = left\r\n    } else {\r\n      style['left'] = left\r\n    }\r\n  }\r\n  if (spec.fade) style = { opacity: 1 }\r\n  if (trackWidth) style.width = trackWidth + 'px'\r\n  if (trackHeight) style.height = trackHeight + 'px'\r\n\r\n  return style\r\n}\r\n\r\nexport function getTotalSlideGroups(spec: TrackInfoSpec) {\r\n  return spec.slideGroupCount <= spec.groupsToShow\r\n    ? spec.slideGroupCount\r\n    : getTotalPreClones(spec) + spec.slideGroupCount + getTotalPostClones(spec)\r\n}\r\n\r\nexport function getTrackAnimateCSS(spec: TrackInfoSpec, left: number) {\r\n  let style = getTrackCSS(spec, left)\r\n  // useCSS is true by default so it can be undefined\r\n  if (spec.useCSSTransform) {\r\n    style.transition = 'transform ' + spec.speed + 'ms ' + spec.cssEase\r\n  } else {\r\n    if (spec.vertical) {\r\n      style.transition = 'top ' + spec.speed + 'ms ' + spec.cssEase\r\n    } else {\r\n      style.transition = 'left ' + spec.speed + 'ms ' + spec.cssEase\r\n    }\r\n  }\r\n  if (spec.ignorePrefersReducedMotion) {\r\n    style.transition += ' !important'\r\n  }\r\n  return style\r\n}\r\n\r\nexport function getTrackLeft(spec: TrackInfoSpec) {\r\n  let {\r\n    centerPadding,\r\n    currentSlideGroupIndex,\r\n    trackEl,\r\n    infinite,\r\n    centerMode,\r\n    slideGroupCount,\r\n    groupsToShow,\r\n    groupsToScroll,\r\n    slideGroupWidth,\r\n    listWidth,\r\n    variableWidth,\r\n    slideGroupHeight,\r\n    fade,\r\n    vertical,\r\n    rtl\r\n  } = spec\r\n  listWidth = listWidth || 0\r\n  slideGroupWidth = slideGroupWidth || 0\r\n  slideGroupHeight = slideGroupHeight || 0\r\n\r\n  let slideGroupOffset = 0\r\n  let targetLeft\r\n  let targetSlide: HTMLElement\r\n  let verticalOffset = 0\r\n\r\n  if (fade || slideGroupCount === 1) {\r\n    return 0\r\n  }\r\n\r\n  let slidesToOffset = 0\r\n  if (infinite) {\r\n    slidesToOffset = -getTotalPreClones(spec) // bring active slide to the beginning of visible area\r\n    // if next scroll doesn't have enough children, just reach till the end of original slides instead of shifting groupsToScroll children\r\n    if (\r\n      slideGroupCount % groupsToScroll !== 0 &&\r\n      currentSlideGroupIndex + groupsToScroll > slideGroupCount\r\n    ) {\r\n      slidesToOffset = -(currentSlideGroupIndex > slideGroupCount\r\n        ? groupsToShow - (currentSlideGroupIndex - slideGroupCount)\r\n        : slideGroupCount % groupsToScroll)\r\n    }\r\n    // in center mode, shift current slide group to the center of the frame\r\n    if (centerMode) {\r\n      slidesToOffset += Math.floor(groupsToShow / 2)\r\n    }\r\n  } else {\r\n    if (\r\n      slideGroupCount % groupsToScroll !== 0 &&\r\n      currentSlideGroupIndex + groupsToScroll > slideGroupCount\r\n    ) {\r\n      slidesToOffset = groupsToShow - (slideGroupCount % groupsToScroll)\r\n    }\r\n    if (centerMode) {\r\n      slidesToOffset = Math.floor(groupsToShow / 2)\r\n    }\r\n  }\r\n  slideGroupOffset = slidesToOffset * parseInt(`${slideGroupWidth}`)\r\n  verticalOffset = slidesToOffset * parseInt(`${slideGroupHeight}`)\r\n\r\n  if (!vertical) {\r\n    targetLeft =\r\n      currentSlideGroupIndex * parseInt(`${slideGroupWidth}`) * -1 +\r\n      slideGroupOffset\r\n  } else {\r\n    targetLeft =\r\n      currentSlideGroupIndex * parseInt(`${slideGroupHeight}`) * -1 +\r\n      verticalOffset\r\n  }\r\n\r\n  if (variableWidth === true) {\r\n    let targetSlideIndex\r\n    targetSlideIndex = currentSlideGroupIndex + getTotalPreClones(spec)\r\n    targetSlide =\r\n      trackEl && (trackEl.childNodes[targetSlideIndex] as HTMLElement)\r\n    targetLeft = targetSlide ? targetSlide.offsetLeft * -1 : 0\r\n    if (centerMode === true) {\r\n      targetSlideIndex = infinite\r\n        ? currentSlideGroupIndex + getTotalPreClones(spec)\r\n        : currentSlideGroupIndex\r\n      targetSlide =\r\n        trackEl && (trackEl.children[targetSlideIndex] as HTMLElement)\r\n      targetLeft = 0\r\n      for (let slide = 0; slide < targetSlideIndex; slide++) {\r\n        targetLeft -=\r\n          trackEl &&\r\n          trackEl.children[slide] &&\r\n          (trackEl.children[slide] as HTMLElement).offsetWidth\r\n      }\r\n      targetLeft -= parseInt(centerPadding)\r\n      targetLeft += targetSlide && (listWidth - targetSlide.offsetWidth) / 2\r\n    }\r\n  }\r\n\r\n  if (rtl) targetLeft = -targetLeft\r\n\r\n  return targetLeft\r\n}\r\n\r\nexport const canGoPrev = (spec: GoPrevSpec) => {\r\n  return (\r\n    spec.infinite ||\r\n    (spec.currentSlideGroupIndex !== 0 &&\r\n      spec.slideGroupCount > spec.groupsToShow)\r\n  )\r\n}\r\n\r\nexport const canGoNext = (spec: GoNextSpec) => {\r\n  let canGo = true\r\n  if (!spec.infinite) {\r\n    if (spec.centerMode) {\r\n      canGo = spec.currentSlideGroupIndex < spec.slideGroupCount - 1\r\n    } else if (\r\n      spec.slideGroupCount <= spec.groupsToShow ||\r\n      spec.currentSlideGroupIndex >= spec.slideGroupCount - spec.groupsToShow\r\n    ) {\r\n      canGo = false\r\n    }\r\n  }\r\n  return canGo\r\n}\r\n\r\nexport const getStatesOnSlide = (spec: OnSlideSpec) => {\r\n  let {\r\n    waitForAnimate,\r\n    animating,\r\n    fade,\r\n    infinite,\r\n    index,\r\n    slideGroupCount,\r\n    lazyLoadedList,\r\n    lazyLoad,\r\n    currentSlideGroupIndex,\r\n    centerMode,\r\n    groupsToScroll,\r\n    groupsToShow,\r\n    useCSSTransitions\r\n  } = spec\r\n  if (\r\n    (waitForAnimate && animating) ||\r\n    (fade && !infinite && (index < 0 || index >= slideGroupCount))\r\n  )\r\n    return\r\n  let animationSlideGroupIndex = index,\r\n    finalSlideGroupIndex\r\n  let slidingState: Partial<SliderState> = {},\r\n    afterSlidingState: Partial<SliderState> = {}\r\n  if (fade) {\r\n    if (index < 0) {\r\n      animationSlideGroupIndex += slideGroupCount\r\n    } else if (index >= slideGroupCount) {\r\n      animationSlideGroupIndex -= slideGroupCount\r\n    }\r\n    if (lazyLoad && lazyLoadedList.indexOf(animationSlideGroupIndex) < 0) {\r\n      lazyLoadedList.push(animationSlideGroupIndex)\r\n    }\r\n    slidingState = {\r\n      animating: true,\r\n      currentSlideGroupIndex: animationSlideGroupIndex,\r\n      lazyLoadedList\r\n    }\r\n    afterSlidingState = { animating: false }\r\n    return {\r\n      slidingState,\r\n      afterSlidingState\r\n    }\r\n  }\r\n  finalSlideGroupIndex = animationSlideGroupIndex\r\n  if (animationSlideGroupIndex < 0) {\r\n    finalSlideGroupIndex = animationSlideGroupIndex + slideGroupCount\r\n    if (!infinite) finalSlideGroupIndex = 0\r\n    else if (slideGroupCount % groupsToScroll !== 0)\r\n      finalSlideGroupIndex =\r\n        slideGroupCount - (slideGroupCount % groupsToScroll)\r\n  } else if (\r\n    !canGoNext(spec) &&\r\n    animationSlideGroupIndex > currentSlideGroupIndex\r\n  ) {\r\n    animationSlideGroupIndex = finalSlideGroupIndex = currentSlideGroupIndex\r\n  } else if (centerMode && animationSlideGroupIndex >= slideGroupCount) {\r\n    animationSlideGroupIndex = infinite ? slideGroupCount : slideGroupCount - 1\r\n    finalSlideGroupIndex = infinite ? 0 : slideGroupCount - 1\r\n  } else if (animationSlideGroupIndex >= slideGroupCount) {\r\n    finalSlideGroupIndex = animationSlideGroupIndex - slideGroupCount\r\n    if (!infinite) finalSlideGroupIndex = slideGroupCount - groupsToShow\r\n    else if (slideGroupCount % groupsToScroll !== 0) finalSlideGroupIndex = 0\r\n  }\r\n  let finalLeft = getTrackLeft({\r\n    ...spec,\r\n    currentSlideGroupIndex: finalSlideGroupIndex\r\n  })\r\n  let animationLeft = getTrackLeft({\r\n    ...spec,\r\n    currentSlideGroupIndex: animationSlideGroupIndex\r\n  })\r\n  if (!infinite) {\r\n    if (animationLeft === finalLeft)\r\n      animationSlideGroupIndex = finalSlideGroupIndex\r\n    animationLeft = finalLeft\r\n  }\r\n  if (lazyLoad)\r\n    lazyLoadedList = lazyLoadedList.concat(\r\n      getOnDemandLazySlideGroups({\r\n        ...spec,\r\n        currentSlideGroupIndex: animationSlideGroupIndex\r\n      })\r\n    )\r\n  if (!useCSSTransitions) {\r\n    slidingState = {\r\n      currentSlideGroupIndex: finalSlideGroupIndex,\r\n      trackStyle: getTrackCSS(spec, finalLeft),\r\n      lazyLoadedList\r\n    }\r\n    return {\r\n      slidingState,\r\n      afterSlidingState\r\n    }\r\n  }\r\n  slidingState = {\r\n    animating: true,\r\n    currentSlideGroupIndex: finalSlideGroupIndex,\r\n    trackStyle: getTrackAnimateCSS(spec, animationLeft),\r\n    lazyLoadedList\r\n  }\r\n  afterSlidingState = {\r\n    animating: false,\r\n    currentSlideGroupIndex: finalSlideGroupIndex,\r\n    trackStyle: getTrackCSS(spec, finalLeft),\r\n    swipeLeft: undefined\r\n  }\r\n  return { slidingState, afterSlidingState }\r\n}\r\n\r\nexport function getTotalPreClones(spec: CloneInfoSpec) {\r\n  if (!spec.infinite) {\r\n    return 0\r\n  }\r\n  if (spec.variableWidth) {\r\n    return spec.slideGroupCount\r\n  }\r\n  return spec.groupsToShow + (spec.centerMode ? 1 : 0)\r\n}\r\n\r\nexport function getTotalPostClones(spec: CloneInfoSpec) {\r\n  if (!spec.infinite) {\r\n    return 0\r\n  }\r\n  return spec.slideGroupCount\r\n}\r\n\r\nexport const getSwipeMoveState = (\r\n  e: SwipeEvent,\r\n  spec: SwipeMoveSpec\r\n): SwipeMoveState | undefined => {\r\n  const {\r\n    scrolling,\r\n    animating,\r\n    vertical,\r\n    swipeToSlide,\r\n    verticalSwiping,\r\n    rtl,\r\n    currentSlideGroupIndex,\r\n    edgeFriction,\r\n    edgeDragged,\r\n    onEdge,\r\n    swiped,\r\n    swiping,\r\n    slideGroupCount,\r\n    groupsToScroll,\r\n    infinite,\r\n    touchObject,\r\n    swipeEvent,\r\n    listHeight,\r\n    listWidth\r\n  } = spec\r\n  if (scrolling) return\r\n  if (animating) {\r\n    e.preventDefault()\r\n    return\r\n  }\r\n  if (vertical && swipeToSlide && verticalSwiping) e.preventDefault()\r\n  let swipeLeft,\r\n    state: SwipeMoveState = {}\r\n  let curLeft = getTrackLeft(spec)\r\n  touchObject.curX =\r\n    window.TouchEvent && e instanceof TouchEvent\r\n      ? e.touches[0].pageX\r\n      : (e as MouseEvent).clientX\r\n  touchObject.curY =\r\n    window.TouchEvent && e instanceof TouchEvent\r\n      ? e.touches[0].pageY\r\n      : (e as MouseEvent).clientY\r\n  touchObject.swipeLength = Math.round(\r\n    Math.sqrt(Math.pow(touchObject.curX - touchObject.startX, 2))\r\n  )\r\n  let verticalSwipeLength = Math.round(\r\n    Math.sqrt(Math.pow(touchObject.curY - touchObject.startY, 2))\r\n  )\r\n  if (!verticalSwiping && !swiping && verticalSwipeLength > 10) {\r\n    return { scrolling: true }\r\n  }\r\n  if (verticalSwiping) touchObject.swipeLength = verticalSwipeLength\r\n  let positionOffset =\r\n    (!rtl ? 1 : -1) * (touchObject.curX > touchObject.startX ? 1 : -1)\r\n  if (verticalSwiping)\r\n    positionOffset = touchObject.curY > touchObject.startY ? 1 : -1\r\n\r\n  let dotCount = Math.ceil(slideGroupCount / groupsToScroll)\r\n  let swipeDirection = getSwipeDirection(spec.touchObject, verticalSwiping)\r\n  let touchSwipeLength = touchObject.swipeLength\r\n  if (!infinite) {\r\n    if (\r\n      (currentSlideGroupIndex === 0 && swipeDirection === 'right') ||\r\n      (currentSlideGroupIndex + 1 >= dotCount && swipeDirection === 'left') ||\r\n      (!canGoNext(spec) && swipeDirection === 'left')\r\n    ) {\r\n      touchSwipeLength = Math.round(touchObject.swipeLength * edgeFriction)\r\n      if (edgeDragged === false && onEdge) {\r\n        onEdge(swipeDirection)\r\n        state.edgeDragged = true\r\n      }\r\n    }\r\n  }\r\n  if (!swiped && swipeEvent) {\r\n    swipeEvent(swipeDirection)\r\n    state.swiped = true\r\n  }\r\n  if (!vertical) {\r\n    if (!rtl) {\r\n      swipeLeft = curLeft + touchSwipeLength * positionOffset\r\n    } else {\r\n      swipeLeft = curLeft - touchSwipeLength * positionOffset\r\n    }\r\n  } else {\r\n    swipeLeft =\r\n      curLeft + touchSwipeLength * (listHeight / listWidth) * positionOffset\r\n  }\r\n  if (verticalSwiping) {\r\n    swipeLeft = curLeft + touchSwipeLength * positionOffset\r\n  }\r\n  state = {\r\n    ...state,\r\n    touchObject,\r\n    swipeLeft,\r\n    trackStyle: getTrackCSS(spec, swipeLeft)\r\n  }\r\n  if (\r\n    Math.abs(touchObject.curX - touchObject.startX) <\r\n    Math.abs(touchObject.curY - touchObject.startY) * 0.8\r\n  ) {\r\n    return state\r\n  }\r\n  if (touchObject.swipeLength > 10) {\r\n    state.swiping = true\r\n    e.preventDefault()\r\n  }\r\n  return state\r\n}\r\n\r\nexport function getSlideGroupCount(slideCount: number, groupsToShow: number) {\r\n  return Math.ceil(slideCount / groupsToShow)\r\n}\r\n\r\nexport function getSliderState(spec: SliderStateInfoSpec) {\r\n  let slideGroupCount = getSlideGroupCount(\r\n    spec.slides.length,\r\n    spec.groupsToShow\r\n  )\r\n  let listWidth = Math.ceil(spec.listEl?.offsetWidth || 0)\r\n  let trackWidth = Math.ceil(spec.trackEl?.offsetWidth || 0)\r\n  let slideGroupWidth\r\n  if (!spec.vertical) {\r\n    let centerPaddingAdj = spec.centerMode\r\n      ? parseInt(spec.centerPadding) * 2\r\n      : 0\r\n    if (\r\n      typeof spec.centerPadding === 'string' &&\r\n      spec.centerPadding.slice(-1) === '%'\r\n    ) {\r\n      centerPaddingAdj *= listWidth / 100\r\n    }\r\n    slideGroupWidth = Math.ceil(\r\n      (listWidth - centerPaddingAdj) / spec.groupsToShow\r\n    )\r\n  } else {\r\n    slideGroupWidth = listWidth\r\n  }\r\n  let slideGroupHeight =\r\n    spec.listEl && spec.listEl.querySelector('[data-index=\"0\"]')\r\n      ? spec.listEl.querySelector<HTMLElement>('[data-index=\"0\"]')\r\n          ?.offsetHeight || 0\r\n      : 0\r\n  let listHeight = slideGroupHeight * spec.groupsToShow\r\n  let currentSlideGroupIndex =\r\n    spec.currentSlideGroupIndex === undefined\r\n      ? spec.initialGroupIndex\r\n      : spec.currentSlideGroupIndex\r\n  if (spec.rtl && spec.currentSlideGroupIndex === undefined) {\r\n    currentSlideGroupIndex = slideGroupCount - 1 - spec.initialGroupIndex\r\n  }\r\n  let lazyLoadedList = spec.lazyLoadedList || []\r\n  let slideGroupsToLoad = getOnDemandLazySlideGroups(spec as LazyInfoSpec)\r\n  lazyLoadedList.concat(slideGroupsToLoad)\r\n\r\n  let sliderState: MarkRequiredWithPartialBase<\r\n    SliderState,\r\n    | 'currentSlideGroupIndex'\r\n    | 'listWidth'\r\n    | 'slideGroupHeight'\r\n    | 'slideGroupWidth'\r\n  > & { slideGroupCount: number } = {\r\n    slideGroupCount,\r\n    slideGroupWidth,\r\n    listWidth,\r\n    trackWidth,\r\n    currentSlideGroupIndex,\r\n    slideGroupHeight,\r\n    listHeight,\r\n    lazyLoadedList\r\n  }\r\n\r\n  if (spec.autoplaying === null && spec.autoplay) {\r\n    sliderState.autoplaying = PlayingType.playing\r\n  }\r\n\r\n  return sliderState\r\n}\r\n","export * from './carousel-utils'\r\n\r\nexport const canUseDOM = () =>\r\n  !!(\r\n    typeof window !== 'undefined' &&\r\n    window.document &&\r\n    window.document.createElement\r\n  )\r\n\r\nexport const filterUndefined = <T extends object>(props: T) =>\r\n  Object.keys(props)\r\n    .filter((key) => props[key as keyof T] !== undefined)\r\n    .reduce((acc, key) => {\r\n      acc[key as keyof T] = props[key as keyof T]\r\n      return acc\r\n    }, {} as T)\r\n\r\nexport function clearSelection() {\r\n  if (!window.getSelection) return\r\n  if (window.getSelection()?.empty) {\r\n    window.getSelection()!.empty()\r\n  } else if (window.getSelection()?.removeAllRanges) {\r\n    window.getSelection()!.removeAllRanges()\r\n  }\r\n}\r\n","import { PropType, VNode } from 'vue'\r\nimport {\r\n  ArrowProps,\r\n  DotsProps,\r\n  Props,\r\n  Responsive,\r\n  SlideNavigation,\r\n  SliderState,\r\n  TrackProps,\r\n  WidthDetection\r\n} from '../types'\r\n\r\ntype VuePropDef<T extends string> = Record<\r\n  T,\r\n  { type: PropType<unknown>; default: unknown }\r\n>\r\n\r\nconst makeDefaultProps = (selectFields?: string[]) => {\r\n  const defaultProps = {\r\n    accessibility: { type: Boolean, default: true },\r\n    adaptiveHeight: { type: Boolean, default: false },\r\n    arrows: { type: Boolean, default: true },\r\n    asNavFor: {\r\n      type: Object,\r\n      default: null\r\n    },\r\n    autoplay: { type: Boolean, default: false },\r\n    autoplaySpeed: { type: Number, default: 3000 },\r\n    centerMode: { type: Boolean, default: false },\r\n    centerPadding: { type: String, default: '50px' },\r\n    cssEase: { type: String, default: 'ease' },\r\n    dots: { type: Boolean, default: false },\r\n    dotsClass: { type: String, default: 'v-slick-dots' },\r\n    draggable: { type: Boolean, default: true },\r\n    edgeFriction: { type: Number, default: 0.35 },\r\n    fade: { type: Boolean, default: false },\r\n    focusOnSelect: { type: Boolean, default: false },\r\n    ignorePrefersReducedMotion: { type: Boolean, default: false },\r\n    infinite: { type: Boolean, default: true },\r\n    initialGroupIndex: { type: Number, default: 0 },\r\n    lazyLoad: { type: String, default: null },\r\n    nextArrowLabel: { type: String, default: 'Next' },\r\n    pauseOnDotsHover: { type: Boolean, default: false },\r\n    pauseOnFocus: { type: Boolean, default: false },\r\n    pauseOnHover: { type: Boolean, default: true },\r\n    prevArrowLabel: { type: String, default: 'Previous' },\r\n    responsive: { type: Array as PropType<Responsive[]>, default: [] },\r\n    rtl: { type: Boolean, default: false },\r\n    slidesPerGroup: { type: Number, default: 1 },\r\n    groupsToScroll: { type: Number, default: 1 },\r\n    groupsToShow: { type: Number, default: 1 },\r\n    speed: { type: Number, default: 500 },\r\n    swipe: { type: Boolean, default: true },\r\n    swipeToSlide: { type: Boolean, default: false },\r\n    touchMove: { type: Boolean, default: true },\r\n    touchThreshold: { type: Number, default: 5 },\r\n    useCSSTransitions: { type: Boolean, default: true },\r\n    useCSSTransform: { type: Boolean, default: true },\r\n    variableWidth: { type: Boolean, default: false },\r\n    vertical: { type: Boolean, default: false },\r\n    verticalSwiping: { type: Boolean, default: false },\r\n    waitForAnimate: { type: Boolean, default: true },\r\n    widthDetection: { type: String, default: WidthDetection.auto }\r\n  } satisfies VuePropDef<keyof Props>\r\n  if (!selectFields) return defaultProps\r\n  return Object.keys(defaultProps).reduce<{\r\n    [key: string]: { type: PropType<unknown>; default: unknown }\r\n  }>((acc, key) => {\r\n    if (selectFields.includes(key)) {\r\n      acc[key as keyof Props] = (defaultProps as any)[key]\r\n    }\r\n    return acc\r\n  }, {}) as typeof defaultProps\r\n}\r\n\r\nexport const defaultProps = makeDefaultProps() satisfies VuePropDef<keyof Props>\r\n\r\nexport const defaultPropValues = Object.keys(defaultProps).reduce<{\r\n  [key: string]: unknown\r\n}>((acc, key) => {\r\n  acc[key] = (defaultProps as any)[key].default\r\n  return acc\r\n}, {}) as {\r\n  [K in keyof Props]: unknown\r\n} as Props\r\n\r\nexport const makeDefaultSliderState: () => SliderState = () => ({\r\n  animating: false,\r\n  autoplaying: null,\r\n  autoplayTimer: null,\r\n  currentDirection: 0,\r\n  currentLeft: null,\r\n  currentSlideGroupIndex: 0,\r\n  detectingWidth: false,\r\n  direction: 1,\r\n  dragging: false,\r\n  edgeDragged: false,\r\n  initialized: false,\r\n  lazyLoadedList: [],\r\n  listHeight: undefined,\r\n  listWidth: undefined,\r\n  scrolling: false,\r\n  slideGroupHeight: undefined,\r\n  slideGroupWidth: undefined,\r\n  swipeLeft: undefined,\r\n  swiped: false,\r\n  swiping: false,\r\n  touchObject: { startX: 0, startY: 0, curX: 0, curY: 0, swipeLength: 0 },\r\n  trackStyle: {},\r\n  trackWidth: 0\r\n})\r\n\r\nexport const defaultTrackProps = {\r\n  ...makeDefaultProps([\r\n    'centerMode',\r\n    'centerPadding',\r\n    'cssEase',\r\n    'fade',\r\n    'ignorePrefersReducedMotion',\r\n    'infinite',\r\n    'lazyLoad',\r\n    'rtl',\r\n    'groupsToScroll',\r\n    'groupsToShow',\r\n    'speed',\r\n    'variableWidth',\r\n    'vertical'\r\n  ]),\r\n  ...{\r\n    currentSlideGroupIndex: { type: Number, default: 0 },\r\n    detectingWidth: { type: Boolean, default: false },\r\n    lazyLoadedList: {\r\n      type: Array as PropType<number[]>,\r\n      default: []\r\n    },\r\n    listHeight: { type: Number, default: undefined },\r\n    trackStyle: { type: Object, default: {} },\r\n    slideGroupCount: { type: Number, default: 0 },\r\n    rawSlideGroups: { type: Array as PropType<VNode[][]>, default: [] },\r\n    slideGroupHeight: { type: [String, Number], default: undefined },\r\n    slideGroupWidth: { type: [String, Number], default: undefined }\r\n  }\r\n} satisfies VuePropDef<keyof TrackProps>\r\n\r\nexport const defaultArrowProps = {\r\n  ...makeDefaultProps([\r\n    'centerMode',\r\n    'infinite',\r\n    'groupsToShow',\r\n    'prevArrowLabel',\r\n    'nextArrowLabel'\r\n  ]),\r\n  ...{\r\n    currentSlideGroupIndex: { type: Number, default: 0 },\r\n    disabled: { type: Boolean, default: false },\r\n    slideGroupCount: { type: Number, default: 0 },\r\n    type: { type: String as PropType<SlideNavigation>, default: 'prev' }\r\n  }\r\n} satisfies VuePropDef<keyof ArrowProps>\r\n\r\nexport const defaultDotsProps = {\r\n  ...makeDefaultProps([\r\n    'dotsClass',\r\n    'infinite',\r\n    'groupsToScroll',\r\n    'groupsToShow'\r\n  ]),\r\n  ...{\r\n    currentSlideGroupIndex: { type: Number, default: 0 },\r\n    slideGroupCount: { type: Number, default: 0 },\r\n    pageCount: { type: Number, default: 0 }\r\n  }\r\n} satisfies VuePropDef<keyof DotsProps>\r\n","/**\r\n * Delegate to handle a media query being matched and unmatched.\r\n *\r\n * @param {object} options\r\n * @param {function} options.match callback for when the media query is matched\r\n * @param {function} [options.unmatch] callback for when the media query is unmatched\r\n * @param {function} [options.setup] one-time callback triggered the first time a query is matched\r\n * @param {boolean} [options.deferSetup=false] should the setup callback be run immediately, rather than first time query is matched?\r\n * @constructor\r\n */\r\nfunction QueryHandler(options) {\r\n    this.options = options;\r\n    !options.deferSetup && this.setup();\r\n}\r\n\r\nQueryHandler.prototype = {\r\n\r\n    constructor : QueryHandler,\r\n\r\n    /**\r\n     * coordinates setup of the handler\r\n     *\r\n     * @function\r\n     */\r\n    setup : function() {\r\n        if(this.options.setup) {\r\n            this.options.setup();\r\n        }\r\n        this.initialised = true;\r\n    },\r\n\r\n    /**\r\n     * coordinates setup and triggering of the handler\r\n     *\r\n     * @function\r\n     */\r\n    on : function() {\r\n        !this.initialised && this.setup();\r\n        this.options.match && this.options.match();\r\n    },\r\n\r\n    /**\r\n     * coordinates the unmatch event for the handler\r\n     *\r\n     * @function\r\n     */\r\n    off : function() {\r\n        this.options.unmatch && this.options.unmatch();\r\n    },\r\n\r\n    /**\r\n     * called when a handler is to be destroyed.\r\n     * delegates to the destroy or unmatch callbacks, depending on availability.\r\n     *\r\n     * @function\r\n     */\r\n    destroy : function() {\r\n        this.options.destroy ? this.options.destroy() : this.off();\r\n    },\r\n\r\n    /**\r\n     * determines equality by reference.\r\n     * if object is supplied compare options, if function, compare match callback\r\n     *\r\n     * @function\r\n     * @param {object || function} [target] the target for comparison\r\n     */\r\n    equals : function(target) {\r\n        return this.options === target || this.options.match === target;\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = QueryHandler;\r\n","/**\r\n * Helper function for iterating over a collection\r\n *\r\n * @param collection\r\n * @param fn\r\n */\r\nfunction each(collection, fn) {\r\n    var i      = 0,\r\n        length = collection.length,\r\n        cont;\r\n\r\n    for(i; i < length; i++) {\r\n        cont = fn(collection[i], i);\r\n        if(cont === false) {\r\n            break; //allow early exit\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Helper function for determining whether target object is an array\r\n *\r\n * @param target the object under test\r\n * @return {Boolean} true if array, false otherwise\r\n */\r\nfunction isArray(target) {\r\n    return Object.prototype.toString.apply(target) === '[object Array]';\r\n}\r\n\r\n/**\r\n * Helper function for determining whether target object is a function\r\n *\r\n * @param target the object under test\r\n * @return {Boolean} true if function, false otherwise\r\n */\r\nfunction isFunction(target) {\r\n    return typeof target === 'function';\r\n}\r\n\r\nmodule.exports = {\r\n    isFunction : isFunction,\r\n    isArray : isArray,\r\n    each : each\r\n};\r\n","var QueryHandler = require('./QueryHandler');\r\nvar each = require('./Util').each;\r\n\r\n/**\r\n * Represents a single media query, manages it's state and registered handlers for this query\r\n *\r\n * @constructor\r\n * @param {string} query the media query string\r\n * @param {boolean} [isUnconditional=false] whether the media query should run regardless of whether the conditions are met. Primarily for helping older browsers deal with mobile-first design\r\n */\r\nfunction MediaQuery(query, isUnconditional) {\r\n    this.query = query;\r\n    this.isUnconditional = isUnconditional;\r\n    this.handlers = [];\r\n    this.mql = window?.matchMedia(query);\r\n\r\n    var self = this;\r\n    this.listener = function(mql) {\r\n        // Chrome passes an MediaQueryListEvent object, while other browsers pass MediaQueryList directly\r\n        self.mql = mql.currentTarget || mql;\r\n        self.assess();\r\n    };\r\n    this.mql.addListener(this.listener);\r\n}\r\n\r\nMediaQuery.prototype = {\r\n\r\n    constuctor : MediaQuery,\r\n\r\n    /**\r\n     * add a handler for this query, triggering if already active\r\n     *\r\n     * @param {object} handler\r\n     * @param {function} handler.match callback for when query is activated\r\n     * @param {function} [handler.unmatch] callback for when query is deactivated\r\n     * @param {function} [handler.setup] callback for immediate execution when a query handler is registered\r\n     * @param {boolean} [handler.deferSetup=false] should the setup callback be deferred until the first time the handler is matched?\r\n     */\r\n    addHandler : function(handler) {\r\n        var qh = new QueryHandler(handler);\r\n        this.handlers.push(qh);\r\n\r\n        this.matches() && qh.on();\r\n    },\r\n\r\n    /**\r\n     * removes the given handler from the collection, and calls it's destroy methods\r\n     *\r\n     * @param {object || function} handler the handler to remove\r\n     */\r\n    removeHandler : function(handler) {\r\n        var handlers = this.handlers;\r\n        each(handlers, function(h, i) {\r\n            if(h.equals(handler)) {\r\n                h.destroy();\r\n                return !handlers.splice(i,1); //remove from array and exit each early\r\n            }\r\n        });\r\n    },\r\n\r\n    /**\r\n     * Determine whether the media query should be considered a match\r\n     *\r\n     * @return {Boolean} true if media query can be considered a match, false otherwise\r\n     */\r\n    matches : function() {\r\n        return this.mql.matches || this.isUnconditional;\r\n    },\r\n\r\n    /**\r\n     * Clears all handlers and unbinds events\r\n     */\r\n    clear : function() {\r\n        each(this.handlers, function(handler) {\r\n            handler.destroy();\r\n        });\r\n        this.mql.removeListener(this.listener);\r\n        this.handlers.length = 0; //clear array\r\n    },\r\n\r\n    /*\r\n        * Assesses the query, turning on all handlers if it matches, turning them off if it doesn't match\r\n        */\r\n    assess : function() {\r\n        var action = this.matches() ? 'on' : 'off';\r\n\r\n        each(this.handlers, function(handler) {\r\n            handler[action]();\r\n        });\r\n    }\r\n};\r\n\r\nmodule.exports = MediaQuery;\r\n","var MediaQuery = require('./MediaQuery');\r\nvar Util = require('./Util');\r\nvar each = Util.each;\r\nvar isFunction = Util.isFunction;\r\nvar isArray = Util.isArray;\r\n\r\n/**\r\n * Allows for registration of query handlers.\r\n * Manages the query handler's state and is responsible for wiring up browser events\r\n *\r\n * @constructor\r\n */\r\nfunction MediaQueryDispatch () {\r\n    if(typeof window !== 'undefined' && !window.matchMedia) {\r\n        throw new Error('matchMedia not present, legacy browsers require a polyfill');\r\n    }\r\n\r\n    this.queries = {};\r\n    if (typeof window !== 'undefined') {\r\n        this.browserIsIncapable = !window.matchMedia('only all').matches;\r\n    }\r\n}\r\n\r\nMediaQueryDispatch.prototype = {\r\n\r\n    constructor : MediaQueryDispatch,\r\n\r\n    /**\r\n     * Registers a handler for the given media query\r\n     *\r\n     * @param {string} q the media query\r\n     * @param {object || Array || Function} options either a single query handler object, a function, or an array of query handlers\r\n     * @param {function} options.match fired when query matched\r\n     * @param {function} [options.unmatch] fired when a query is no longer matched\r\n     * @param {function} [options.setup] fired when handler first triggered\r\n     * @param {boolean} [options.deferSetup=false] whether setup should be run immediately or deferred until query is first matched\r\n     * @param {boolean} [shouldDegrade=false] whether this particular media query should always run on incapable browsers\r\n     */\r\n    register : function(q, options, shouldDegrade) {\r\n        var queries         = this.queries,\r\n            isUnconditional = shouldDegrade && this.browserIsIncapable;\r\n\r\n        if(!queries[q]) {\r\n            queries[q] = new MediaQuery(q, isUnconditional);\r\n        }\r\n\r\n        //normalise to object in an array\r\n        if(isFunction(options)) {\r\n            options = { match : options };\r\n        }\r\n        if(!isArray(options)) {\r\n            options = [options];\r\n        }\r\n        each(options, function(handler) {\r\n            if (isFunction(handler)) {\r\n                handler = { match : handler };\r\n            }\r\n            queries[q].addHandler(handler);\r\n        });\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * unregisters a query and all it's handlers, or a specific handler for a query\r\n     *\r\n     * @param {string} q the media query to target\r\n     * @param {object || function} [handler] specific handler to unregister\r\n     */\r\n    unregister : function(q, handler) {\r\n        var query = this.queries[q];\r\n\r\n        if(query) {\r\n            if(handler) {\r\n                query.removeHandler(handler);\r\n            }\r\n            else {\r\n                query.clear();\r\n                delete this.queries[q];\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n};\r\n\r\nmodule.exports = MediaQueryDispatch;\r\n","var MediaQueryDispatch = require('./MediaQueryDispatch');\r\nmodule.exports = new MediaQueryDispatch();\r\n","var camel2hyphen = function (str) {\n  return str\n          .replace(/[A-Z]/g, function (match) {\n            return '-' + match.toLowerCase();\n          })\n          .toLowerCase();\n};\n\nmodule.exports = camel2hyphen;","var camel2hyphen = require('string-convert/camel2hyphen');\n\nvar isDimension = function (feature) {\n  var re = /[height|width]$/;\n  return re.test(feature);\n};\n\nvar obj2mq = function (obj) {\n  var mq = '';\n  var features = Object.keys(obj);\n  features.forEach(function (feature, index) {\n    var value = obj[feature];\n    feature = camel2hyphen(feature);\n    // Add px to dimension features\n    if (isDimension(feature) && typeof value === 'number') {\n      value = value + 'px';\n    }\n    if (value === true) {\n      mq += feature;\n    } else if (value === false) {\n      mq += 'not ' + feature;\n    } else {\n      mq += '(' + feature + ': ' + value + ')';\n    }\n    if (index < features.length-1) {\n      mq += ' and '\n    }\n  });\n  return mq;\n};\n\nvar json2mq = function (query) {\n  var mq = '';\n  if (typeof query === 'string') {\n    return query;\n  }\n  // Handling array of media queries\n  if (query instanceof Array) {\n    query.forEach(function (q, index) {\n      mq += obj2mq(q);\n      if (index < query.length-1) {\n        mq += ', '\n      }\n    });\n    return mq;\n  }\n  // Handling single media query\n  return obj2mq(query);\n};\n\nmodule.exports = json2mq;","<template>\r\n  <template v-if=\"type === SlideNavigation.previous\">\r\n    <slot name=\"prevArrow\" v-bind=\"arrowSlotProps\">\r\n      <button\r\n        type=\"button\"\r\n        data-role=\"none\"\r\n        class=\"v-slick-arrow prev\"\r\n        :class=\"{ disabled }\"\r\n        @click=\"clickHandler\"\r\n      >\r\n        {{ prevArrowLabel }}\r\n      </button>\r\n    </slot>\r\n  </template>\r\n  <template v-else>\r\n    <slot name=\"nextArrow\" v-bind=\"arrowSlotProps\">\r\n      <button\r\n        type=\"button\"\r\n        data-role=\"none\"\r\n        class=\"v-slick-arrow next\"\r\n        :class=\"{ disabled }\"\r\n        @click=\"clickHandler\"\r\n      >\r\n        {{ nextArrowLabel }}\r\n      </button>\r\n    </slot>\r\n  </template>\r\n</template>\r\n<script setup lang=\"ts\">\r\nimport { ArrowSlotProps, SlideNavigation } from '@lib/types'\r\nimport { computed } from 'vue'\r\nimport { defaultArrowProps } from './props'\r\n\r\nconst props = defineProps(defaultArrowProps)\r\nconst emit = defineEmits([SlideNavigation.previous, SlideNavigation.next])\r\nconst clickHandler = computed(() => () => {\r\n  if (props.disabled) return\r\n  emit(props.type)\r\n})\r\nconst arrowSlotProps = computed<ArrowSlotProps>(() => ({\r\n  currentSlideGroupIndex: props.currentSlideGroupIndex,\r\n  slideGroupCount: props.slideGroupCount,\r\n  onClick: clickHandler.value,\r\n  disabled: !props.disabled\r\n}))\r\n</script>\r\n<style scoped>\r\n.v-slick-arrow {\r\n  display: block;\r\n}\r\n</style>\r\n","<template>\r\n  <div\r\n    class=\"v-slick-track\"\r\n    :class=\"{ center: centerMode, vertical: vertical }\"\r\n    :style=\"[trackStyle, detectingWidth ? { width: '0 !important' } : {}]\"\r\n  >\r\n    <div\r\n      v-for=\"(slideGroup, i) in preCloneSlideGroups\"\r\n      :key=\"slideGroup.key\"\r\n      tabindex=\"-1\"\r\n      :class=\"slideGroup.class\"\r\n      :style=\"slideGroup.style\"\r\n      class=\"v-slick-slide-group clone\"\r\n      v-bind=\"slideGroup.attrs\"\r\n      @click=\"slideGroup.onClick\"\r\n    >\r\n      <component\r\n        :is=\"slide\"\r\n        v-for=\"(slide, j) of slideGroup.slides\"\r\n        :key=\"`slide-${i}-${j}` + (slide.key ? `-${String(slide.key)}` : '')\"\r\n      />\r\n    </div>\r\n    <div\r\n      v-for=\"(slideGroup, i) in originalSlideGroups\"\r\n      :key=\"slideGroup.key\"\r\n      tabindex=\"-1\"\r\n      class=\"v-slick-slide-group\"\r\n      :class=\"slideGroup.class\"\r\n      :style=\"slideGroup.style\"\r\n      v-bind=\"slideGroup.attrs\"\r\n      @click=\"slideGroup.onClick\"\r\n    >\r\n      <component\r\n        :is=\"slide\"\r\n        v-for=\"(slide, j) of slideGroup.slides\"\r\n        :key=\"`slide-${i}-${j}` + (slide.key ? `-${String(slide.key)}` : '')\"\r\n      />\r\n    </div>\r\n    <div\r\n      v-for=\"(slideGroup, i) in postCloneSlideGroups\"\r\n      :key=\"slideGroup.key\"\r\n      tabindex=\"-1\"\r\n      :class=\"slideGroup.class\"\r\n      :style=\"slideGroup.style\"\r\n      class=\"v-slick-slide-group clone\"\r\n      v-bind=\"slideGroup.attrs\"\r\n      @click=\"slideGroup.onClick\"\r\n    >\r\n      <component\r\n        :is=\"slide\"\r\n        v-for=\"(slide, j) of slideGroup.slides\"\r\n        :key=\"`slide-${i}-${j}` + (slide.key ? `-${String(slide.key)}` : '')\"\r\n      />\r\n    </div>\r\n  </div>\r\n</template>\r\n\r\n<script setup lang=\"ts\">\r\nimport { computed } from 'vue'\r\nimport { defaultTrackProps } from './props'\r\nimport {\r\n  ChildClickPayload,\r\n  CloneInfoSpec,\r\n  LazyInfoSpec,\r\n  SlideGroup,\r\n  TrackProps\r\n} from '@lib/types'\r\nimport {\r\n  getLazyEndIndex,\r\n  getLazyStartIndex,\r\n  getTotalPreClones\r\n} from '@lib/utils'\r\n\r\nconst props = defineProps(defaultTrackProps) as TrackProps\r\nconst emit = defineEmits<{\r\n  childClick: [payload: ChildClickPayload]\r\n}>()\r\n\r\nconst getSlideGroupClasses = (index: number) => {\r\n  let isActive = false,\r\n    isCenter = false,\r\n    isCurrent = false,\r\n    centerOffset: number\r\n  if (props.centerMode) {\r\n    centerOffset = Math.floor(props.groupsToShow / 2)\r\n    isCenter =\r\n      (index - props.currentSlideGroupIndex) % props.slideGroupCount === 0\r\n    if (\r\n      index > props.currentSlideGroupIndex - centerOffset - 1 &&\r\n      index <= props.currentSlideGroupIndex + centerOffset\r\n    ) {\r\n      isActive = true\r\n    }\r\n  } else {\r\n    isActive =\r\n      props.currentSlideGroupIndex <= index &&\r\n      index < props.currentSlideGroupIndex + props.groupsToShow\r\n  }\r\n  isCurrent = index === props.currentSlideGroupIndex\r\n  return Object.entries({\r\n    active: isActive,\r\n    center: isCenter,\r\n    current: isCurrent\r\n  })\r\n    .filter(([, value]) => value)\r\n    .map(([key]) => key)\r\n}\r\n\r\nconst getSlideGroupStyle = (index: number) => {\r\n  let style: {\r\n    width?: string\r\n    position?: string\r\n    top?: string\r\n    left?: string\r\n    opacity?: number\r\n    transition?: string\r\n  } = {}\r\n\r\n  if (props.variableWidth === undefined || props.variableWidth === false) {\r\n    style.width =\r\n      typeof props.slideGroupWidth === 'number'\r\n        ? `${props.slideGroupWidth}px`\r\n        : props.slideGroupWidth\r\n  }\r\n\r\n  if (props.fade) {\r\n    style.position = 'relative'\r\n    if (props.vertical) {\r\n      const slideGroupHeight = !props.slideGroupHeight\r\n        ? 0\r\n        : typeof props.slideGroupHeight === 'string'\r\n          ? parseFloat(props.slideGroupHeight)\r\n          : props.slideGroupHeight\r\n      style.top = `${-index * slideGroupHeight}px`\r\n    } else {\r\n      const slideGroupWidth = !props.slideGroupWidth\r\n        ? 0\r\n        : typeof props.slideGroupWidth === 'string'\r\n          ? parseFloat(props.slideGroupWidth)\r\n          : props.slideGroupWidth\r\n\r\n      const left = props.rtl\r\n        ? index * slideGroupWidth\r\n        : -index * slideGroupWidth\r\n      style.left = `${left}px`\r\n    }\r\n    style.opacity = props.currentSlideGroupIndex === index ? 1 : 0\r\n    style.transition =\r\n      'opacity ' +\r\n      props.speed +\r\n      'ms ' +\r\n      props.cssEase +\r\n      ', ' +\r\n      'visibility ' +\r\n      props.speed +\r\n      'ms ' +\r\n      props.cssEase\r\n    if (props.ignorePrefersReducedMotion) {\r\n      style.transition += ' !important'\r\n    }\r\n  }\r\n\r\n  return style\r\n}\r\n\r\nconst originalSlideGroups = computed<SlideGroup[]>(() => {\r\n  const slideGroups = props.rawSlideGroups.map((rawSlideGroup, index) => {\r\n    const style = getSlideGroupStyle(index)\r\n    const classes = getSlideGroupClasses(index)\r\n    if (props.fade && classes.includes('active')) {\r\n      Object.assign(style, { zIndex: 1 })\r\n    }\r\n    const slideGroup: SlideGroup = {\r\n      slides: [],\r\n      key: `original-${index}`,\r\n      class: classes,\r\n      style,\r\n      attrs: {\r\n        'data-index': index,\r\n        'aria-hidden': `${!classes.includes('active')}`\r\n      },\r\n      onClick: () => {\r\n        emit('childClick', {\r\n          index:\r\n            props.rtl && props.infinite ? props.slideGroupCount + index : index\r\n        })\r\n      }\r\n    }\r\n    if (\r\n      !props.lazyLoad ||\r\n      (props.lazyLoad && props.lazyLoadedList.indexOf(index) >= 0)\r\n    ) {\r\n      slideGroup.slides = rawSlideGroup\r\n    }\r\n    return slideGroup\r\n  })\r\n  // return props.rtl ? slideGroups.reverse() : slideGroups\r\n  return slideGroups\r\n})\r\n\r\nconst preCloneSlideGroups = computed<SlideGroup[]>(() => {\r\n  if (\r\n    !props.infinite ||\r\n    props.fade ||\r\n    props.slideGroupCount <= props.groupsToShow\r\n  ) {\r\n    return []\r\n  }\r\n  const slideGroups = props.rawSlideGroups\r\n    .map((rawSlideGroup, index) => {\r\n      const preCloneNo = props.slideGroupCount - index\r\n      if (preCloneNo > getTotalPreClones(props as CloneInfoSpec)) return\r\n      const key = -preCloneNo\r\n      const slideGroup: SlideGroup = {\r\n        slides: [],\r\n        key: `preclone-${key}`,\r\n        class: getSlideGroupClasses(key),\r\n        style: getSlideGroupStyle(index),\r\n        attrs: {\r\n          'data-index': key,\r\n          'aria-hidden': 'true'\r\n        },\r\n        onClick: () => {\r\n          emit('childClick', {\r\n            index: key\r\n          })\r\n        }\r\n      }\r\n      if (\r\n        key >= getLazyStartIndex(props as LazyInfoSpec) ||\r\n        !props.lazyLoad ||\r\n        (props.lazyLoad && props.lazyLoadedList.indexOf(index) >= 0)\r\n      ) {\r\n        slideGroup.slides = rawSlideGroup\r\n      }\r\n      return slideGroup\r\n    })\r\n    .filter((slideGroup) => slideGroup) as SlideGroup[]\r\n  // return props.rtl ? slideGroups.reverse() : slideGroups\r\n  return slideGroups\r\n})\r\n\r\nconst postCloneSlideGroups = computed<SlideGroup[]>(() => {\r\n  if (\r\n    !props.infinite ||\r\n    props.fade ||\r\n    props.slideGroupCount <= props.groupsToShow\r\n  ) {\r\n    return []\r\n  }\r\n  const slideGroups = props.rawSlideGroups.map((rawSlideGroup, index) => {\r\n    const key = props.slideGroupCount + index\r\n    const slideGroup: SlideGroup = {\r\n      slides: [],\r\n      key: `postclone-${key}`,\r\n      class: getSlideGroupClasses(key),\r\n      style: getSlideGroupStyle(index),\r\n      attrs: {\r\n        'data-index': key,\r\n        'aria-hidden':\r\n          props.infinite &&\r\n          props.slideGroupCount - props.currentSlideGroupIndex <\r\n            props.groupsToShow &&\r\n          index <\r\n            props.groupsToShow -\r\n              (props.slideGroupCount - props.currentSlideGroupIndex)\r\n            ? 'false'\r\n            : 'true'\r\n      },\r\n      onClick: () => {\r\n        emit('childClick', {\r\n          index: props.rtl ? props.slideGroupCount + key : key\r\n        })\r\n      }\r\n    }\r\n    if (\r\n      key < getLazyEndIndex(props as LazyInfoSpec) ||\r\n      !props.lazyLoad ||\r\n      (props.lazyLoad && props.lazyLoadedList.indexOf(index) >= 0)\r\n    ) {\r\n      slideGroup.slides = rawSlideGroup\r\n    }\r\n    return slideGroup\r\n  })\r\n  // return props.rtl ? slideGroups.reverse() : slideGroups\r\n  return slideGroups\r\n})\r\n</script>\r\n\r\n<style scoped lang=\"scss\">\r\n.v-slick-track {\r\n  position: relative;\r\n  top: 0;\r\n  left: 0;\r\n  display: flex;\r\n  transform: translate3d(0, 0, 0);\r\n  &.center {\r\n    margin-left: auto;\r\n    margin-right: auto;\r\n  }\r\n  &.vertical {\r\n    flex-direction: column;\r\n    .v-slick-slide-group {\r\n      flex-direction: row;\r\n      height: auto;\r\n      & > * {\r\n        flex-grow: 1;\r\n      }\r\n    }\r\n  }\r\n  &.dragging img {\r\n    pointer-events: none;\r\n  }\r\n}\r\n.v-slick-slide-group {\r\n  display: flex;\r\n  flex-direction: column;\r\n  height: 100%;\r\n  min-height: 1px;\r\n  flex-shrink: 0;\r\n  outline: none;\r\n}\r\n</style>\r\n","<template>\r\n  <ul\r\n    :class=\"dotsClass\"\r\n    style=\"display: block\"\r\n    @mouseenter=\"$emit('dotsLeave')\"\r\n    @mouseleave=\"$emit('dotsLeave')\"\r\n    @mouseover=\"$emit('dotsOver')\"\r\n  >\r\n    <li\r\n      v-for=\"i in pageCount\"\r\n      :key=\"i\"\r\n      :class=\"{ active: isActive(i - 1) }\"\r\n      @click=\"\r\n        $emit('dotClick', {\r\n          index: i - 1,\r\n          groupsToScroll\r\n        })\r\n      \"\r\n    >\r\n      <slot name=\"customPaging\" :page=\"i - 1\">\r\n        <button>{{ i }}</button>\r\n      </slot>\r\n    </li>\r\n  </ul>\r\n</template>\r\n<script setup lang=\"ts\">\r\nimport { DotClickPayload } from '@lib/types'\r\nimport { defaultDotsProps } from './props'\r\ndefineEmits<{\r\n  dotClick: [payload: DotClickPayload]\r\n  dotsOver: []\r\n  dotsLeave: []\r\n}>()\r\nconst props = defineProps(defaultDotsProps)\r\nconst isActive = (i: number) => {\r\n  const leftBound = i * props.groupsToScroll\r\n  const rightBound = leftBound + props.groupsToScroll - 1\r\n  return (\r\n    props.currentSlideGroupIndex >= leftBound &&\r\n    props.currentSlideGroupIndex <= rightBound\r\n  )\r\n}\r\n</script>\r\n","/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        result = wait - timeSinceLastCall;\n\n    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = debounce;\n","<template>\r\n  <div\r\n    ref=\"vSlickCarouselRef\"\r\n    class=\"v-slick-carousel\"\r\n    :style=\"\r\n      widthDetection === WidthDetection.manual\r\n        ? state.detectingWidth\r\n          ? { width: '100%' }\r\n          : vSlickCarouselStyle\r\n        : {}\r\n    \"\r\n  >\r\n    <div class=\"v-slick-slider\" :dir=\"settings.rtl ? 'rtl' : 'ltr'\">\r\n      <VSlickArrow\r\n        v-if=\"settings.arrows\"\r\n        :type=\"SlideNavigation.previous\"\r\n        :center-mode=\"settings.centerMode\"\r\n        :infinite=\"settings.infinite\"\r\n        :groups-to-show=\"settings.groupsToShow\"\r\n        :slide-group-count=\"slideGroupCount\"\r\n        :current-slide-group-index=\"state.currentSlideGroupIndex\"\r\n        :disabled=\"!canGoPrev\"\r\n        @previous=\"handlePrevVSlickArrow\"\r\n      >\r\n        <template #prevArrow=\"arrowSlotProps\">\r\n          <slot name=\"prevArrow\" v-bind=\"arrowSlotProps\" />\r\n        </template>\r\n      </VSlickArrow>\r\n      <div\r\n        ref=\"vSlickListRef\"\r\n        class=\"v-slick-list\"\r\n        :class=\"{ dragging: state.dragging }\"\r\n        :style=\"vSlickListStyle\"\r\n        @click=\"handleClickVSlickList\"\r\n        @mousedown=\"handleMouseDownOrTouchStartVSlickList\"\r\n        @touchstart.passive=\"handleMouseDownOrTouchStartVSlickList\"\r\n        @keydown=\"handleKeyDownVSlickList\"\r\n      >\r\n        <VSlickTrack\r\n          ref=\"vSlickTrackRef\"\r\n          :center-mode=\"settings.centerMode\"\r\n          :center-padding=\"settings.centerPadding\"\r\n          :raw-slide-groups=\"rawSlideGroups\"\r\n          :css-ease=\"cssEase\"\r\n          :current-slide-group-index=\"state.currentSlideGroupIndex\"\r\n          :detecting-width=\"state.detectingWidth\"\r\n          :fade=\"settings.fade\"\r\n          :ignore-prefers-reduced-motion=\"settings.ignorePrefersReducedMotion\"\r\n          :infinite=\"settings.infinite\"\r\n          :lazy-load=\"settings.lazyLoad\"\r\n          :lazy-loaded-list=\"state.lazyLoadedList\"\r\n          :list-height=\"state.listHeight\"\r\n          :rtl=\"settings.rtl\"\r\n          :slide-group-count=\"slideGroupCount\"\r\n          :slide-group-height=\"state.slideGroupHeight\"\r\n          :slide-group-width=\"state.slideGroupWidth\"\r\n          :groups-to-scroll=\"settings.groupsToScroll\"\r\n          :groups-to-show=\"settings.groupsToShow\"\r\n          :speed=\"settings.speed\"\r\n          :track-style=\"state.trackStyle\"\r\n          :variable-width=\"settings.variableWidth\"\r\n          :vertical=\"settings.vertical\"\r\n          @mouseenter=\"handleMouseEnterOrOverVSlickTrack\"\r\n          @mouseleave=\"handleMouseLeaveVSlickTrack\"\r\n          @mouseover=\"handleMouseEnterOrOverVSlickTrack\"\r\n          @child-click=\"handleChildClickVSlickTrack\"\r\n        />\r\n      </div>\r\n      <VSlickArrow\r\n        v-if=\"settings.arrows\"\r\n        :type=\"SlideNavigation.next\"\r\n        :center-mode=\"settings.centerMode\"\r\n        :infinite=\"settings.infinite\"\r\n        :groups-to-show=\"settings.groupsToShow\"\r\n        :slide-group-count=\"slideGroupCount\"\r\n        :current-slide-group-index=\"state.currentSlideGroupIndex\"\r\n        :disabled=\"!canGoNext\"\r\n        @next=\"handleNextVSlickArrow\"\r\n      >\r\n        <template #nextArrow=\"arrowSlotProps\">\r\n          <slot name=\"nextArrow\" v-bind=\"arrowSlotProps\" />\r\n        </template>\r\n      </VSlickArrow>\r\n    </div>\r\n    <VSlickDots\r\n      v-if=\"settings.dots\"\r\n      :current-slide-group-index=\"state.currentSlideGroupIndex\"\r\n      :infinite=\"settings.infinite\"\r\n      :slide-group-count=\"slideGroupCount\"\r\n      :groups-to-scroll=\"settings.groupsToScroll\"\r\n      :groups-to-show=\"settings.groupsToShow\"\r\n      :dots-class=\"settings.dotsClass\"\r\n      :page-count=\"pageCount\"\r\n      @dot-click=\"handleClickDot\"\r\n      @dots-over=\"handleOverDots\"\r\n      @dots-leave=\"handleLeaveDots\"\r\n    >\r\n      <template #customPaging=\"paging\">\r\n        <slot name=\"customPaging\" v-bind=\"paging\" />\r\n      </template>\r\n    </VSlickDots>\r\n  </div>\r\n</template>\r\n\r\n<script setup lang=\"ts\">\r\nimport {\r\n  ref,\r\n  computed,\r\n  watch,\r\n  VNode,\r\n  useSlots,\r\n  getCurrentInstance,\r\n  onMounted,\r\n  onBeforeUnmount,\r\n  onUpdated\r\n} from 'vue'\r\nimport {\r\n  ChildClickPayload,\r\n  DotClickPayload,\r\n  LazyLoadType,\r\n  PlayingType,\r\n  Props,\r\n  SwipeDirection,\r\n  SwipeEndSpec,\r\n  SwipeMoveSpec,\r\n  TrackInfoSpec,\r\n  VSlickCarouselInstance,\r\n  SwipeEvent,\r\n  SlideNavigation,\r\n  SlideGroupChangeOptions,\r\n  SlideGroupChangeSpec,\r\n  OnSlideSpec,\r\n  WidthDetection\r\n} from '@lib/types'\r\nimport {\r\n  canUseDOM,\r\n  clearSelection,\r\n  filterUndefined,\r\n  getChangedSlideGroupIndex\r\n} from '@lib/utils'\r\nimport {\r\n  defaultPropValues,\r\n  defaultProps,\r\n  makeDefaultSliderState\r\n} from './props'\r\nimport enquireJs from '@dcufo/enquire.js'\r\nimport json2mq from 'json2mq'\r\nimport VSlickArrow from './VSlickArrow.vue'\r\nimport VSlickTrack from './VSlickTrack.vue'\r\nimport VSlickDots from './VSlickDots.vue'\r\nimport debounce from 'lodash.debounce'\r\nimport {\r\n  canGoNext as checkCanGoNext,\r\n  canGoPrev as checkCanGoPrev,\r\n  extractSlides,\r\n  getNavigationOnKeyType,\r\n  getOnDemandLazySlideGroups,\r\n  getSlideGroupCount,\r\n  getSliderState,\r\n  getStatesOnSlide,\r\n  getSwipeEndState,\r\n  getSwipeMoveState,\r\n  getSwipeStartState,\r\n  getTotalPostClones,\r\n  getTotalPreClones,\r\n  getTrackCSS,\r\n  getTrackLeft\r\n} from '@lib/utils/carousel-utils'\r\n\r\nconst props = defineProps(defaultProps) as Props\r\ndefineOptions({ inheritAttrs: false })\r\n\r\nconst emit = defineEmits([\r\n  'init',\r\n  'beforeChange',\r\n  'afterChange',\r\n  'lazyLoad',\r\n  'lazyLoadError',\r\n  'reInit',\r\n  'edge',\r\n  'swipe'\r\n])\r\n\r\nconst slots = useSlots()\r\nconst enquire = canUseDOM() ? enquireJs : undefined\r\n\r\nconst DEBOUNCE_RESIZE_DURATION = 50\r\n\r\nlet triggerSlideGroupHandler: number | undefined\r\nlet animationEndCallback: NodeJS.Timeout | null = null\r\nlet lazyLoadTimer: NodeJS.Timeout | null = null\r\nlet callbackTimers: NodeJS.Timeout[] = []\r\n\r\nconst vSlickListStyle = ref({\r\n  ...(getCurrentInstance()?.vnode?.props?.style || {})\r\n})\r\n\r\nlet isVSlickListClickable = true\r\nlet debouncedResize: ReturnType<typeof debounce> | null = null\r\nlet ro: ResizeObserver | null = null\r\n\r\nlet responsiveMediaHandlers: {\r\n  query: string\r\n  handler: () => void\r\n}[] = []\r\n\r\nconst media = (query: string, handler: () => void) => {\r\n  if (!enquire) return\r\n\r\n  enquire.register(query, handler)\r\n  responsiveMediaHandlers.push({ query, handler })\r\n}\r\n\r\nconst clearBreakpoints = () => {\r\n  responsiveMediaHandlers.forEach(({ query, handler }) =>\r\n    enquire?.unregister(query, handler)\r\n  )\r\n  responsiveMediaHandlers = []\r\n}\r\n\r\nconst makeBreakpoints = () => {\r\n  if (!props.responsive.length) return\r\n  const breakpoints = props.responsive.map((item) => item.breakpoint)\r\n  breakpoints.sort((a, b) => a - b)\r\n  breakpoints.forEach((_breakpoint, index) => {\r\n    const mediaQuery = json2mq({\r\n      minWidth: index === 0 ? 0 : breakpoints[index - 1] + 1,\r\n      maxWidth: _breakpoint\r\n    })\r\n    media(mediaQuery, () => {\r\n      breakpoint.value = _breakpoint\r\n    })\r\n  })\r\n  const query = json2mq({\r\n    minWidth: breakpoints.slice(-1)[0]\r\n  })\r\n  media(query, () => {\r\n    breakpoint.value = undefined\r\n  })\r\n}\r\n\r\nconst swipeStart = (e: SwipeEvent) => {\r\n  const swipeStartState = getSwipeStartState(\r\n    e,\r\n    settings.value.swipe,\r\n    settings.value.draggable\r\n  )\r\n  Object.assign(state.value, swipeStartState)\r\n}\r\n\r\nconst swipeEnd = (e: SwipeEvent) => {\r\n  const swipeEndState = getSwipeEndState(e, {\r\n    ...settings.value,\r\n    ...state.value,\r\n    trackEl: vSlickTrackRef.value?.$el,\r\n    listEl: vSlickListRef.value,\r\n    slideGroupIndex: state.value.currentSlideGroupIndex,\r\n    slideGroupCount: slideGroupCount.value\r\n  } as SwipeEndSpec)\r\n  if (!swipeEndState) return\r\n  const { triggerSlideGroupHandler: newTriggerSlideGroupHandler, ...rest } =\r\n    swipeEndState\r\n  triggerSlideGroupHandler = newTriggerSlideGroupHandler\r\n  Object.assign(state.value, rest)\r\n  if (triggerSlideGroupHandler !== undefined) {\r\n    slideGroupHandler(triggerSlideGroupHandler)\r\n  }\r\n}\r\n\r\nconst swipeMove = (e: SwipeEvent) => {\r\n  clearSelection()\r\n  const swipeMoveState = getSwipeMoveState(e, {\r\n    ...props,\r\n    ...state.value,\r\n    trackEl: vSlickTrackRef.value?.$el,\r\n    listEl: vSlickListRef.value,\r\n    slideGroupIndex: state.value.currentSlideGroupIndex,\r\n    slideGroupCount: slideGroupCount.value,\r\n    onEdge: (e: SwipeDirection | keyof typeof SwipeDirection) =>\r\n      emit('edge', e),\r\n    swipeEvent: (e: SwipeDirection | keyof typeof SwipeDirection) =>\r\n      emit('swipe', e)\r\n  } as SwipeMoveSpec)\r\n  if (!swipeMoveState) return\r\n  if (swipeMoveState.swiping) {\r\n    isVSlickListClickable = false\r\n  }\r\n  Object.assign(state.value, swipeMoveState)\r\n}\r\n\r\nconst play = () => {\r\n  let nextIndex\r\n  if (settings.value.rtl) {\r\n    nextIndex =\r\n      state.value.currentSlideGroupIndex - settings.value.groupsToScroll\r\n  } else {\r\n    if (canGoNext.value) {\r\n      nextIndex =\r\n        state.value.currentSlideGroupIndex + settings.value.groupsToScroll\r\n    } else {\r\n      return false\r\n    }\r\n  }\r\n\r\n  slideGroupHandler(nextIndex)\r\n}\r\n\r\nconst pause = (\r\n  pauseType: null | PlayingType | keyof typeof PlayingType = null\r\n) => {\r\n  if (state.value.autoplayTimer) {\r\n    clearInterval(state.value.autoplayTimer)\r\n    state.value.autoplayTimer = null\r\n  }\r\n  const autoplaying = state.value.autoplaying\r\n  if (pauseType === PlayingType.paused) {\r\n    state.value.autoplaying = PlayingType.paused\r\n  } else if (\r\n    pauseType === PlayingType.focused &&\r\n    (autoplaying === PlayingType.hovered || autoplaying === PlayingType.playing)\r\n  ) {\r\n    state.value.autoplaying = PlayingType.focused\r\n  } else if (autoplaying === PlayingType.playing) {\r\n    state.value.autoplaying = PlayingType.hovered\r\n  } else if (autoplaying === null) {\r\n    state.value.autoplaying = null\r\n  }\r\n}\r\n\r\nconst autoPlay = (playType: PlayingType | keyof typeof PlayingType) => {\r\n  if (state.value.autoplayTimer) {\r\n    clearInterval(state.value.autoplayTimer)\r\n  }\r\n  const autoplaying = state.value.autoplaying\r\n  if (playType === PlayingType.update) {\r\n    if (\r\n      autoplaying === PlayingType.hovered ||\r\n      autoplaying === PlayingType.focused ||\r\n      autoplaying === PlayingType.paused\r\n    ) {\r\n      return\r\n    }\r\n  } else if (playType === PlayingType.leave) {\r\n    if (\r\n      autoplaying === PlayingType.paused ||\r\n      autoplaying === PlayingType.focused\r\n    ) {\r\n      return\r\n    }\r\n  } else if (playType === PlayingType.blur) {\r\n    if (\r\n      autoplaying === PlayingType.paused ||\r\n      autoplaying === PlayingType.hovered\r\n    ) {\r\n      return\r\n    }\r\n  }\r\n  state.value.autoplayTimer = setInterval(\r\n    play,\r\n    settings.value.autoplaySpeed + 50\r\n  )\r\n  state.value.autoplaying = PlayingType.playing\r\n}\r\n\r\nconst adaptHeight = () => {\r\n  if (settings.value.adaptiveHeight && vSlickListRef.value) {\r\n    const activeSlideGroups = vSlickListRef.value.querySelectorAll<HTMLElement>(\r\n      '.v-slick-slide-group.active'\r\n    )\r\n    let maxHeight = 0\r\n    activeSlideGroups.forEach((slideGroup) => {\r\n      maxHeight = Math.max(maxHeight, slideGroup.offsetHeight)\r\n    })\r\n    vSlickListRef.value.style.height = maxHeight + 'px'\r\n  }\r\n}\r\n\r\nconst onTrackOver = () => {\r\n  if (settings.value.autoplay) pause(PlayingType.hovered)\r\n}\r\n\r\nconst onTrackLeave = () => {\r\n  if (\r\n    settings.value.autoplay &&\r\n    state.value.autoplaying === PlayingType.hovered\r\n  )\r\n    autoPlay(PlayingType.leave)\r\n}\r\n\r\nconst handleClickVSlickList = (e: Event) => {\r\n  if (isVSlickListClickable === false) {\r\n    e.stopPropagation()\r\n    e.preventDefault()\r\n  }\r\n  isVSlickListClickable = true\r\n}\r\n\r\nconst handleChildClickVSlickTrack = ({ index }: ChildClickPayload) => {\r\n  if (!settings.value.focusOnSelect) return\r\n  changeSlideGroup({\r\n    message: 'children',\r\n    index\r\n  })\r\n}\r\n\r\nconst handleKeyDownVSlickList = (e: KeyboardEvent) => {\r\n  if (!settings.value.accessibility) return\r\n  const navigation = getNavigationOnKeyType(\r\n    e,\r\n    settings.value.accessibility,\r\n    settings.value.rtl\r\n  )\r\n  if (!navigation) return\r\n  changeSlideGroup({ message: navigation as SlideNavigation })\r\n}\r\n\r\nconst handleMouseDownOrTouchStartVSlickList = (e: SwipeEvent) => {\r\n  if (!settings.value.touchMove) return\r\n  const target = e.target as HTMLElement | null\r\n  if (target?.classList.contains('no-swipe')) return\r\n  swipeStart(e)\r\n}\r\n\r\nconst handleMouseMoveOrTouchMoveVSlickList = (e: SwipeEvent) => {\r\n  if (!state.value.dragging || !settings.value.touchMove) return\r\n  const target = e.target as HTMLElement | null\r\n  if (target?.classList.contains('no-swipe')) return\r\n  swipeMove(e)\r\n}\r\n\r\nconst handleMouseUpOrTouchEndVSlickList = (e: SwipeEvent) => {\r\n  if (!settings.value.touchMove) return\r\n  swipeEnd(e)\r\n}\r\n\r\nconst handleMouseLeaveOrTouchCancelVSlickList = (e: SwipeEvent) => {\r\n  if (!state.value.dragging || !settings.value.touchMove) return\r\n  swipeEnd(e)\r\n}\r\n\r\nconst handleMouseEnterOrOverVSlickTrack = () => {\r\n  if (!settings.value.pauseOnHover) return\r\n  onTrackOver()\r\n}\r\n\r\nconst handleMouseLeaveVSlickTrack = () => {\r\n  if (!settings.value.pauseOnHover) return\r\n  onTrackLeave()\r\n}\r\n\r\nconst handleOverDots = () => {\r\n  if (settings.value.pauseOnDotsHover && settings.value.autoplay)\r\n    pause(PlayingType.hovered)\r\n}\r\nconst handleLeaveDots = () => {\r\n  if (\r\n    settings.value.pauseOnDotsHover &&\r\n    settings.value.autoplay &&\r\n    state.value.autoplaying === PlayingType.hovered\r\n  )\r\n    autoPlay(PlayingType.leave)\r\n}\r\n\r\nconst handleClickDot = ({ index }: DotClickPayload) => {\r\n  changeSlideGroup({\r\n    message: 'dots',\r\n    index\r\n  })\r\n}\r\n\r\nconst handleNextVSlickArrow = () => {\r\n  changeSlideGroup({\r\n    message: SlideNavigation.next\r\n  })\r\n}\r\n\r\nconst handlePrevVSlickArrow = () => {\r\n  changeSlideGroup({\r\n    message: SlideNavigation.previous\r\n  })\r\n}\r\n\r\nconst changeSlideGroup = (\r\n  options: SlideGroupChangeOptions,\r\n  dontAnimate = false\r\n) => {\r\n  const spec = {\r\n    ...settings.value,\r\n    ...state.value,\r\n    slideGroupCount: slideGroupCount.value\r\n  }\r\n  const targetSlideGroupIndex = getChangedSlideGroupIndex(\r\n    spec as SlideGroupChangeSpec,\r\n    options\r\n  )\r\n  if (targetSlideGroupIndex === undefined || targetSlideGroupIndex === null)\r\n    return\r\n  slideGroupHandler(\r\n    targetSlideGroupIndex,\r\n    dontAnimate === true ? true : undefined\r\n  )\r\n}\r\n\r\nconst slideGroupHandler = async (index: number, dontAnimate = false) => {\r\n  const { asNavFor, speed } = settings.value\r\n  const currentSlideGroupIndex = state.value.currentSlideGroupIndex\r\n  const states = getStatesOnSlide({\r\n    index,\r\n    ...settings.value,\r\n    ...state.value,\r\n    slideGroupCount: slideGroupCount.value,\r\n    trackEl: vSlickTrackRef.value?.$el,\r\n    useCSSTransitions: settings.value.useCSSTransitions && !dontAnimate\r\n  } as OnSlideSpec)\r\n  if (!states) return\r\n  const { slidingState, afterSlidingState } = states\r\n  emit(\r\n    'beforeChange',\r\n    currentSlideGroupIndex,\r\n    slidingState.currentSlideGroupIndex\r\n  )\r\n  const slidesToLoad =\r\n    slidingState.lazyLoadedList?.filter(\r\n      (value: number) => state.value.lazyLoadedList.indexOf(value) < 0\r\n    ) || []\r\n  if (slidesToLoad.length) {\r\n    emit('lazyLoad', slidesToLoad)\r\n  }\r\n  Object.assign(state.value, slidingState)\r\n  if (asNavFor) {\r\n    ;(asNavFor as VSlickCarouselInstance).goTo(index)\r\n  }\r\n  if (!afterSlidingState) return\r\n  await new Promise<void>((resolve) => {\r\n    animationEndCallback = setTimeout(() => {\r\n      const { animating, ...firstBatch } = afterSlidingState!\r\n      if (\r\n        settings.value.waitForAnimate ||\r\n        state.value.currentSlideGroupIndex ===\r\n          slidingState.currentSlideGroupIndex\r\n      ) {\r\n        Object.assign(state.value, firstBatch)\r\n      }\r\n      callbackTimers.push(\r\n        setTimeout(() => {\r\n          state.value.animating = animating || false\r\n        })\r\n      )\r\n      emit('afterChange', slidingState.currentSlideGroupIndex)\r\n      animationEndCallback = null\r\n      resolve()\r\n    }, speed)\r\n  })\r\n}\r\n\r\nconst updateState = (shouldSetTrackStyle?: boolean) => {\r\n  const updatedState = getSliderState({\r\n    ...settings.value,\r\n    ...state.value,\r\n    listEl: vSlickListRef.value,\r\n    trackEl: vSlickTrackRef.value?.$el,\r\n    slides: slides.value\r\n  })\r\n  const spec: TrackInfoSpec = {\r\n    ...props,\r\n    ...state,\r\n    ...updatedState,\r\n    trackEl: vSlickTrackRef.value?.$el,\r\n    slideGroupCount: slideGroupCount.value\r\n  }\r\n  const targetLeft = getTrackLeft(spec as TrackInfoSpec)\r\n  const trackStyle = getTrackCSS(spec as TrackInfoSpec, targetLeft)\r\n  if (shouldSetTrackStyle || slideGroupCount.value !== spec.slideGroupCount) {\r\n    updatedState.trackStyle = trackStyle\r\n  }\r\n  Object.assign(state.value, updatedState)\r\n}\r\n\r\nconst resize = async (\r\n  options: { shouldSetTrackStyle?: boolean; isWindowResize?: boolean } = {\r\n    shouldSetTrackStyle: true\r\n  }\r\n) => {\r\n  if (!vSlickTrackRef.value || !vSlickTrackRef.value.$el) {\r\n    return\r\n  }\r\n  if (\r\n    settings.value.widthDetection === WidthDetection.manual &&\r\n    options.isWindowResize\r\n  ) {\r\n    await detectWidth()\r\n  }\r\n  updateState(\r\n    options.shouldSetTrackStyle ||\r\n      (settings.value.widthDetection === WidthDetection.manual &&\r\n        options.isWindowResize)\r\n  )\r\n  if (props.autoplay) {\r\n    autoPlay(PlayingType.update)\r\n  } else {\r\n    pause()\r\n  }\r\n}\r\n\r\nconst onResize = (options?: {\r\n  shouldSetTrackStyle?: boolean\r\n  isWindowResize?: boolean\r\n}) => {\r\n  debouncedResize?.cancel()\r\n  debouncedResize = debounce(() => resize(options), DEBOUNCE_RESIZE_DURATION)\r\n  debouncedResize()\r\n}\r\n\r\nconst onResizeEventListener = () =>\r\n  onResize({\r\n    isWindowResize: true\r\n  })\r\n\r\nconst onSlideGroupFocus = () => {\r\n  if (settings.value.autoplay) pause(PlayingType.focused)\r\n}\r\nconst onSlideGroupBlur = () => {\r\n  if (\r\n    settings.value.autoplay &&\r\n    state.value.autoplaying === PlayingType.focused\r\n  )\r\n    autoPlay(PlayingType.blur)\r\n}\r\n\r\nconst progressiveLazyLoad = () => {\r\n  const slideGroupsToLoad = []\r\n  const spec = { ...settings.value, ...state.value }\r\n  const totalPostClones = getTotalPostClones({\r\n    ...spec,\r\n    slideGroupCount: slideGroupCount.value\r\n  })\r\n  const totalPreClones = getTotalPreClones({\r\n    ...spec,\r\n    slideGroupCount: slideGroupCount.value\r\n  })\r\n  for (\r\n    let index = state.value.currentSlideGroupIndex;\r\n    index < slideGroupCount.value + totalPostClones;\r\n    index++\r\n  ) {\r\n    if (state.value.lazyLoadedList.indexOf(index) < 0) {\r\n      slideGroupsToLoad.push(index)\r\n      break\r\n    }\r\n  }\r\n  for (\r\n    let index = state.value.currentSlideGroupIndex - 1;\r\n    index >= -totalPreClones;\r\n    index--\r\n  ) {\r\n    if (state.value.lazyLoadedList.indexOf(index) < 0) {\r\n      slideGroupsToLoad.push(index)\r\n      break\r\n    }\r\n  }\r\n  if (slideGroupsToLoad.length > 0) {\r\n    state.value.lazyLoadedList =\r\n      state.value.lazyLoadedList.concat(slideGroupsToLoad)\r\n    emit('lazyLoad', slideGroupsToLoad)\r\n  } else {\r\n    if (lazyLoadTimer) {\r\n      clearInterval(lazyLoadTimer)\r\n      lazyLoadTimer = null\r\n    }\r\n  }\r\n}\r\n\r\nconst checkImagesLoad = () => {\r\n  const images = vSlickListRef.value?.querySelectorAll<HTMLImageElement>(\r\n    '.v-slick-slide-group img'\r\n  )\r\n  const imagesCount = images?.length || 0\r\n  let loadedCount = 0\r\n  images?.forEach((image) => {\r\n    const handler = () => {\r\n      if (++loadedCount >= imagesCount) {\r\n        onResize()\r\n      }\r\n    }\r\n    if (!image.onclick) {\r\n      image.onclick = () => {\r\n        ;(image.closest('.v-slick-slide-group') as HTMLElement)?.focus()\r\n      }\r\n    } else {\r\n      const prevClickHandler = image.onclick.bind(image)\r\n      image.onclick = (e) => {\r\n        prevClickHandler(e)\r\n        ;(image.closest('.v-slick-slide-group') as HTMLElement)?.focus()\r\n      }\r\n    }\r\n    if (!image.onload) {\r\n      if (!settings.value.lazyLoad) return\r\n      image.onload = () => {\r\n        adaptHeight()\r\n        callbackTimers.push(setTimeout(onResize, settings.value.speed))\r\n      }\r\n    } else {\r\n      image.onload = handler\r\n      image.onerror = () => {\r\n        handler()\r\n        emit('lazyLoadError')\r\n      }\r\n    }\r\n  })\r\n}\r\n\r\nconst detectWidth = async () => {\r\n  state.value.detectingWidth = true\r\n  return new Promise<void>((resolve) =>\r\n    setTimeout(() => {\r\n      Object.assign(vSlickCarouselStyle.value, {\r\n        width: `${vSlickCarouselRef.value?.offsetWidth}px`\r\n      })\r\n      state.value.detectingWidth = false\r\n      resolve()\r\n    })\r\n  )\r\n}\r\n\r\nconst ssrInit = () => {\r\n  const spec = {\r\n    ...settings.value,\r\n    ...state.value,\r\n    slideGroupCount: slideGroupCount.value\r\n  }\r\n  const preClones = getTotalPreClones(spec)\r\n  const postClones = getTotalPostClones(spec)\r\n  if (settings.value.variableWidth) {\r\n    let trackWidth = [],\r\n      trackLeft = []\r\n    const childrenWidths: number[] = []\r\n    rawSlideGroups.value.forEach((slideGroup) => {\r\n      let maxWidth = 0\r\n      slideGroup.forEach((child) => {\r\n        const { width } = child.props?.style || {}\r\n        if (width) maxWidth = Math.max(maxWidth, width)\r\n      })\r\n      childrenWidths.push(maxWidth)\r\n      trackWidth.push(maxWidth)\r\n    })\r\n    for (let i = 0; i < preClones; i++) {\r\n      trackLeft.push(childrenWidths[childrenWidths.length - 1 - i])\r\n      trackWidth.push(childrenWidths[childrenWidths.length - 1 - i])\r\n    }\r\n    for (let i = 0; i < postClones; i++) {\r\n      trackWidth.push(childrenWidths[i])\r\n    }\r\n    for (let i = 0; i < state.value.currentSlideGroupIndex; i++) {\r\n      trackLeft.push(childrenWidths[i])\r\n    }\r\n    trackWidth = trackWidth.filter((o) => o)\r\n    trackLeft = trackLeft.filter((o) => o)\r\n    const trackStyle = {\r\n      width: `calc(${trackWidth.join(' + ')})`,\r\n      left: `calc(${trackLeft.map((o) => `-${o}`).join(' + ')})`\r\n    }\r\n    if (settings.value.centerMode) {\r\n      const currentWidth = childrenWidths[state.value.currentSlideGroupIndex]\r\n      trackStyle.left = `calc(${trackLeft\r\n        .map((o) => `-${o}`)\r\n        .join(' + ')} + (100% - ${currentWidth}) / 2 )`\r\n    }\r\n    state.value.trackStyle = trackStyle\r\n  } else {\r\n    const _slideGroupCount = preClones + postClones + slideGroupCount.value\r\n    const trackWidth = (100 / settings.value.groupsToShow) * _slideGroupCount\r\n    const slideGroupWidth = 100 / _slideGroupCount\r\n    let trackLeft =\r\n      (-slideGroupWidth *\r\n        (preClones + state.value.currentSlideGroupIndex) *\r\n        trackWidth) /\r\n      100\r\n    if (settings.value.centerMode) {\r\n      trackLeft += (100 - (slideGroupWidth * trackWidth) / 100) / 2\r\n    }\r\n    state.value.slideGroupWidth = slideGroupWidth + '%'\r\n    state.value.trackStyle = {\r\n      width: trackWidth + '%',\r\n      left: trackLeft + '%'\r\n    }\r\n  }\r\n}\r\n\r\nconst breakpoint = ref<number>()\r\n\r\nconst vSlickCarouselRef = ref<HTMLElement>()\r\nconst vSlickCarouselStyle = ref({})\r\nconst vSlickListRef = ref<HTMLElement>()\r\nconst vSlickTrackRef = ref<InstanceType<typeof VSlickTrack>>()\r\n\r\nconst settings = computed<Props>(() => {\r\n  const definedProps = filterUndefined(props)\r\n  let settings = { ...defaultPropValues, ...definedProps }\r\n  if (breakpoint.value) {\r\n    const newProps = props.responsive.find(\r\n      (item) => item.breakpoint === breakpoint.value\r\n    )\r\n    settings = {\r\n      ...settings,\r\n      ...newProps?.settings\r\n    }\r\n  }\r\n  // force scrolling by one group if 'centerMode' is enabled\r\n  if (settings.centerMode) {\r\n    if (settings.groupsToScroll > 1 && process.env.NODE_ENV !== 'production') {\r\n      // eslint-disable-next-line no-console\r\n      console.warn(\r\n        `centerMode is enabled: groupsToScroll should be 1; you are using ${settings.groupsToScroll}`\r\n      )\r\n    }\r\n    settings.groupsToScroll = 1\r\n  }\r\n  // force showing one group and scrolling by one if `fade` is enabled\r\n  if (settings.fade) {\r\n    if (settings.groupsToShow > 1 && process.env.NODE_ENV !== 'production') {\r\n      // eslint-disable-next-line no-console\r\n      console.warn(\r\n        `fade is enabled: groupsToShow should be 1; you are using ${settings.groupsToShow}`\r\n      )\r\n    }\r\n    if (settings.groupsToScroll > 1 && process.env.NODE_ENV !== 'production') {\r\n      // eslint-disable-next-line no-console\r\n      console.warn(\r\n        `fade is enabled: groupsToScroll should be 1; you are using ${settings.groupsToScroll}`\r\n      )\r\n    }\r\n    settings.groupsToShow = 1\r\n    settings.groupsToScroll = 1\r\n  }\r\n  // force disabling `variableWidth` if `slidesPerGroup` is bigger than 1\r\n  if (settings.slidesPerGroup > 1) {\r\n    if (settings.variableWidth && process.env.NODE_ENV !== 'production') {\r\n      // eslint-disable-next-line no-console\r\n      console.warn(`slidesPerGroup is bigger than 1: variableWidth is disabled`)\r\n    }\r\n    settings.variableWidth = false\r\n  }\r\n\r\n  if (settings.vertical && settings.rtl) {\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      // eslint-disable-next-line no-console\r\n      console.warn(`vertical mode is enabled: rtl is disabled`)\r\n    }\r\n    settings.rtl = false\r\n  }\r\n\r\n  return settings\r\n})\r\n\r\nconst canGoPrev = computed(() =>\r\n  checkCanGoPrev({\r\n    ...settings.value,\r\n    ...state.value,\r\n    slideGroupCount: slideGroupCount.value\r\n  })\r\n)\r\n\r\nconst canGoNext = computed(() =>\r\n  checkCanGoNext({\r\n    ...settings.value,\r\n    ...state.value,\r\n    slideGroupCount: slideGroupCount.value\r\n  })\r\n)\r\n\r\nconst pageCount = computed(() => {\r\n  if (settings.value.infinite) {\r\n    return Math.ceil(slideGroupCount.value / settings.value.groupsToScroll)\r\n  }\r\n  let pageCount =\r\n    Math.ceil(\r\n      (slideGroupCount.value - settings.value.groupsToShow) /\r\n        settings.value.groupsToScroll\r\n    ) + 1\r\n  if (\r\n    !settings.value.infinite &&\r\n    settings.value.groupsToShow > 1 &&\r\n    settings.value.centerMode\r\n  ) {\r\n    pageCount++\r\n  }\r\n  return pageCount < 0 ? 0 : pageCount\r\n})\r\n\r\nconst slides = ref<VNode[]>(slots.default ? extractSlides(slots.default()) : [])\r\n\r\nconst state = ref({\r\n  ...makeDefaultSliderState(),\r\n  currentSlideGroupIndex: settings.value.initialGroupIndex\r\n})\r\n\r\nconst currentSlideGroupIndex = computed(\r\n  () => state.value.currentSlideGroupIndex\r\n)\r\n\r\nconst currentGroupsToShow = computed(() => settings.value.groupsToShow)\r\n\r\nconst slideGroupCount = computed(() =>\r\n  getSlideGroupCount(slides.value.length, settings.value.slidesPerGroup)\r\n)\r\n\r\nconst rawSlideGroups = computed<VNode[][]>(() => {\r\n  const slideGroups: VNode[][] = []\r\n  const slidesPerGroup = settings.value.slidesPerGroup\r\n  const slideGroupsCount = slideGroupCount.value\r\n  for (let i = 0; i < slideGroupsCount; i++) {\r\n    const startIndex = i * slidesPerGroup\r\n    const endIndex = startIndex + slidesPerGroup\r\n    slideGroups.push(slides.value.slice(startIndex, endIndex))\r\n  }\r\n  return slideGroups\r\n})\r\n\r\nwatch(\r\n  () => props,\r\n  () => {\r\n    clearBreakpoints()\r\n    makeBreakpoints()\r\n  },\r\n  { deep: true }\r\n)\r\n\r\nwatch(\r\n  settings,\r\n  (newSettings: Props, oldSettings: Props) => {\r\n    let shouldSetTrackStyle = false\r\n    for (const key of Object.keys(settings.value)) {\r\n      if (!newSettings.hasOwnProperty(key)) {\r\n        shouldSetTrackStyle = true\r\n        break\r\n      }\r\n      if (\r\n        typeof newSettings[key as keyof typeof newSettings] === 'object' ||\r\n        typeof newSettings[key as keyof typeof newSettings] === 'function'\r\n      ) {\r\n        continue\r\n      }\r\n      if (\r\n        newSettings[key as keyof typeof newSettings] !==\r\n        oldSettings[key as keyof typeof newSettings]\r\n      ) {\r\n        shouldSetTrackStyle = true\r\n        break\r\n      }\r\n    }\r\n    updateState(shouldSetTrackStyle)\r\n    if (state.value.currentSlideGroupIndex >= slideGroupCount.value) {\r\n      changeSlideGroup({\r\n        message: 'index',\r\n        index: slideGroupCount.value - newSettings.groupsToShow\r\n      })\r\n    }\r\n    if (newSettings.autoplay) {\r\n      autoPlay(PlayingType.update)\r\n    } else {\r\n      pause(PlayingType.paused)\r\n    }\r\n  },\r\n  {\r\n    deep: true\r\n  }\r\n)\r\n\r\nwatch(\r\n  () => slots.default?.() || [],\r\n  (newSlots) => {\r\n    slides.value = extractSlides(newSlots)\r\n  }\r\n)\r\n\r\nwatch(\r\n  () => [\r\n    state.value.listHeight,\r\n    settings.value.centerMode,\r\n    settings.value.centerPadding,\r\n    settings.value.vertical\r\n  ],\r\n  ([listHeight, centerMode, centerPadding, vertical]) => {\r\n    let verticalHeightStyle = {\r\n      height: 'auto'\r\n    }\r\n    if (vertical) {\r\n      verticalHeightStyle = {\r\n        height: `${listHeight}px`\r\n      }\r\n    }\r\n\r\n    let centerPaddingStyle\r\n    if (!centerMode) {\r\n      centerPaddingStyle = {\r\n        padding: '0'\r\n      }\r\n    } else if (vertical) {\r\n      centerPaddingStyle = {\r\n        padding: centerPadding + ' 0px'\r\n      }\r\n    } else {\r\n      centerPaddingStyle = {\r\n        padding: '0px ' + centerPadding\r\n      }\r\n    }\r\n    vSlickListStyle.value = {\r\n      ...vSlickListStyle.value,\r\n      ...filterUndefined(verticalHeightStyle),\r\n      ...centerPaddingStyle\r\n    }\r\n  }\r\n)\r\n\r\nwatch(\r\n  () => [\r\n    settings.value.infinite,\r\n    state.value.currentSlideGroupIndex,\r\n    settings.value.groupsToShow,\r\n    slideGroupCount.value\r\n  ],\r\n  ([infinite, groupsIndex, groupToShow, slideGroupCount]) => {\r\n    if (\r\n      infinite ||\r\n      (groupsIndex as number) <=\r\n        (slideGroupCount as number) - (groupToShow as number) + 1\r\n    )\r\n      return\r\n    slideGroupHandler(pageCount.value - 1)\r\n  }\r\n)\r\n\r\nwatch(\r\n  () => state.value.dragging,\r\n  (dragging) => {\r\n    if (!vSlickListRef.value) return\r\n    if (dragging) {\r\n      vSlickListRef.value.onmousemove = handleMouseMoveOrTouchMoveVSlickList\r\n      vSlickListRef.value.ontouchmove = handleMouseMoveOrTouchMoveVSlickList\r\n      vSlickListRef.value.onmouseup = handleMouseUpOrTouchEndVSlickList\r\n      vSlickListRef.value.ontouchend = handleMouseUpOrTouchEndVSlickList\r\n      vSlickListRef.value.onmouseleave = handleMouseLeaveOrTouchCancelVSlickList\r\n      vSlickListRef.value.ontouchcancel =\r\n        handleMouseLeaveOrTouchCancelVSlickList\r\n    } else {\r\n      vSlickListRef.value.onmousemove = null\r\n      vSlickListRef.value.ontouchmove = null\r\n      vSlickListRef.value.onmouseup = null\r\n      vSlickListRef.value.ontouchend = null\r\n      vSlickListRef.value.onmouseleave = null\r\n      vSlickListRef.value.ontouchcancel = null\r\n    }\r\n  }\r\n)\r\n\r\ndefineExpose({\r\n  goTo: slideGroupHandler,\r\n  next: () => {\r\n    slideGroupHandler(\r\n      state.value.currentSlideGroupIndex + settings.value.groupsToScroll\r\n    )\r\n  },\r\n  prev: () => {\r\n    slideGroupHandler(\r\n      state.value.currentSlideGroupIndex - settings.value.groupsToScroll\r\n    )\r\n  },\r\n  canGoNext,\r\n  canGoPrev,\r\n  play,\r\n  pause,\r\n  autoPlay,\r\n  slideGroupCount,\r\n  currentSlideGroupIndex,\r\n  currentGroupsToShow,\r\n  pageCount\r\n})\r\n\r\nonMounted(async () => {\r\n  window.addEventListener('resize', onResizeEventListener)\r\n  if (settings.value.widthDetection === WidthDetection.manual) {\r\n    await detectWidth()\r\n  }\r\n  updateState(true)\r\n  adaptHeight()\r\n  if (settings.value.autoplay) {\r\n    autoPlay(PlayingType.update)\r\n  }\r\n  if (settings.value.lazyLoad === LazyLoadType.progressive) {\r\n    lazyLoadTimer = setInterval(progressiveLazyLoad, 1000)\r\n  }\r\n  ro = new ResizeObserver(() => {\r\n    if (state.value.animating) {\r\n      onResize({ shouldSetTrackStyle: false }) // do not set trackStyle so as to not break the animation\r\n      callbackTimers.push(setTimeout(() => onResize(), settings.value.speed))\r\n    } else {\r\n      onResize()\r\n    }\r\n  })\r\n  ro.observe(vSlickListRef.value as Element)\r\n  vSlickListRef.value\r\n    ?.querySelectorAll<HTMLElement>('.v-slick-slide-group')\r\n    .forEach((slideGroup) => {\r\n      slideGroup.onfocus = settings.value.pauseOnFocus\r\n        ? onSlideGroupFocus\r\n        : null\r\n      slideGroup.onblur = settings.value.pauseOnFocus ? onSlideGroupBlur : null\r\n    })\r\n})\r\n\r\nonUpdated(() => {\r\n  checkImagesLoad()\r\n  emit('reInit')\r\n  if (settings.value.lazyLoad) {\r\n    const slideGroupsToLoad = getOnDemandLazySlideGroups({\r\n      ...settings.value,\r\n      ...state.value\r\n    })\r\n    if (slideGroupsToLoad.length) {\r\n      state.value.lazyLoadedList =\r\n        state.value.lazyLoadedList.concat(slideGroupsToLoad)\r\n      emit('lazyLoad', slideGroupsToLoad)\r\n    }\r\n  }\r\n  adaptHeight()\r\n})\r\n\r\nonBeforeUnmount(() => {\r\n  window.removeEventListener('resize', onResizeEventListener)\r\n  ro?.unobserve(vSlickListRef.value as Element)\r\n  if (animationEndCallback) {\r\n    clearTimeout(animationEndCallback)\r\n  }\r\n  if (lazyLoadTimer) {\r\n    clearInterval(lazyLoadTimer)\r\n  }\r\n  if (callbackTimers.length) {\r\n    callbackTimers.forEach((timer) => clearTimeout(timer))\r\n    callbackTimers = []\r\n  }\r\n  if (state.value.autoplayTimer) {\r\n    clearInterval(state.value.autoplayTimer)\r\n  }\r\n})\r\n\r\nmakeBreakpoints()\r\nssrInit()\r\nemit('init')\r\n</script>\r\n\r\n<style scoped lang=\"scss\">\r\n.v-slick-slider {\r\n  position: relative;\r\n  display: block;\r\n  box-sizing: border-box;\r\n}\r\n.v-slick-list {\r\n  position: relative;\r\n  display: block;\r\n  overflow: hidden;\r\n  margin: 0;\r\n  padding: 0;\r\n  transform: translate3d(0, 0, 0);\r\n  &:focus {\r\n    outline: none;\r\n  }\r\n  &.dragging {\r\n    cursor: pointer;\r\n    cursor: hand;\r\n  }\r\n}\r\n</style>\r\n"],"names":["PlayingType","LazyLoadType","SwipeDirection","SlideNavigation","WidthDetection","extractSlides","vnodes","vnode","isSlide","getNavigationOnKeyType","accessibility","rtl","_a","getChangedSlideGroupIndex","spec","options","indexOffset","previousInt","slideGroupOffset","unevenOffset","targetSlideGroupIndex","groupsToScroll","groupsToShow","slideGroupCount","currentSlideGroupIndex","lazyLoad","infinite","direction","siblingDirection","totalVisibleGroupsOnRightOfCurrGroup","totalVisibleGroupsOnLeftOfCurrGroup","centerMode","centerPadding","right","left","getNavigableIndexes","max","breakpoint","counter","indexes","checkNavigable","index","navigables","prevNavigable","n","getSwipeStartState","swipe","draggable","getTraversedSlideGroupCount","centerOffset","swipedSlideGroup","slideGroups","grp","currentIndex","swipedSlideGroupIndex","getSwipeDirection","touchObject","verticalSwiping","xDist","yDist","r","swipeAngle","getSwipeEndState","dragging","listWidth","touchThreshold","listHeight","swipeToSlide","scrolling","onSwipe","minSwipe","swipeDirection","state","newSlideGroupIndex","currentLeft","getTrackLeft","getTrackAnimateCSS","getLazySlidesOnLeft","getLazySlidesOnRight","getLazyStartIndex","getLazyEndIndex","getOnDemandLazySlideGroups","onDemandSlideGroups","startIndex","endIndex","slideGroupIndex","getTrackCSS","trackWidth","trackHeight","trackChildren","getTotalSlideGroups","style","transform","getTotalPreClones","getTotalPostClones","trackEl","slideGroupWidth","variableWidth","slideGroupHeight","fade","vertical","targetLeft","targetSlide","verticalOffset","slidesToOffset","targetSlideIndex","slide","canGoPrev","canGoNext","canGo","getStatesOnSlide","waitForAnimate","animating","lazyLoadedList","useCSSTransitions","animationSlideGroupIndex","finalSlideGroupIndex","slidingState","afterSlidingState","finalLeft","animationLeft","getSwipeMoveState","edgeFriction","edgeDragged","onEdge","swiped","swiping","swipeEvent","swipeLeft","curLeft","verticalSwipeLength","positionOffset","dotCount","touchSwipeLength","getSlideGroupCount","slideCount","getSliderState","_b","centerPaddingAdj","_c","slideGroupsToLoad","sliderState","canUseDOM","filterUndefined","props","key","acc","clearSelection","makeDefaultProps","selectFields","defaultProps","defaultPropValues","makeDefaultSliderState","defaultTrackProps","defaultArrowProps","defaultDotsProps","QueryHandler","QueryHandler$1","target","QueryHandler_1","each","collection","fn","i","length","cont","isArray","isFunction","Util","require$$0","require$$1","MediaQuery","query","isUnconditional","self","mql","MediaQuery$1","handler","qh","handlers","h","action","MediaQuery_1","MediaQueryDispatch","MediaQueryDispatch$1","q","shouldDegrade","queries","MediaQueryDispatch_1","src","camel2hyphen","str","match","camel2hyphen_1","isDimension","feature","re","obj2mq","obj","mq","features","value","json2mq","json2mq_1","__props","emit","__emit","clickHandler","computed","arrowSlotProps","getSlideGroupClasses","isActive","isCenter","isCurrent","getSlideGroupStyle","originalSlideGroups","rawSlideGroup","classes","slideGroup","preCloneSlideGroups","preCloneNo","postCloneSlideGroups","leftBound","rightBound","FUNC_ERROR_TEXT","NAN","symbolTag","reTrim","reIsBadHex","reIsBinary","reIsOctal","freeParseInt","freeGlobal","global","freeSelf","root","objectProto","objectToString","nativeMax","nativeMin","now","debounce","func","wait","lastArgs","lastThis","maxWait","result","timerId","lastCallTime","lastInvokeTime","leading","maxing","trailing","toNumber","isObject","invokeFunc","time","args","thisArg","leadingEdge","timerExpired","remainingWait","timeSinceLastCall","timeSinceLastInvoke","shouldInvoke","trailingEdge","cancel","flush","debounced","isInvoking","type","isObjectLike","isSymbol","other","isBinary","lodash_debounce","DEBOUNCE_RESIZE_DURATION","slots","useSlots","enquire","enquireJs","triggerSlideGroupHandler","animationEndCallback","lazyLoadTimer","callbackTimers","vSlickListStyle","ref","getCurrentInstance","isVSlickListClickable","debouncedResize","ro","responsiveMediaHandlers","media","clearBreakpoints","makeBreakpoints","breakpoints","item","a","b","_breakpoint","mediaQuery","swipeStart","e","swipeStartState","settings","swipeEnd","swipeEndState","vSlickTrackRef","vSlickListRef","newTriggerSlideGroupHandler","rest","slideGroupHandler","swipeMove","swipeMoveState","play","nextIndex","pause","pauseType","autoplaying","autoPlay","playType","adaptHeight","activeSlideGroups","maxHeight","onTrackOver","onTrackLeave","handleClickVSlickList","handleChildClickVSlickTrack","changeSlideGroup","handleKeyDownVSlickList","navigation","handleMouseDownOrTouchStartVSlickList","handleMouseMoveOrTouchMoveVSlickList","handleMouseUpOrTouchEndVSlickList","handleMouseLeaveOrTouchCancelVSlickList","handleMouseEnterOrOverVSlickTrack","handleMouseLeaveVSlickTrack","handleOverDots","handleLeaveDots","handleClickDot","handleNextVSlickArrow","handlePrevVSlickArrow","dontAnimate","asNavFor","speed","states","slidesToLoad","resolve","firstBatch","updateState","shouldSetTrackStyle","updatedState","slides","trackStyle","resize","detectWidth","onResize","onResizeEventListener","onSlideGroupFocus","onSlideGroupBlur","progressiveLazyLoad","totalPostClones","totalPreClones","checkImagesLoad","images","imagesCount","loadedCount","image","prevClickHandler","vSlickCarouselStyle","vSlickCarouselRef","ssrInit","preClones","postClones","trackLeft","childrenWidths","rawSlideGroups","maxWidth","child","width","o","currentWidth","_slideGroupCount","definedProps","newProps","checkCanGoPrev","checkCanGoNext","pageCount","currentGroupsToShow","slidesPerGroup","slideGroupsCount","watch","newSettings","oldSettings","newSlots","verticalHeightStyle","centerPaddingStyle","groupsIndex","groupToShow","__expose","onMounted","onUpdated","onBeforeUnmount","timer"],"mappings":"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","x_google_ignoreList":[4,5,6,7,8,9,10,14]}