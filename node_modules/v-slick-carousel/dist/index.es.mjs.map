{"version":3,"file":"index.es.mjs","sources":["../lib/types/enums.ts","../lib/utils/carousel-utils.ts","../lib/utils/index.ts","../lib/components/props.ts","../../../node_modules/.pnpm/@dcufo+enquire.js@2.1.9/node_modules/@dcufo/enquire.js/src/QueryHandler.js","../../../node_modules/.pnpm/@dcufo+enquire.js@2.1.9/node_modules/@dcufo/enquire.js/src/Util.js","../../../node_modules/.pnpm/@dcufo+enquire.js@2.1.9/node_modules/@dcufo/enquire.js/src/MediaQuery.js","../../../node_modules/.pnpm/@dcufo+enquire.js@2.1.9/node_modules/@dcufo/enquire.js/src/MediaQueryDispatch.js","../../../node_modules/.pnpm/@dcufo+enquire.js@2.1.9/node_modules/@dcufo/enquire.js/src/index.js","../../../node_modules/.pnpm/string-convert@0.2.1/node_modules/string-convert/camel2hyphen.js","../../../node_modules/.pnpm/json2mq@0.2.0/node_modules/json2mq/index.js","../lib/components/VSlickArrow.vue","../lib/components/VSlickTrack.vue","../lib/components/VSlickDots.vue","../../../node_modules/.pnpm/lodash.debounce@4.0.8/node_modules/lodash.debounce/index.js","../lib/components/VSlickCarousel.vue"],"sourcesContent":["export enum PlayingType {\r\n  play = 'play',\r\n  playing = 'playing',\r\n  paused = 'paused',\r\n  hovered = 'hovered',\r\n  focused = 'focused',\r\n  update = 'update',\r\n  leave = 'leave',\r\n  blur = 'blur'\r\n}\r\n\r\nexport enum LazyLoadType {\r\n  ondemand = 'ondemand',\r\n  progressive = 'progressive'\r\n}\r\n\r\nexport enum SwipeDirection {\r\n  left = 'left',\r\n  right = 'right',\r\n  up = 'up',\r\n  down = 'down',\r\n  vertical = 'vertical'\r\n}\r\n\r\nexport enum SlideNavigation {\r\n  next = 'next',\r\n  previous = 'previous'\r\n}\r\n\r\nexport enum WidthDetection {\r\n  auto = 'auto',\r\n  manual = 'manual'\r\n}\r\n","import { VNode } from 'vue'\r\nimport {\r\n  CloneInfoSpec,\r\n  GoNextSpec,\r\n  GoPrevSpec,\r\n  LazyInfoSpec,\r\n  NavigableSpec,\r\n  OnSlideSpec,\r\n  PlayingType,\r\n  SlideGroupChangeOptions,\r\n  SlideGroupChangeSpec,\r\n  SlideGroupCountSpec,\r\n  SlideNavigation,\r\n  SliderState,\r\n  SliderStateInfoSpec,\r\n  SwipeDirection,\r\n  SwipeEndSpec,\r\n  SwipeEndState,\r\n  SwipeEvent,\r\n  SwipeMoveSpec,\r\n  SwipeMoveState,\r\n  TouchObject,\r\n  TrackInfoSpec\r\n} from '../types'\r\nimport { MarkRequiredWithPartialBase } from '@lib/types/helpers'\r\n\r\nexport const extractSlides = (vnodes: VNode[]): VNode[] => {\r\n  return vnodes.flatMap((vnode) =>\r\n    isSlide(vnode)\r\n      ? [vnode]\r\n      : Array.isArray(vnode.children) && vnode.children.length > 0\r\n        ? extractSlides(vnode.children as VNode[])\r\n        : []\r\n  )\r\n}\r\n\r\nfunction isSlide(vnode: VNode): boolean {\r\n  return !vnode.type.toString().startsWith('Symbol')\r\n}\r\n\r\nexport const getNavigationOnKeyType = (\r\n  e: KeyboardEvent,\r\n  accessibility: boolean,\r\n  rtl: boolean\r\n) => {\r\n  if (\r\n    (e.target as HTMLElement)?.tagName.match('TEXTAREA|INPUT|SELECT') ||\r\n    !accessibility\r\n  )\r\n    return ''\r\n  if (e.key === 'ArrowLeft')\r\n    return rtl ? SlideNavigation.next : SlideNavigation.previous\r\n  if (e.key === 'ArrowRight')\r\n    return rtl ? SlideNavigation.previous : SlideNavigation.next\r\n  return ''\r\n}\r\n\r\nexport const getChangedSlideGroupIndex = (\r\n  spec: SlideGroupChangeSpec,\r\n  options: SlideGroupChangeOptions\r\n) => {\r\n  let indexOffset,\r\n    previousInt,\r\n    slideGroupOffset,\r\n    unevenOffset,\r\n    targetSlideGroupIndex\r\n  const {\r\n    groupsToScroll,\r\n    groupsToShow,\r\n    slideGroupCount,\r\n    currentSlideGroupIndex,\r\n    lazyLoad,\r\n    infinite\r\n  } = spec\r\n  unevenOffset = slideGroupCount % groupsToScroll !== 0\r\n  indexOffset = unevenOffset\r\n    ? 0\r\n    : (slideGroupCount - currentSlideGroupIndex) % groupsToScroll\r\n\r\n  if (options.message === SlideNavigation.previous) {\r\n    slideGroupOffset =\r\n      indexOffset === 0 ? groupsToScroll : groupsToShow - indexOffset\r\n    targetSlideGroupIndex = currentSlideGroupIndex - slideGroupOffset\r\n    if (lazyLoad && !infinite) {\r\n      previousInt = currentSlideGroupIndex - slideGroupOffset\r\n      targetSlideGroupIndex =\r\n        previousInt === -1 ? slideGroupCount - 1 : previousInt\r\n    }\r\n  } else if (options.message === SlideNavigation.next) {\r\n    slideGroupOffset = indexOffset === 0 ? groupsToScroll : indexOffset\r\n    targetSlideGroupIndex = currentSlideGroupIndex + slideGroupOffset\r\n    if (lazyLoad && !infinite) {\r\n      targetSlideGroupIndex =\r\n        ((currentSlideGroupIndex + groupsToScroll) % slideGroupCount) +\r\n        indexOffset\r\n    }\r\n  } else if (options.message === 'dots') {\r\n    // Click on dots\r\n    targetSlideGroupIndex = (options.index || 0) * groupsToScroll\r\n    if (targetSlideGroupIndex === currentSlideGroupIndex) {\r\n      return null\r\n    }\r\n  } else if (options.message === 'children') {\r\n    // Click on the slides\r\n    targetSlideGroupIndex = options.index || 0\r\n    if (targetSlideGroupIndex === currentSlideGroupIndex) {\r\n      return null\r\n    }\r\n    if (infinite) {\r\n      let direction = siblingDirection({ ...spec, targetSlideGroupIndex })\r\n      if (\r\n        targetSlideGroupIndex > currentSlideGroupIndex &&\r\n        direction === 'left'\r\n      ) {\r\n        targetSlideGroupIndex = targetSlideGroupIndex - slideGroupCount\r\n      } else if (\r\n        targetSlideGroupIndex < currentSlideGroupIndex &&\r\n        direction === 'right'\r\n      ) {\r\n        targetSlideGroupIndex = targetSlideGroupIndex + slideGroupCount\r\n      }\r\n    }\r\n  } else if (options.message === 'index') {\r\n    targetSlideGroupIndex = Number(options.index)\r\n    if (targetSlideGroupIndex === currentSlideGroupIndex) {\r\n      return null\r\n    }\r\n  }\r\n  return targetSlideGroupIndex\r\n}\r\n\r\nexport const siblingDirection = (\r\n  spec: SlideGroupChangeSpec & { targetSlideGroupIndex: number }\r\n) => {\r\n  if (spec.targetSlideGroupIndex > spec.currentSlideGroupIndex) {\r\n    if (\r\n      spec.targetSlideGroupIndex >\r\n      spec.currentSlideGroupIndex + totalVisibleGroupsOnRightOfCurrGroup(spec)\r\n    ) {\r\n      return 'left'\r\n    }\r\n    return 'right'\r\n  } else {\r\n    if (\r\n      spec.targetSlideGroupIndex <\r\n      spec.currentSlideGroupIndex - totalVisibleGroupsOnLeftOfCurrGroup(spec)\r\n    ) {\r\n      return 'right'\r\n    }\r\n    return 'left'\r\n  }\r\n}\r\n\r\nconst totalVisibleGroupsOnRightOfCurrGroup = ({\r\n  groupsToShow,\r\n  centerMode,\r\n  rtl,\r\n  centerPadding\r\n}: SlideGroupChangeSpec) => {\r\n  if (centerMode) {\r\n    let right = (groupsToShow - 1) / 2 + 1\r\n    if (parseInt(centerPadding) > 0) right += 1\r\n    if (rtl && groupsToShow % 2 === 0) right += 1\r\n    return right\r\n  }\r\n  if (rtl) {\r\n    return 0\r\n  }\r\n  return groupsToShow - 1\r\n}\r\n\r\nconst totalVisibleGroupsOnLeftOfCurrGroup = ({\r\n  groupsToShow,\r\n  centerMode,\r\n  rtl,\r\n  centerPadding\r\n}: SlideGroupChangeSpec) => {\r\n  if (centerMode) {\r\n    let left = (groupsToShow - 1) / 2 + 1\r\n    if (parseInt(centerPadding) > 0) left += 1\r\n    if (!rtl && groupsToShow % 2 === 0) left += 1\r\n    return left\r\n  }\r\n  if (rtl) {\r\n    return groupsToShow - 1\r\n  }\r\n  return 0\r\n}\r\n\r\nexport const getNavigableIndexes = (spec: NavigableSpec) => {\r\n  let max = spec.infinite ? spec.slideGroupCount * 2 : spec.slideGroupCount\r\n  let breakpoint = spec.infinite ? spec.groupsToShow * -1 : 0\r\n  let counter = spec.infinite ? spec.groupsToShow * -1 : 0\r\n  let indexes = []\r\n  while (breakpoint < max) {\r\n    indexes.push(breakpoint)\r\n    breakpoint = counter + spec.groupsToScroll\r\n    counter += Math.min(spec.groupsToScroll, spec.groupsToShow)\r\n  }\r\n  return indexes\r\n}\r\n\r\nexport const checkNavigable = (spec: NavigableSpec, index: number) => {\r\n  const navigables = getNavigableIndexes(spec)\r\n  let prevNavigable = 0\r\n  if (index > navigables[navigables.length - 1]) {\r\n    index = navigables[navigables.length - 1]\r\n  } else {\r\n    for (let n in navigables) {\r\n      if (index < navigables[n]) {\r\n        index = prevNavigable\r\n        break\r\n      }\r\n      prevNavigable = navigables[n]\r\n    }\r\n  }\r\n  return index\r\n}\r\n\r\nexport const getSwipeStartState = (\r\n  e: SwipeEvent,\r\n  swipe: boolean,\r\n  draggable: boolean\r\n) => {\r\n  if (!swipe || (!draggable && e.type.indexOf('mouse') !== -1)) return\r\n  return {\r\n    dragging: true,\r\n    touchObject: {\r\n      startX:\r\n        window.TouchEvent && e instanceof TouchEvent\r\n          ? e.touches[0].pageX\r\n          : (e as MouseEvent).clientX,\r\n      startY:\r\n        window.TouchEvent && e instanceof TouchEvent\r\n          ? e.touches[0].pageY\r\n          : (e as MouseEvent).clientY,\r\n      curX:\r\n        window.TouchEvent && e instanceof TouchEvent\r\n          ? e.touches[0].pageX\r\n          : (e as MouseEvent).clientX,\r\n      curY:\r\n        window.TouchEvent && e instanceof TouchEvent\r\n          ? e.touches[0].pageY\r\n          : (e as MouseEvent).clientY\r\n    }\r\n  }\r\n}\r\n\r\nexport const getTraversedSlideGroupCount = (spec: SlideGroupCountSpec) => {\r\n  const centerOffset = spec.centerMode\r\n    ? +spec.slideGroupWidth * Math.floor(spec.groupsToShow / 2)\r\n    : 0\r\n  let swipedSlideGroup\r\n  const slickList = spec.listEl\r\n  const slideGroups = slickList.querySelectorAll<HTMLElement>(\r\n    '.v-slick-slide-group'\r\n  )\r\n  Array.from(slideGroups).every((grp) => {\r\n    if (!spec.vertical) {\r\n      if (\r\n        grp.offsetLeft - centerOffset + grp.offsetWidth / 2 >\r\n        spec.swipeLeft * -1\r\n      ) {\r\n        swipedSlideGroup = grp\r\n        return false\r\n      }\r\n    } else {\r\n      if (grp.offsetTop + grp.offsetHeight / 2 > spec.swipeLeft * -1) {\r\n        swipedSlideGroup = grp\r\n        return false\r\n      }\r\n    }\r\n\r\n    return true\r\n  })\r\n\r\n  if (!swipedSlideGroup) {\r\n    return 0\r\n  }\r\n  const currentIndex =\r\n    spec.rtl === true\r\n      ? spec.slideGroupCount - spec.currentSlideGroupIndex\r\n      : spec.currentSlideGroupIndex\r\n  const swipedSlideGroupIndex = (swipedSlideGroup as HTMLElement)?.dataset\r\n    ?.index\r\n  const groupsTraversed = Math.abs(\r\n    swipedSlideGroupIndex ? parseInt(swipedSlideGroupIndex) : 0 - currentIndex\r\n  )\r\n  return groupsTraversed\r\n}\r\n\r\nexport const getSwipeDirection = (\r\n  touchObject: TouchObject,\r\n  verticalSwiping = false\r\n): SwipeDirection => {\r\n  let xDist, yDist, r, swipeAngle\r\n  xDist = touchObject.startX - touchObject.curX\r\n  yDist = touchObject.startY - touchObject.curY\r\n  r = Math.atan2(yDist, xDist)\r\n  swipeAngle = Math.round((r * 180) / Math.PI)\r\n  if (swipeAngle < 0) {\r\n    swipeAngle = 360 - Math.abs(swipeAngle)\r\n  }\r\n  if (\r\n    (swipeAngle <= 45 && swipeAngle >= 0) ||\r\n    (swipeAngle <= 360 && swipeAngle >= 315)\r\n  ) {\r\n    return SwipeDirection.left\r\n  }\r\n  if (swipeAngle >= 135 && swipeAngle <= 225) {\r\n    return SwipeDirection.right\r\n  }\r\n  if (verticalSwiping === true) {\r\n    if (swipeAngle >= 35 && swipeAngle <= 135) {\r\n      return SwipeDirection.up\r\n    } else {\r\n      return SwipeDirection.down\r\n    }\r\n  }\r\n\r\n  return SwipeDirection.vertical\r\n}\r\n\r\nexport const getSwipeEndState = (\r\n  e: SwipeEvent,\r\n  spec: SwipeEndSpec\r\n): SwipeEndState | undefined => {\r\n  const {\r\n    dragging,\r\n    swipe,\r\n    touchObject,\r\n    listWidth,\r\n    touchThreshold,\r\n    verticalSwiping,\r\n    listHeight,\r\n    currentSlideGroupIndex,\r\n    swipeToSlide,\r\n    scrolling,\r\n    onSwipe,\r\n    rtl\r\n  } = spec\r\n  if (!dragging) {\r\n    if (swipe) e.preventDefault()\r\n    return\r\n  }\r\n  let minSwipe = verticalSwiping\r\n    ? listHeight / touchThreshold\r\n    : listWidth / touchThreshold\r\n  let swipeDirection = getSwipeDirection(touchObject, verticalSwiping)\r\n  if (rtl) {\r\n    if (swipeDirection === SwipeDirection.left) {\r\n      swipeDirection = SwipeDirection.right\r\n    } else if (swipeDirection === SwipeDirection.right) {\r\n      swipeDirection = SwipeDirection.left\r\n    }\r\n  }\r\n  // reset the state of touch related state variables.\r\n  let state: SwipeEndState = {\r\n    dragging: false,\r\n    edgeDragged: false,\r\n    scrolling: false,\r\n    swiping: false,\r\n    swiped: false,\r\n    swipeLeft: null,\r\n    touchObject: {}\r\n  }\r\n  if (scrolling) {\r\n    return state\r\n  }\r\n  if (!touchObject.swipeLength) {\r\n    return state\r\n  }\r\n  if (touchObject.swipeLength > minSwipe) {\r\n    e.preventDefault()\r\n    if (onSwipe) {\r\n      onSwipe(swipeDirection)\r\n    }\r\n    let slideGroupCount, newSlideGroupIndex\r\n    switch (swipeDirection) {\r\n      case 'left':\r\n      case 'up':\r\n        newSlideGroupIndex = spec.swipeToSlide\r\n          ? getTraversedSlideGroupCount(spec)\r\n          : currentSlideGroupIndex + spec.groupsToScroll\r\n        slideGroupCount = swipeToSlide\r\n          ? checkNavigable(spec, newSlideGroupIndex)\r\n          : newSlideGroupIndex\r\n        state.currentDirection = 0\r\n        break\r\n      case 'right':\r\n      case 'down':\r\n        newSlideGroupIndex = spec.swipeToSlide\r\n          ? getTraversedSlideGroupCount(spec)\r\n          : currentSlideGroupIndex - spec.groupsToScroll\r\n        slideGroupCount = swipeToSlide\r\n          ? checkNavigable(spec, newSlideGroupIndex)\r\n          : newSlideGroupIndex\r\n        state.currentDirection = 1\r\n        break\r\n      default:\r\n        slideGroupCount = currentSlideGroupIndex\r\n    }\r\n    state.triggerSlideGroupHandler = slideGroupCount\r\n  } else {\r\n    // Adjust the track back to its original position.\r\n    let currentLeft = getTrackLeft(spec)\r\n    state.trackStyle = getTrackAnimateCSS(spec, currentLeft)\r\n  }\r\n  return state\r\n}\r\n\r\nexport function getLazySlidesOnLeft(spec: LazyInfoSpec) {\r\n  return spec.centerMode\r\n    ? Math.floor(spec.groupsToShow / 2) +\r\n        (parseInt(spec.centerPadding) > 0 ? 1 : 0)\r\n    : 0\r\n}\r\n\r\nexport function getLazySlidesOnRight(spec: LazyInfoSpec) {\r\n  return spec.centerMode\r\n    ? Math.floor((spec.groupsToShow - 1) / 2) +\r\n        1 +\r\n        (parseInt(spec.centerPadding) > 0 ? 1 : 0)\r\n    : spec.groupsToShow\r\n}\r\n\r\nexport function getLazyStartIndex(spec: LazyInfoSpec) {\r\n  return spec.currentSlideGroupIndex - getLazySlidesOnLeft(spec)\r\n}\r\n\r\nexport function getLazyEndIndex(spec: LazyInfoSpec) {\r\n  return spec.currentSlideGroupIndex + getLazySlidesOnRight(spec)\r\n}\r\n\r\nexport function getOnDemandLazySlideGroups(spec: LazyInfoSpec) {\r\n  let onDemandSlideGroups = []\r\n  const startIndex = getLazyStartIndex(spec)\r\n  const endIndex = getLazyEndIndex(spec)\r\n  for (\r\n    let slideGroupIndex = startIndex;\r\n    slideGroupIndex < endIndex;\r\n    slideGroupIndex++\r\n  ) {\r\n    if (spec.lazyLoadedList?.indexOf(slideGroupIndex) < 0) {\r\n      onDemandSlideGroups.push(slideGroupIndex)\r\n    }\r\n  }\r\n  return onDemandSlideGroups\r\n}\r\n\r\nexport function getTrackCSS(spec: TrackInfoSpec, left: number) {\r\n  let trackWidth, trackHeight\r\n  const trackChildren = spec.slideGroupCount + 2 * spec.groupsToShow\r\n  if (!spec.vertical) {\r\n    trackWidth =\r\n      getTotalSlideGroups(spec) * parseInt(`${spec.slideGroupWidth || 0}`)\r\n  } else {\r\n    trackHeight = trackChildren * parseInt(`${spec.slideGroupHeight || 0}`)\r\n  }\r\n  let style: Record<string, string | number> = {\r\n    opacity: 1,\r\n    transition: ''\r\n  }\r\n  if (spec.useCSSTransform) {\r\n    let transform = !spec.vertical\r\n      ? 'translate3d(' + left + 'px, 0px, 0px)'\r\n      : 'translate3d(0px, ' + left + 'px, 0px)'\r\n    style = {\r\n      ...style,\r\n      transform\r\n    }\r\n  } else {\r\n    if (spec.vertical) {\r\n      style['top'] = left\r\n    } else {\r\n      style['left'] = left\r\n    }\r\n  }\r\n  if (spec.fade) style = { opacity: 1 }\r\n  if (trackWidth) style.width = trackWidth + 'px'\r\n  if (trackHeight) style.height = trackHeight + 'px'\r\n\r\n  return style\r\n}\r\n\r\nexport function getTotalSlideGroups(spec: TrackInfoSpec) {\r\n  return spec.slideGroupCount <= spec.groupsToShow\r\n    ? spec.slideGroupCount\r\n    : getTotalPreClones(spec) + spec.slideGroupCount + getTotalPostClones(spec)\r\n}\r\n\r\nexport function getTrackAnimateCSS(spec: TrackInfoSpec, left: number) {\r\n  let style = getTrackCSS(spec, left)\r\n  // useCSS is true by default so it can be undefined\r\n  if (spec.useCSSTransform) {\r\n    style.transition = 'transform ' + spec.speed + 'ms ' + spec.cssEase\r\n  } else {\r\n    if (spec.vertical) {\r\n      style.transition = 'top ' + spec.speed + 'ms ' + spec.cssEase\r\n    } else {\r\n      style.transition = 'left ' + spec.speed + 'ms ' + spec.cssEase\r\n    }\r\n  }\r\n  if (spec.ignorePrefersReducedMotion) {\r\n    style.transition += ' !important'\r\n  }\r\n  return style\r\n}\r\n\r\nexport function getTrackLeft(spec: TrackInfoSpec) {\r\n  let {\r\n    centerPadding,\r\n    currentSlideGroupIndex,\r\n    trackEl,\r\n    infinite,\r\n    centerMode,\r\n    slideGroupCount,\r\n    groupsToShow,\r\n    groupsToScroll,\r\n    slideGroupWidth,\r\n    listWidth,\r\n    variableWidth,\r\n    slideGroupHeight,\r\n    fade,\r\n    vertical,\r\n    rtl\r\n  } = spec\r\n  listWidth = listWidth || 0\r\n  slideGroupWidth = slideGroupWidth || 0\r\n  slideGroupHeight = slideGroupHeight || 0\r\n\r\n  let slideGroupOffset = 0\r\n  let targetLeft\r\n  let targetSlide: HTMLElement\r\n  let verticalOffset = 0\r\n\r\n  if (fade || slideGroupCount === 1) {\r\n    return 0\r\n  }\r\n\r\n  let slidesToOffset = 0\r\n  if (infinite) {\r\n    slidesToOffset = -getTotalPreClones(spec) // bring active slide to the beginning of visible area\r\n    // if next scroll doesn't have enough children, just reach till the end of original slides instead of shifting groupsToScroll children\r\n    if (\r\n      slideGroupCount % groupsToScroll !== 0 &&\r\n      currentSlideGroupIndex + groupsToScroll > slideGroupCount\r\n    ) {\r\n      slidesToOffset = -(currentSlideGroupIndex > slideGroupCount\r\n        ? groupsToShow - (currentSlideGroupIndex - slideGroupCount)\r\n        : slideGroupCount % groupsToScroll)\r\n    }\r\n    // in center mode, shift current slide group to the center of the frame\r\n    if (centerMode) {\r\n      slidesToOffset += Math.floor(groupsToShow / 2)\r\n    }\r\n  } else {\r\n    if (\r\n      slideGroupCount % groupsToScroll !== 0 &&\r\n      currentSlideGroupIndex + groupsToScroll > slideGroupCount\r\n    ) {\r\n      slidesToOffset = groupsToShow - (slideGroupCount % groupsToScroll)\r\n    }\r\n    if (centerMode) {\r\n      slidesToOffset = Math.floor(groupsToShow / 2)\r\n    }\r\n  }\r\n  slideGroupOffset = slidesToOffset * parseInt(`${slideGroupWidth}`)\r\n  verticalOffset = slidesToOffset * parseInt(`${slideGroupHeight}`)\r\n\r\n  if (!vertical) {\r\n    targetLeft =\r\n      currentSlideGroupIndex * parseInt(`${slideGroupWidth}`) * -1 +\r\n      slideGroupOffset\r\n  } else {\r\n    targetLeft =\r\n      currentSlideGroupIndex * parseInt(`${slideGroupHeight}`) * -1 +\r\n      verticalOffset\r\n  }\r\n\r\n  if (variableWidth === true) {\r\n    let targetSlideIndex\r\n    targetSlideIndex = currentSlideGroupIndex + getTotalPreClones(spec)\r\n    targetSlide =\r\n      trackEl && (trackEl.childNodes[targetSlideIndex] as HTMLElement)\r\n    targetLeft = targetSlide ? targetSlide.offsetLeft * -1 : 0\r\n    if (centerMode === true) {\r\n      targetSlideIndex = infinite\r\n        ? currentSlideGroupIndex + getTotalPreClones(spec)\r\n        : currentSlideGroupIndex\r\n      targetSlide =\r\n        trackEl && (trackEl.children[targetSlideIndex] as HTMLElement)\r\n      targetLeft = 0\r\n      for (let slide = 0; slide < targetSlideIndex; slide++) {\r\n        targetLeft -=\r\n          trackEl &&\r\n          trackEl.children[slide] &&\r\n          (trackEl.children[slide] as HTMLElement).offsetWidth\r\n      }\r\n      targetLeft -= parseInt(centerPadding)\r\n      targetLeft += targetSlide && (listWidth - targetSlide.offsetWidth) / 2\r\n    }\r\n  }\r\n\r\n  if (rtl) targetLeft = -targetLeft\r\n\r\n  return targetLeft\r\n}\r\n\r\nexport const canGoPrev = (spec: GoPrevSpec) => {\r\n  return (\r\n    spec.infinite ||\r\n    (spec.currentSlideGroupIndex !== 0 &&\r\n      spec.slideGroupCount > spec.groupsToShow)\r\n  )\r\n}\r\n\r\nexport const canGoNext = (spec: GoNextSpec) => {\r\n  let canGo = true\r\n  if (!spec.infinite) {\r\n    if (spec.centerMode) {\r\n      canGo = spec.currentSlideGroupIndex < spec.slideGroupCount - 1\r\n    } else if (\r\n      spec.slideGroupCount <= spec.groupsToShow ||\r\n      spec.currentSlideGroupIndex >= spec.slideGroupCount - spec.groupsToShow\r\n    ) {\r\n      canGo = false\r\n    }\r\n  }\r\n  return canGo\r\n}\r\n\r\nexport const getStatesOnSlide = (spec: OnSlideSpec) => {\r\n  let {\r\n    waitForAnimate,\r\n    animating,\r\n    fade,\r\n    infinite,\r\n    index,\r\n    slideGroupCount,\r\n    lazyLoadedList,\r\n    lazyLoad,\r\n    currentSlideGroupIndex,\r\n    centerMode,\r\n    groupsToScroll,\r\n    groupsToShow,\r\n    useCSSTransitions\r\n  } = spec\r\n  if (\r\n    (waitForAnimate && animating) ||\r\n    (fade && !infinite && (index < 0 || index >= slideGroupCount))\r\n  )\r\n    return\r\n  let animationSlideGroupIndex = index,\r\n    finalSlideGroupIndex\r\n  let slidingState: Partial<SliderState> = {},\r\n    afterSlidingState: Partial<SliderState> = {}\r\n  if (fade) {\r\n    if (index < 0) {\r\n      animationSlideGroupIndex += slideGroupCount\r\n    } else if (index >= slideGroupCount) {\r\n      animationSlideGroupIndex -= slideGroupCount\r\n    }\r\n    if (lazyLoad && lazyLoadedList.indexOf(animationSlideGroupIndex) < 0) {\r\n      lazyLoadedList.push(animationSlideGroupIndex)\r\n    }\r\n    slidingState = {\r\n      animating: true,\r\n      currentSlideGroupIndex: animationSlideGroupIndex,\r\n      lazyLoadedList\r\n    }\r\n    afterSlidingState = { animating: false }\r\n    return {\r\n      slidingState,\r\n      afterSlidingState\r\n    }\r\n  }\r\n  finalSlideGroupIndex = animationSlideGroupIndex\r\n  if (animationSlideGroupIndex < 0) {\r\n    finalSlideGroupIndex = animationSlideGroupIndex + slideGroupCount\r\n    if (!infinite) finalSlideGroupIndex = 0\r\n    else if (slideGroupCount % groupsToScroll !== 0)\r\n      finalSlideGroupIndex =\r\n        slideGroupCount - (slideGroupCount % groupsToScroll)\r\n  } else if (\r\n    !canGoNext(spec) &&\r\n    animationSlideGroupIndex > currentSlideGroupIndex\r\n  ) {\r\n    animationSlideGroupIndex = finalSlideGroupIndex = currentSlideGroupIndex\r\n  } else if (centerMode && animationSlideGroupIndex >= slideGroupCount) {\r\n    animationSlideGroupIndex = infinite ? slideGroupCount : slideGroupCount - 1\r\n    finalSlideGroupIndex = infinite ? 0 : slideGroupCount - 1\r\n  } else if (animationSlideGroupIndex >= slideGroupCount) {\r\n    finalSlideGroupIndex = animationSlideGroupIndex - slideGroupCount\r\n    if (!infinite) finalSlideGroupIndex = slideGroupCount - groupsToShow\r\n    else if (slideGroupCount % groupsToScroll !== 0) finalSlideGroupIndex = 0\r\n  }\r\n  let finalLeft = getTrackLeft({\r\n    ...spec,\r\n    currentSlideGroupIndex: finalSlideGroupIndex\r\n  })\r\n  let animationLeft = getTrackLeft({\r\n    ...spec,\r\n    currentSlideGroupIndex: animationSlideGroupIndex\r\n  })\r\n  if (!infinite) {\r\n    if (animationLeft === finalLeft)\r\n      animationSlideGroupIndex = finalSlideGroupIndex\r\n    animationLeft = finalLeft\r\n  }\r\n  if (lazyLoad)\r\n    lazyLoadedList = lazyLoadedList.concat(\r\n      getOnDemandLazySlideGroups({\r\n        ...spec,\r\n        currentSlideGroupIndex: animationSlideGroupIndex\r\n      })\r\n    )\r\n  if (!useCSSTransitions) {\r\n    slidingState = {\r\n      currentSlideGroupIndex: finalSlideGroupIndex,\r\n      trackStyle: getTrackCSS(spec, finalLeft),\r\n      lazyLoadedList\r\n    }\r\n    return {\r\n      slidingState,\r\n      afterSlidingState\r\n    }\r\n  }\r\n  slidingState = {\r\n    animating: true,\r\n    currentSlideGroupIndex: finalSlideGroupIndex,\r\n    trackStyle: getTrackAnimateCSS(spec, animationLeft),\r\n    lazyLoadedList\r\n  }\r\n  afterSlidingState = {\r\n    animating: false,\r\n    currentSlideGroupIndex: finalSlideGroupIndex,\r\n    trackStyle: getTrackCSS(spec, finalLeft),\r\n    swipeLeft: undefined\r\n  }\r\n  return { slidingState, afterSlidingState }\r\n}\r\n\r\nexport function getTotalPreClones(spec: CloneInfoSpec) {\r\n  if (!spec.infinite) {\r\n    return 0\r\n  }\r\n  if (spec.variableWidth) {\r\n    return spec.slideGroupCount\r\n  }\r\n  return spec.groupsToShow + (spec.centerMode ? 1 : 0)\r\n}\r\n\r\nexport function getTotalPostClones(spec: CloneInfoSpec) {\r\n  if (!spec.infinite) {\r\n    return 0\r\n  }\r\n  return spec.slideGroupCount\r\n}\r\n\r\nexport const getSwipeMoveState = (\r\n  e: SwipeEvent,\r\n  spec: SwipeMoveSpec\r\n): SwipeMoveState | undefined => {\r\n  const {\r\n    scrolling,\r\n    animating,\r\n    vertical,\r\n    swipeToSlide,\r\n    verticalSwiping,\r\n    rtl,\r\n    currentSlideGroupIndex,\r\n    edgeFriction,\r\n    edgeDragged,\r\n    onEdge,\r\n    swiped,\r\n    swiping,\r\n    slideGroupCount,\r\n    groupsToScroll,\r\n    infinite,\r\n    touchObject,\r\n    swipeEvent,\r\n    listHeight,\r\n    listWidth\r\n  } = spec\r\n  if (scrolling) return\r\n  if (animating) {\r\n    e.preventDefault()\r\n    return\r\n  }\r\n  if (vertical && swipeToSlide && verticalSwiping) e.preventDefault()\r\n  let swipeLeft,\r\n    state: SwipeMoveState = {}\r\n  let curLeft = getTrackLeft(spec)\r\n  touchObject.curX =\r\n    window.TouchEvent && e instanceof TouchEvent\r\n      ? e.touches[0].pageX\r\n      : (e as MouseEvent).clientX\r\n  touchObject.curY =\r\n    window.TouchEvent && e instanceof TouchEvent\r\n      ? e.touches[0].pageY\r\n      : (e as MouseEvent).clientY\r\n  touchObject.swipeLength = Math.round(\r\n    Math.sqrt(Math.pow(touchObject.curX - touchObject.startX, 2))\r\n  )\r\n  let verticalSwipeLength = Math.round(\r\n    Math.sqrt(Math.pow(touchObject.curY - touchObject.startY, 2))\r\n  )\r\n  if (!verticalSwiping && !swiping && verticalSwipeLength > 10) {\r\n    return { scrolling: true }\r\n  }\r\n  if (verticalSwiping) touchObject.swipeLength = verticalSwipeLength\r\n  let positionOffset =\r\n    (!rtl ? 1 : -1) * (touchObject.curX > touchObject.startX ? 1 : -1)\r\n  if (verticalSwiping)\r\n    positionOffset = touchObject.curY > touchObject.startY ? 1 : -1\r\n\r\n  let dotCount = Math.ceil(slideGroupCount / groupsToScroll)\r\n  let swipeDirection = getSwipeDirection(spec.touchObject, verticalSwiping)\r\n  let touchSwipeLength = touchObject.swipeLength\r\n  if (!infinite) {\r\n    if (\r\n      (currentSlideGroupIndex === 0 && swipeDirection === 'right') ||\r\n      (currentSlideGroupIndex + 1 >= dotCount && swipeDirection === 'left') ||\r\n      (!canGoNext(spec) && swipeDirection === 'left')\r\n    ) {\r\n      touchSwipeLength = Math.round(touchObject.swipeLength * edgeFriction)\r\n      if (edgeDragged === false && onEdge) {\r\n        onEdge(swipeDirection)\r\n        state.edgeDragged = true\r\n      }\r\n    }\r\n  }\r\n  if (!swiped && swipeEvent) {\r\n    swipeEvent(swipeDirection)\r\n    state.swiped = true\r\n  }\r\n  if (!vertical) {\r\n    if (!rtl) {\r\n      swipeLeft = curLeft + touchSwipeLength * positionOffset\r\n    } else {\r\n      swipeLeft = curLeft - touchSwipeLength * positionOffset\r\n    }\r\n  } else {\r\n    swipeLeft =\r\n      curLeft + touchSwipeLength * (listHeight / listWidth) * positionOffset\r\n  }\r\n  if (verticalSwiping) {\r\n    swipeLeft = curLeft + touchSwipeLength * positionOffset\r\n  }\r\n  state = {\r\n    ...state,\r\n    touchObject,\r\n    swipeLeft,\r\n    trackStyle: getTrackCSS(spec, swipeLeft)\r\n  }\r\n  if (\r\n    Math.abs(touchObject.curX - touchObject.startX) <\r\n    Math.abs(touchObject.curY - touchObject.startY) * 0.8\r\n  ) {\r\n    return state\r\n  }\r\n  if (touchObject.swipeLength > 10) {\r\n    state.swiping = true\r\n    e.preventDefault()\r\n  }\r\n  return state\r\n}\r\n\r\nexport function getSlideGroupCount(slideCount: number, groupsToShow: number) {\r\n  return Math.ceil(slideCount / groupsToShow)\r\n}\r\n\r\nexport function getSliderState(spec: SliderStateInfoSpec) {\r\n  let slideGroupCount = getSlideGroupCount(\r\n    spec.slides.length,\r\n    spec.groupsToShow\r\n  )\r\n  let listWidth = Math.ceil(spec.listEl?.offsetWidth || 0)\r\n  let trackWidth = Math.ceil(spec.trackEl?.offsetWidth || 0)\r\n  let slideGroupWidth\r\n  if (!spec.vertical) {\r\n    let centerPaddingAdj = spec.centerMode\r\n      ? parseInt(spec.centerPadding) * 2\r\n      : 0\r\n    if (\r\n      typeof spec.centerPadding === 'string' &&\r\n      spec.centerPadding.slice(-1) === '%'\r\n    ) {\r\n      centerPaddingAdj *= listWidth / 100\r\n    }\r\n    slideGroupWidth = Math.ceil(\r\n      (listWidth - centerPaddingAdj) / spec.groupsToShow\r\n    )\r\n  } else {\r\n    slideGroupWidth = listWidth\r\n  }\r\n  let slideGroupHeight =\r\n    spec.listEl && spec.listEl.querySelector('[data-index=\"0\"]')\r\n      ? spec.listEl.querySelector<HTMLElement>('[data-index=\"0\"]')\r\n          ?.offsetHeight || 0\r\n      : 0\r\n  let listHeight = slideGroupHeight * spec.groupsToShow\r\n  let currentSlideGroupIndex =\r\n    spec.currentSlideGroupIndex === undefined\r\n      ? spec.initialGroupIndex\r\n      : spec.currentSlideGroupIndex\r\n  if (spec.rtl && spec.currentSlideGroupIndex === undefined) {\r\n    currentSlideGroupIndex = slideGroupCount - 1 - spec.initialGroupIndex\r\n  }\r\n  let lazyLoadedList = spec.lazyLoadedList || []\r\n  let slideGroupsToLoad = getOnDemandLazySlideGroups(spec as LazyInfoSpec)\r\n  lazyLoadedList.concat(slideGroupsToLoad)\r\n\r\n  let sliderState: MarkRequiredWithPartialBase<\r\n    SliderState,\r\n    | 'currentSlideGroupIndex'\r\n    | 'listWidth'\r\n    | 'slideGroupHeight'\r\n    | 'slideGroupWidth'\r\n  > & { slideGroupCount: number } = {\r\n    slideGroupCount,\r\n    slideGroupWidth,\r\n    listWidth,\r\n    trackWidth,\r\n    currentSlideGroupIndex,\r\n    slideGroupHeight,\r\n    listHeight,\r\n    lazyLoadedList\r\n  }\r\n\r\n  if (spec.autoplaying === null && spec.autoplay) {\r\n    sliderState.autoplaying = PlayingType.playing\r\n  }\r\n\r\n  return sliderState\r\n}\r\n","export * from './carousel-utils'\r\n\r\nexport const canUseDOM = () =>\r\n  !!(\r\n    typeof window !== 'undefined' &&\r\n    window.document &&\r\n    window.document.createElement\r\n  )\r\n\r\nexport const filterUndefined = <T extends object>(props: T) =>\r\n  Object.keys(props)\r\n    .filter((key) => props[key as keyof T] !== undefined)\r\n    .reduce((acc, key) => {\r\n      acc[key as keyof T] = props[key as keyof T]\r\n      return acc\r\n    }, {} as T)\r\n\r\nexport function clearSelection() {\r\n  if (!window.getSelection) return\r\n  if (window.getSelection()?.empty) {\r\n    window.getSelection()!.empty()\r\n  } else if (window.getSelection()?.removeAllRanges) {\r\n    window.getSelection()!.removeAllRanges()\r\n  }\r\n}\r\n","import { PropType, VNode } from 'vue'\r\nimport {\r\n  ArrowProps,\r\n  DotsProps,\r\n  Props,\r\n  Responsive,\r\n  SlideNavigation,\r\n  SliderState,\r\n  TrackProps,\r\n  WidthDetection\r\n} from '../types'\r\n\r\ntype VuePropDef<T extends string> = Record<\r\n  T,\r\n  { type: PropType<unknown>; default: unknown }\r\n>\r\n\r\nconst makeDefaultProps = (selectFields?: string[]) => {\r\n  const defaultProps = {\r\n    accessibility: { type: Boolean, default: true },\r\n    adaptiveHeight: { type: Boolean, default: false },\r\n    arrows: { type: Boolean, default: true },\r\n    asNavFor: {\r\n      type: Object,\r\n      default: null\r\n    },\r\n    autoplay: { type: Boolean, default: false },\r\n    autoplaySpeed: { type: Number, default: 3000 },\r\n    centerMode: { type: Boolean, default: false },\r\n    centerPadding: { type: String, default: '50px' },\r\n    cssEase: { type: String, default: 'ease' },\r\n    dots: { type: Boolean, default: false },\r\n    dotsClass: { type: String, default: 'v-slick-dots' },\r\n    draggable: { type: Boolean, default: true },\r\n    edgeFriction: { type: Number, default: 0.35 },\r\n    fade: { type: Boolean, default: false },\r\n    focusOnSelect: { type: Boolean, default: false },\r\n    ignorePrefersReducedMotion: { type: Boolean, default: false },\r\n    infinite: { type: Boolean, default: true },\r\n    initialGroupIndex: { type: Number, default: 0 },\r\n    lazyLoad: { type: String, default: null },\r\n    nextArrowLabel: { type: String, default: 'Next' },\r\n    pauseOnDotsHover: { type: Boolean, default: false },\r\n    pauseOnFocus: { type: Boolean, default: false },\r\n    pauseOnHover: { type: Boolean, default: true },\r\n    prevArrowLabel: { type: String, default: 'Previous' },\r\n    responsive: { type: Array as PropType<Responsive[]>, default: [] },\r\n    rtl: { type: Boolean, default: false },\r\n    slidesPerGroup: { type: Number, default: 1 },\r\n    groupsToScroll: { type: Number, default: 1 },\r\n    groupsToShow: { type: Number, default: 1 },\r\n    speed: { type: Number, default: 500 },\r\n    swipe: { type: Boolean, default: true },\r\n    swipeToSlide: { type: Boolean, default: false },\r\n    touchMove: { type: Boolean, default: true },\r\n    touchThreshold: { type: Number, default: 5 },\r\n    useCSSTransitions: { type: Boolean, default: true },\r\n    useCSSTransform: { type: Boolean, default: true },\r\n    variableWidth: { type: Boolean, default: false },\r\n    vertical: { type: Boolean, default: false },\r\n    verticalSwiping: { type: Boolean, default: false },\r\n    waitForAnimate: { type: Boolean, default: true },\r\n    widthDetection: { type: String, default: WidthDetection.auto }\r\n  } satisfies VuePropDef<keyof Props>\r\n  if (!selectFields) return defaultProps\r\n  return Object.keys(defaultProps).reduce<{\r\n    [key: string]: { type: PropType<unknown>; default: unknown }\r\n  }>((acc, key) => {\r\n    if (selectFields.includes(key)) {\r\n      acc[key as keyof Props] = (defaultProps as any)[key]\r\n    }\r\n    return acc\r\n  }, {}) as typeof defaultProps\r\n}\r\n\r\nexport const defaultProps = makeDefaultProps() satisfies VuePropDef<keyof Props>\r\n\r\nexport const defaultPropValues = Object.keys(defaultProps).reduce<{\r\n  [key: string]: unknown\r\n}>((acc, key) => {\r\n  acc[key] = (defaultProps as any)[key].default\r\n  return acc\r\n}, {}) as {\r\n  [K in keyof Props]: unknown\r\n} as Props\r\n\r\nexport const makeDefaultSliderState: () => SliderState = () => ({\r\n  animating: false,\r\n  autoplaying: null,\r\n  autoplayTimer: null,\r\n  currentDirection: 0,\r\n  currentLeft: null,\r\n  currentSlideGroupIndex: 0,\r\n  detectingWidth: false,\r\n  direction: 1,\r\n  dragging: false,\r\n  edgeDragged: false,\r\n  initialized: false,\r\n  lazyLoadedList: [],\r\n  listHeight: undefined,\r\n  listWidth: undefined,\r\n  scrolling: false,\r\n  slideGroupHeight: undefined,\r\n  slideGroupWidth: undefined,\r\n  swipeLeft: undefined,\r\n  swiped: false,\r\n  swiping: false,\r\n  touchObject: { startX: 0, startY: 0, curX: 0, curY: 0, swipeLength: 0 },\r\n  trackStyle: {},\r\n  trackWidth: 0\r\n})\r\n\r\nexport const defaultTrackProps = {\r\n  ...makeDefaultProps([\r\n    'centerMode',\r\n    'centerPadding',\r\n    'cssEase',\r\n    'fade',\r\n    'ignorePrefersReducedMotion',\r\n    'infinite',\r\n    'lazyLoad',\r\n    'rtl',\r\n    'groupsToScroll',\r\n    'groupsToShow',\r\n    'speed',\r\n    'variableWidth',\r\n    'vertical'\r\n  ]),\r\n  ...{\r\n    currentSlideGroupIndex: { type: Number, default: 0 },\r\n    detectingWidth: { type: Boolean, default: false },\r\n    lazyLoadedList: {\r\n      type: Array as PropType<number[]>,\r\n      default: []\r\n    },\r\n    listHeight: { type: Number, default: undefined },\r\n    trackStyle: { type: Object, default: {} },\r\n    slideGroupCount: { type: Number, default: 0 },\r\n    rawSlideGroups: { type: Array as PropType<VNode[][]>, default: [] },\r\n    slideGroupHeight: { type: [String, Number], default: undefined },\r\n    slideGroupWidth: { type: [String, Number], default: undefined }\r\n  }\r\n} satisfies VuePropDef<keyof TrackProps>\r\n\r\nexport const defaultArrowProps = {\r\n  ...makeDefaultProps([\r\n    'centerMode',\r\n    'infinite',\r\n    'groupsToShow',\r\n    'prevArrowLabel',\r\n    'nextArrowLabel'\r\n  ]),\r\n  ...{\r\n    currentSlideGroupIndex: { type: Number, default: 0 },\r\n    disabled: { type: Boolean, default: false },\r\n    slideGroupCount: { type: Number, default: 0 },\r\n    type: { type: String as PropType<SlideNavigation>, default: 'prev' }\r\n  }\r\n} satisfies VuePropDef<keyof ArrowProps>\r\n\r\nexport const defaultDotsProps = {\r\n  ...makeDefaultProps([\r\n    'dotsClass',\r\n    'infinite',\r\n    'groupsToScroll',\r\n    'groupsToShow'\r\n  ]),\r\n  ...{\r\n    currentSlideGroupIndex: { type: Number, default: 0 },\r\n    slideGroupCount: { type: Number, default: 0 },\r\n    pageCount: { type: Number, default: 0 }\r\n  }\r\n} satisfies VuePropDef<keyof DotsProps>\r\n","/**\r\n * Delegate to handle a media query being matched and unmatched.\r\n *\r\n * @param {object} options\r\n * @param {function} options.match callback for when the media query is matched\r\n * @param {function} [options.unmatch] callback for when the media query is unmatched\r\n * @param {function} [options.setup] one-time callback triggered the first time a query is matched\r\n * @param {boolean} [options.deferSetup=false] should the setup callback be run immediately, rather than first time query is matched?\r\n * @constructor\r\n */\r\nfunction QueryHandler(options) {\r\n    this.options = options;\r\n    !options.deferSetup && this.setup();\r\n}\r\n\r\nQueryHandler.prototype = {\r\n\r\n    constructor : QueryHandler,\r\n\r\n    /**\r\n     * coordinates setup of the handler\r\n     *\r\n     * @function\r\n     */\r\n    setup : function() {\r\n        if(this.options.setup) {\r\n            this.options.setup();\r\n        }\r\n        this.initialised = true;\r\n    },\r\n\r\n    /**\r\n     * coordinates setup and triggering of the handler\r\n     *\r\n     * @function\r\n     */\r\n    on : function() {\r\n        !this.initialised && this.setup();\r\n        this.options.match && this.options.match();\r\n    },\r\n\r\n    /**\r\n     * coordinates the unmatch event for the handler\r\n     *\r\n     * @function\r\n     */\r\n    off : function() {\r\n        this.options.unmatch && this.options.unmatch();\r\n    },\r\n\r\n    /**\r\n     * called when a handler is to be destroyed.\r\n     * delegates to the destroy or unmatch callbacks, depending on availability.\r\n     *\r\n     * @function\r\n     */\r\n    destroy : function() {\r\n        this.options.destroy ? this.options.destroy() : this.off();\r\n    },\r\n\r\n    /**\r\n     * determines equality by reference.\r\n     * if object is supplied compare options, if function, compare match callback\r\n     *\r\n     * @function\r\n     * @param {object || function} [target] the target for comparison\r\n     */\r\n    equals : function(target) {\r\n        return this.options === target || this.options.match === target;\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = QueryHandler;\r\n","/**\r\n * Helper function for iterating over a collection\r\n *\r\n * @param collection\r\n * @param fn\r\n */\r\nfunction each(collection, fn) {\r\n    var i      = 0,\r\n        length = collection.length,\r\n        cont;\r\n\r\n    for(i; i < length; i++) {\r\n        cont = fn(collection[i], i);\r\n        if(cont === false) {\r\n            break; //allow early exit\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Helper function for determining whether target object is an array\r\n *\r\n * @param target the object under test\r\n * @return {Boolean} true if array, false otherwise\r\n */\r\nfunction isArray(target) {\r\n    return Object.prototype.toString.apply(target) === '[object Array]';\r\n}\r\n\r\n/**\r\n * Helper function for determining whether target object is a function\r\n *\r\n * @param target the object under test\r\n * @return {Boolean} true if function, false otherwise\r\n */\r\nfunction isFunction(target) {\r\n    return typeof target === 'function';\r\n}\r\n\r\nmodule.exports = {\r\n    isFunction : isFunction,\r\n    isArray : isArray,\r\n    each : each\r\n};\r\n","var QueryHandler = require('./QueryHandler');\r\nvar each = require('./Util').each;\r\n\r\n/**\r\n * Represents a single media query, manages it's state and registered handlers for this query\r\n *\r\n * @constructor\r\n * @param {string} query the media query string\r\n * @param {boolean} [isUnconditional=false] whether the media query should run regardless of whether the conditions are met. Primarily for helping older browsers deal with mobile-first design\r\n */\r\nfunction MediaQuery(query, isUnconditional) {\r\n    this.query = query;\r\n    this.isUnconditional = isUnconditional;\r\n    this.handlers = [];\r\n    this.mql = window?.matchMedia(query);\r\n\r\n    var self = this;\r\n    this.listener = function(mql) {\r\n        // Chrome passes an MediaQueryListEvent object, while other browsers pass MediaQueryList directly\r\n        self.mql = mql.currentTarget || mql;\r\n        self.assess();\r\n    };\r\n    this.mql.addListener(this.listener);\r\n}\r\n\r\nMediaQuery.prototype = {\r\n\r\n    constuctor : MediaQuery,\r\n\r\n    /**\r\n     * add a handler for this query, triggering if already active\r\n     *\r\n     * @param {object} handler\r\n     * @param {function} handler.match callback for when query is activated\r\n     * @param {function} [handler.unmatch] callback for when query is deactivated\r\n     * @param {function} [handler.setup] callback for immediate execution when a query handler is registered\r\n     * @param {boolean} [handler.deferSetup=false] should the setup callback be deferred until the first time the handler is matched?\r\n     */\r\n    addHandler : function(handler) {\r\n        var qh = new QueryHandler(handler);\r\n        this.handlers.push(qh);\r\n\r\n        this.matches() && qh.on();\r\n    },\r\n\r\n    /**\r\n     * removes the given handler from the collection, and calls it's destroy methods\r\n     *\r\n     * @param {object || function} handler the handler to remove\r\n     */\r\n    removeHandler : function(handler) {\r\n        var handlers = this.handlers;\r\n        each(handlers, function(h, i) {\r\n            if(h.equals(handler)) {\r\n                h.destroy();\r\n                return !handlers.splice(i,1); //remove from array and exit each early\r\n            }\r\n        });\r\n    },\r\n\r\n    /**\r\n     * Determine whether the media query should be considered a match\r\n     *\r\n     * @return {Boolean} true if media query can be considered a match, false otherwise\r\n     */\r\n    matches : function() {\r\n        return this.mql.matches || this.isUnconditional;\r\n    },\r\n\r\n    /**\r\n     * Clears all handlers and unbinds events\r\n     */\r\n    clear : function() {\r\n        each(this.handlers, function(handler) {\r\n            handler.destroy();\r\n        });\r\n        this.mql.removeListener(this.listener);\r\n        this.handlers.length = 0; //clear array\r\n    },\r\n\r\n    /*\r\n        * Assesses the query, turning on all handlers if it matches, turning them off if it doesn't match\r\n        */\r\n    assess : function() {\r\n        var action = this.matches() ? 'on' : 'off';\r\n\r\n        each(this.handlers, function(handler) {\r\n            handler[action]();\r\n        });\r\n    }\r\n};\r\n\r\nmodule.exports = MediaQuery;\r\n","var MediaQuery = require('./MediaQuery');\r\nvar Util = require('./Util');\r\nvar each = Util.each;\r\nvar isFunction = Util.isFunction;\r\nvar isArray = Util.isArray;\r\n\r\n/**\r\n * Allows for registration of query handlers.\r\n * Manages the query handler's state and is responsible for wiring up browser events\r\n *\r\n * @constructor\r\n */\r\nfunction MediaQueryDispatch () {\r\n    if(typeof window !== 'undefined' && !window.matchMedia) {\r\n        throw new Error('matchMedia not present, legacy browsers require a polyfill');\r\n    }\r\n\r\n    this.queries = {};\r\n    if (typeof window !== 'undefined') {\r\n        this.browserIsIncapable = !window.matchMedia('only all').matches;\r\n    }\r\n}\r\n\r\nMediaQueryDispatch.prototype = {\r\n\r\n    constructor : MediaQueryDispatch,\r\n\r\n    /**\r\n     * Registers a handler for the given media query\r\n     *\r\n     * @param {string} q the media query\r\n     * @param {object || Array || Function} options either a single query handler object, a function, or an array of query handlers\r\n     * @param {function} options.match fired when query matched\r\n     * @param {function} [options.unmatch] fired when a query is no longer matched\r\n     * @param {function} [options.setup] fired when handler first triggered\r\n     * @param {boolean} [options.deferSetup=false] whether setup should be run immediately or deferred until query is first matched\r\n     * @param {boolean} [shouldDegrade=false] whether this particular media query should always run on incapable browsers\r\n     */\r\n    register : function(q, options, shouldDegrade) {\r\n        var queries         = this.queries,\r\n            isUnconditional = shouldDegrade && this.browserIsIncapable;\r\n\r\n        if(!queries[q]) {\r\n            queries[q] = new MediaQuery(q, isUnconditional);\r\n        }\r\n\r\n        //normalise to object in an array\r\n        if(isFunction(options)) {\r\n            options = { match : options };\r\n        }\r\n        if(!isArray(options)) {\r\n            options = [options];\r\n        }\r\n        each(options, function(handler) {\r\n            if (isFunction(handler)) {\r\n                handler = { match : handler };\r\n            }\r\n            queries[q].addHandler(handler);\r\n        });\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * unregisters a query and all it's handlers, or a specific handler for a query\r\n     *\r\n     * @param {string} q the media query to target\r\n     * @param {object || function} [handler] specific handler to unregister\r\n     */\r\n    unregister : function(q, handler) {\r\n        var query = this.queries[q];\r\n\r\n        if(query) {\r\n            if(handler) {\r\n                query.removeHandler(handler);\r\n            }\r\n            else {\r\n                query.clear();\r\n                delete this.queries[q];\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n};\r\n\r\nmodule.exports = MediaQueryDispatch;\r\n","var MediaQueryDispatch = require('./MediaQueryDispatch');\r\nmodule.exports = new MediaQueryDispatch();\r\n","var camel2hyphen = function (str) {\n  return str\n          .replace(/[A-Z]/g, function (match) {\n            return '-' + match.toLowerCase();\n          })\n          .toLowerCase();\n};\n\nmodule.exports = camel2hyphen;","var camel2hyphen = require('string-convert/camel2hyphen');\n\nvar isDimension = function (feature) {\n  var re = /[height|width]$/;\n  return re.test(feature);\n};\n\nvar obj2mq = function (obj) {\n  var mq = '';\n  var features = Object.keys(obj);\n  features.forEach(function (feature, index) {\n    var value = obj[feature];\n    feature = camel2hyphen(feature);\n    // Add px to dimension features\n    if (isDimension(feature) && typeof value === 'number') {\n      value = value + 'px';\n    }\n    if (value === true) {\n      mq += feature;\n    } else if (value === false) {\n      mq += 'not ' + feature;\n    } else {\n      mq += '(' + feature + ': ' + value + ')';\n    }\n    if (index < features.length-1) {\n      mq += ' and '\n    }\n  });\n  return mq;\n};\n\nvar json2mq = function (query) {\n  var mq = '';\n  if (typeof query === 'string') {\n    return query;\n  }\n  // Handling array of media queries\n  if (query instanceof Array) {\n    query.forEach(function (q, index) {\n      mq += obj2mq(q);\n      if (index < query.length-1) {\n        mq += ', '\n      }\n    });\n    return mq;\n  }\n  // Handling single media query\n  return obj2mq(query);\n};\n\nmodule.exports = json2mq;","<template>\r\n  <template v-if=\"type === SlideNavigation.previous\">\r\n    <slot name=\"prevArrow\" v-bind=\"arrowSlotProps\">\r\n      <button\r\n        type=\"button\"\r\n        data-role=\"none\"\r\n        class=\"v-slick-arrow prev\"\r\n        :class=\"{ disabled }\"\r\n        @click=\"clickHandler\"\r\n      >\r\n        {{ prevArrowLabel }}\r\n      </button>\r\n    </slot>\r\n  </template>\r\n  <template v-else>\r\n    <slot name=\"nextArrow\" v-bind=\"arrowSlotProps\">\r\n      <button\r\n        type=\"button\"\r\n        data-role=\"none\"\r\n        class=\"v-slick-arrow next\"\r\n        :class=\"{ disabled }\"\r\n        @click=\"clickHandler\"\r\n      >\r\n        {{ nextArrowLabel }}\r\n      </button>\r\n    </slot>\r\n  </template>\r\n</template>\r\n<script setup lang=\"ts\">\r\nimport { ArrowSlotProps, SlideNavigation } from '@lib/types'\r\nimport { computed } from 'vue'\r\nimport { defaultArrowProps } from './props'\r\n\r\nconst props = defineProps(defaultArrowProps)\r\nconst emit = defineEmits([SlideNavigation.previous, SlideNavigation.next])\r\nconst clickHandler = computed(() => () => {\r\n  if (props.disabled) return\r\n  emit(props.type)\r\n})\r\nconst arrowSlotProps = computed<ArrowSlotProps>(() => ({\r\n  currentSlideGroupIndex: props.currentSlideGroupIndex,\r\n  slideGroupCount: props.slideGroupCount,\r\n  onClick: clickHandler.value,\r\n  disabled: !props.disabled\r\n}))\r\n</script>\r\n<style scoped>\r\n.v-slick-arrow {\r\n  display: block;\r\n}\r\n</style>\r\n","<template>\r\n  <div\r\n    class=\"v-slick-track\"\r\n    :class=\"{ center: centerMode, vertical: vertical }\"\r\n    :style=\"[trackStyle, detectingWidth ? { width: '0 !important' } : {}]\"\r\n  >\r\n    <div\r\n      v-for=\"(slideGroup, i) in preCloneSlideGroups\"\r\n      :key=\"slideGroup.key\"\r\n      tabindex=\"-1\"\r\n      :class=\"slideGroup.class\"\r\n      :style=\"slideGroup.style\"\r\n      class=\"v-slick-slide-group clone\"\r\n      v-bind=\"slideGroup.attrs\"\r\n      @click=\"slideGroup.onClick\"\r\n    >\r\n      <component\r\n        :is=\"slide\"\r\n        v-for=\"(slide, j) of slideGroup.slides\"\r\n        :key=\"`slide-${i}-${j}` + (slide.key ? `-${String(slide.key)}` : '')\"\r\n      />\r\n    </div>\r\n    <div\r\n      v-for=\"(slideGroup, i) in originalSlideGroups\"\r\n      :key=\"slideGroup.key\"\r\n      tabindex=\"-1\"\r\n      class=\"v-slick-slide-group\"\r\n      :class=\"slideGroup.class\"\r\n      :style=\"slideGroup.style\"\r\n      v-bind=\"slideGroup.attrs\"\r\n      @click=\"slideGroup.onClick\"\r\n    >\r\n      <component\r\n        :is=\"slide\"\r\n        v-for=\"(slide, j) of slideGroup.slides\"\r\n        :key=\"`slide-${i}-${j}` + (slide.key ? `-${String(slide.key)}` : '')\"\r\n      />\r\n    </div>\r\n    <div\r\n      v-for=\"(slideGroup, i) in postCloneSlideGroups\"\r\n      :key=\"slideGroup.key\"\r\n      tabindex=\"-1\"\r\n      :class=\"slideGroup.class\"\r\n      :style=\"slideGroup.style\"\r\n      class=\"v-slick-slide-group clone\"\r\n      v-bind=\"slideGroup.attrs\"\r\n      @click=\"slideGroup.onClick\"\r\n    >\r\n      <component\r\n        :is=\"slide\"\r\n        v-for=\"(slide, j) of slideGroup.slides\"\r\n        :key=\"`slide-${i}-${j}` + (slide.key ? `-${String(slide.key)}` : '')\"\r\n      />\r\n    </div>\r\n  </div>\r\n</template>\r\n\r\n<script setup lang=\"ts\">\r\nimport { computed } from 'vue'\r\nimport { defaultTrackProps } from './props'\r\nimport {\r\n  ChildClickPayload,\r\n  CloneInfoSpec,\r\n  LazyInfoSpec,\r\n  SlideGroup,\r\n  TrackProps\r\n} from '@lib/types'\r\nimport {\r\n  getLazyEndIndex,\r\n  getLazyStartIndex,\r\n  getTotalPreClones\r\n} from '@lib/utils'\r\n\r\nconst props = defineProps(defaultTrackProps) as TrackProps\r\nconst emit = defineEmits<{\r\n  childClick: [payload: ChildClickPayload]\r\n}>()\r\n\r\nconst getSlideGroupClasses = (index: number) => {\r\n  let isActive = false,\r\n    isCenter = false,\r\n    isCurrent = false,\r\n    centerOffset: number\r\n  if (props.centerMode) {\r\n    centerOffset = Math.floor(props.groupsToShow / 2)\r\n    isCenter =\r\n      (index - props.currentSlideGroupIndex) % props.slideGroupCount === 0\r\n    if (\r\n      index > props.currentSlideGroupIndex - centerOffset - 1 &&\r\n      index <= props.currentSlideGroupIndex + centerOffset\r\n    ) {\r\n      isActive = true\r\n    }\r\n  } else {\r\n    isActive =\r\n      props.currentSlideGroupIndex <= index &&\r\n      index < props.currentSlideGroupIndex + props.groupsToShow\r\n  }\r\n  isCurrent = index === props.currentSlideGroupIndex\r\n  return Object.entries({\r\n    active: isActive,\r\n    center: isCenter,\r\n    current: isCurrent\r\n  })\r\n    .filter(([, value]) => value)\r\n    .map(([key]) => key)\r\n}\r\n\r\nconst getSlideGroupStyle = (index: number) => {\r\n  let style: {\r\n    width?: string\r\n    position?: string\r\n    top?: string\r\n    left?: string\r\n    opacity?: number\r\n    transition?: string\r\n  } = {}\r\n\r\n  if (props.variableWidth === undefined || props.variableWidth === false) {\r\n    style.width =\r\n      typeof props.slideGroupWidth === 'number'\r\n        ? `${props.slideGroupWidth}px`\r\n        : props.slideGroupWidth\r\n  }\r\n\r\n  if (props.fade) {\r\n    style.position = 'relative'\r\n    if (props.vertical) {\r\n      const slideGroupHeight = !props.slideGroupHeight\r\n        ? 0\r\n        : typeof props.slideGroupHeight === 'string'\r\n          ? parseFloat(props.slideGroupHeight)\r\n          : props.slideGroupHeight\r\n      style.top = `${-index * slideGroupHeight}px`\r\n    } else {\r\n      const slideGroupWidth = !props.slideGroupWidth\r\n        ? 0\r\n        : typeof props.slideGroupWidth === 'string'\r\n          ? parseFloat(props.slideGroupWidth)\r\n          : props.slideGroupWidth\r\n\r\n      const left = props.rtl\r\n        ? index * slideGroupWidth\r\n        : -index * slideGroupWidth\r\n      style.left = `${left}px`\r\n    }\r\n    style.opacity = props.currentSlideGroupIndex === index ? 1 : 0\r\n    style.transition =\r\n      'opacity ' +\r\n      props.speed +\r\n      'ms ' +\r\n      props.cssEase +\r\n      ', ' +\r\n      'visibility ' +\r\n      props.speed +\r\n      'ms ' +\r\n      props.cssEase\r\n    if (props.ignorePrefersReducedMotion) {\r\n      style.transition += ' !important'\r\n    }\r\n  }\r\n\r\n  return style\r\n}\r\n\r\nconst originalSlideGroups = computed<SlideGroup[]>(() => {\r\n  const slideGroups = props.rawSlideGroups.map((rawSlideGroup, index) => {\r\n    const style = getSlideGroupStyle(index)\r\n    const classes = getSlideGroupClasses(index)\r\n    if (props.fade && classes.includes('active')) {\r\n      Object.assign(style, { zIndex: 1 })\r\n    }\r\n    const slideGroup: SlideGroup = {\r\n      slides: [],\r\n      key: `original-${index}`,\r\n      class: classes,\r\n      style,\r\n      attrs: {\r\n        'data-index': index,\r\n        'aria-hidden': `${!classes.includes('active')}`\r\n      },\r\n      onClick: () => {\r\n        emit('childClick', {\r\n          index:\r\n            props.rtl && props.infinite ? props.slideGroupCount + index : index\r\n        })\r\n      }\r\n    }\r\n    if (\r\n      !props.lazyLoad ||\r\n      (props.lazyLoad && props.lazyLoadedList.indexOf(index) >= 0)\r\n    ) {\r\n      slideGroup.slides = rawSlideGroup\r\n    }\r\n    return slideGroup\r\n  })\r\n  // return props.rtl ? slideGroups.reverse() : slideGroups\r\n  return slideGroups\r\n})\r\n\r\nconst preCloneSlideGroups = computed<SlideGroup[]>(() => {\r\n  if (\r\n    !props.infinite ||\r\n    props.fade ||\r\n    props.slideGroupCount <= props.groupsToShow\r\n  ) {\r\n    return []\r\n  }\r\n  const slideGroups = props.rawSlideGroups\r\n    .map((rawSlideGroup, index) => {\r\n      const preCloneNo = props.slideGroupCount - index\r\n      if (preCloneNo > getTotalPreClones(props as CloneInfoSpec)) return\r\n      const key = -preCloneNo\r\n      const slideGroup: SlideGroup = {\r\n        slides: [],\r\n        key: `preclone-${key}`,\r\n        class: getSlideGroupClasses(key),\r\n        style: getSlideGroupStyle(index),\r\n        attrs: {\r\n          'data-index': key,\r\n          'aria-hidden': 'true'\r\n        },\r\n        onClick: () => {\r\n          emit('childClick', {\r\n            index: key\r\n          })\r\n        }\r\n      }\r\n      if (\r\n        key >= getLazyStartIndex(props as LazyInfoSpec) ||\r\n        !props.lazyLoad ||\r\n        (props.lazyLoad && props.lazyLoadedList.indexOf(index) >= 0)\r\n      ) {\r\n        slideGroup.slides = rawSlideGroup\r\n      }\r\n      return slideGroup\r\n    })\r\n    .filter((slideGroup) => slideGroup) as SlideGroup[]\r\n  // return props.rtl ? slideGroups.reverse() : slideGroups\r\n  return slideGroups\r\n})\r\n\r\nconst postCloneSlideGroups = computed<SlideGroup[]>(() => {\r\n  if (\r\n    !props.infinite ||\r\n    props.fade ||\r\n    props.slideGroupCount <= props.groupsToShow\r\n  ) {\r\n    return []\r\n  }\r\n  const slideGroups = props.rawSlideGroups.map((rawSlideGroup, index) => {\r\n    const key = props.slideGroupCount + index\r\n    const slideGroup: SlideGroup = {\r\n      slides: [],\r\n      key: `postclone-${key}`,\r\n      class: getSlideGroupClasses(key),\r\n      style: getSlideGroupStyle(index),\r\n      attrs: {\r\n        'data-index': key,\r\n        'aria-hidden':\r\n          props.infinite &&\r\n          props.slideGroupCount - props.currentSlideGroupIndex <\r\n            props.groupsToShow &&\r\n          index <\r\n            props.groupsToShow -\r\n              (props.slideGroupCount - props.currentSlideGroupIndex)\r\n            ? 'false'\r\n            : 'true'\r\n      },\r\n      onClick: () => {\r\n        emit('childClick', {\r\n          index: props.rtl ? props.slideGroupCount + key : key\r\n        })\r\n      }\r\n    }\r\n    if (\r\n      key < getLazyEndIndex(props as LazyInfoSpec) ||\r\n      !props.lazyLoad ||\r\n      (props.lazyLoad && props.lazyLoadedList.indexOf(index) >= 0)\r\n    ) {\r\n      slideGroup.slides = rawSlideGroup\r\n    }\r\n    return slideGroup\r\n  })\r\n  // return props.rtl ? slideGroups.reverse() : slideGroups\r\n  return slideGroups\r\n})\r\n</script>\r\n\r\n<style scoped lang=\"scss\">\r\n.v-slick-track {\r\n  position: relative;\r\n  top: 0;\r\n  left: 0;\r\n  display: flex;\r\n  transform: translate3d(0, 0, 0);\r\n  &.center {\r\n    margin-left: auto;\r\n    margin-right: auto;\r\n  }\r\n  &.vertical {\r\n    flex-direction: column;\r\n    .v-slick-slide-group {\r\n      flex-direction: row;\r\n      height: auto;\r\n      & > * {\r\n        flex-grow: 1;\r\n      }\r\n    }\r\n  }\r\n  &.dragging img {\r\n    pointer-events: none;\r\n  }\r\n}\r\n.v-slick-slide-group {\r\n  display: flex;\r\n  flex-direction: column;\r\n  height: 100%;\r\n  min-height: 1px;\r\n  flex-shrink: 0;\r\n  outline: none;\r\n}\r\n</style>\r\n","<template>\r\n  <ul\r\n    :class=\"dotsClass\"\r\n    style=\"display: block\"\r\n    @mouseenter=\"$emit('dotsLeave')\"\r\n    @mouseleave=\"$emit('dotsLeave')\"\r\n    @mouseover=\"$emit('dotsOver')\"\r\n  >\r\n    <li\r\n      v-for=\"i in pageCount\"\r\n      :key=\"i\"\r\n      :class=\"{ active: isActive(i - 1) }\"\r\n      @click=\"\r\n        $emit('dotClick', {\r\n          index: i - 1,\r\n          groupsToScroll\r\n        })\r\n      \"\r\n    >\r\n      <slot name=\"customPaging\" :page=\"i - 1\">\r\n        <button>{{ i }}</button>\r\n      </slot>\r\n    </li>\r\n  </ul>\r\n</template>\r\n<script setup lang=\"ts\">\r\nimport { DotClickPayload } from '@lib/types'\r\nimport { defaultDotsProps } from './props'\r\ndefineEmits<{\r\n  dotClick: [payload: DotClickPayload]\r\n  dotsOver: []\r\n  dotsLeave: []\r\n}>()\r\nconst props = defineProps(defaultDotsProps)\r\nconst isActive = (i: number) => {\r\n  const leftBound = i * props.groupsToScroll\r\n  const rightBound = leftBound + props.groupsToScroll - 1\r\n  return (\r\n    props.currentSlideGroupIndex >= leftBound &&\r\n    props.currentSlideGroupIndex <= rightBound\r\n  )\r\n}\r\n</script>\r\n","/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        result = wait - timeSinceLastCall;\n\n    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = debounce;\n","<template>\r\n  <div\r\n    ref=\"vSlickCarouselRef\"\r\n    class=\"v-slick-carousel\"\r\n    :style=\"\r\n      widthDetection === WidthDetection.manual\r\n        ? state.detectingWidth\r\n          ? { width: '100%' }\r\n          : vSlickCarouselStyle\r\n        : {}\r\n    \"\r\n  >\r\n    <div class=\"v-slick-slider\" :dir=\"settings.rtl ? 'rtl' : 'ltr'\">\r\n      <VSlickArrow\r\n        v-if=\"settings.arrows\"\r\n        :type=\"SlideNavigation.previous\"\r\n        :center-mode=\"settings.centerMode\"\r\n        :infinite=\"settings.infinite\"\r\n        :groups-to-show=\"settings.groupsToShow\"\r\n        :slide-group-count=\"slideGroupCount\"\r\n        :current-slide-group-index=\"state.currentSlideGroupIndex\"\r\n        :disabled=\"!canGoPrev\"\r\n        @previous=\"handlePrevVSlickArrow\"\r\n      >\r\n        <template #prevArrow=\"arrowSlotProps\">\r\n          <slot name=\"prevArrow\" v-bind=\"arrowSlotProps\" />\r\n        </template>\r\n      </VSlickArrow>\r\n      <div\r\n        ref=\"vSlickListRef\"\r\n        class=\"v-slick-list\"\r\n        :class=\"{ dragging: state.dragging }\"\r\n        :style=\"vSlickListStyle\"\r\n        @click=\"handleClickVSlickList\"\r\n        @mousedown=\"handleMouseDownOrTouchStartVSlickList\"\r\n        @touchstart.passive=\"handleMouseDownOrTouchStartVSlickList\"\r\n        @keydown=\"handleKeyDownVSlickList\"\r\n      >\r\n        <VSlickTrack\r\n          ref=\"vSlickTrackRef\"\r\n          :center-mode=\"settings.centerMode\"\r\n          :center-padding=\"settings.centerPadding\"\r\n          :raw-slide-groups=\"rawSlideGroups\"\r\n          :css-ease=\"cssEase\"\r\n          :current-slide-group-index=\"state.currentSlideGroupIndex\"\r\n          :detecting-width=\"state.detectingWidth\"\r\n          :fade=\"settings.fade\"\r\n          :ignore-prefers-reduced-motion=\"settings.ignorePrefersReducedMotion\"\r\n          :infinite=\"settings.infinite\"\r\n          :lazy-load=\"settings.lazyLoad\"\r\n          :lazy-loaded-list=\"state.lazyLoadedList\"\r\n          :list-height=\"state.listHeight\"\r\n          :rtl=\"settings.rtl\"\r\n          :slide-group-count=\"slideGroupCount\"\r\n          :slide-group-height=\"state.slideGroupHeight\"\r\n          :slide-group-width=\"state.slideGroupWidth\"\r\n          :groups-to-scroll=\"settings.groupsToScroll\"\r\n          :groups-to-show=\"settings.groupsToShow\"\r\n          :speed=\"settings.speed\"\r\n          :track-style=\"state.trackStyle\"\r\n          :variable-width=\"settings.variableWidth\"\r\n          :vertical=\"settings.vertical\"\r\n          @mouseenter=\"handleMouseEnterOrOverVSlickTrack\"\r\n          @mouseleave=\"handleMouseLeaveVSlickTrack\"\r\n          @mouseover=\"handleMouseEnterOrOverVSlickTrack\"\r\n          @child-click=\"handleChildClickVSlickTrack\"\r\n        />\r\n      </div>\r\n      <VSlickArrow\r\n        v-if=\"settings.arrows\"\r\n        :type=\"SlideNavigation.next\"\r\n        :center-mode=\"settings.centerMode\"\r\n        :infinite=\"settings.infinite\"\r\n        :groups-to-show=\"settings.groupsToShow\"\r\n        :slide-group-count=\"slideGroupCount\"\r\n        :current-slide-group-index=\"state.currentSlideGroupIndex\"\r\n        :disabled=\"!canGoNext\"\r\n        @next=\"handleNextVSlickArrow\"\r\n      >\r\n        <template #nextArrow=\"arrowSlotProps\">\r\n          <slot name=\"nextArrow\" v-bind=\"arrowSlotProps\" />\r\n        </template>\r\n      </VSlickArrow>\r\n    </div>\r\n    <VSlickDots\r\n      v-if=\"settings.dots\"\r\n      :current-slide-group-index=\"state.currentSlideGroupIndex\"\r\n      :infinite=\"settings.infinite\"\r\n      :slide-group-count=\"slideGroupCount\"\r\n      :groups-to-scroll=\"settings.groupsToScroll\"\r\n      :groups-to-show=\"settings.groupsToShow\"\r\n      :dots-class=\"settings.dotsClass\"\r\n      :page-count=\"pageCount\"\r\n      @dot-click=\"handleClickDot\"\r\n      @dots-over=\"handleOverDots\"\r\n      @dots-leave=\"handleLeaveDots\"\r\n    >\r\n      <template #customPaging=\"paging\">\r\n        <slot name=\"customPaging\" v-bind=\"paging\" />\r\n      </template>\r\n    </VSlickDots>\r\n  </div>\r\n</template>\r\n\r\n<script setup lang=\"ts\">\r\nimport {\r\n  ref,\r\n  computed,\r\n  watch,\r\n  VNode,\r\n  useSlots,\r\n  getCurrentInstance,\r\n  onMounted,\r\n  onBeforeUnmount,\r\n  onUpdated\r\n} from 'vue'\r\nimport {\r\n  ChildClickPayload,\r\n  DotClickPayload,\r\n  LazyLoadType,\r\n  PlayingType,\r\n  Props,\r\n  SwipeDirection,\r\n  SwipeEndSpec,\r\n  SwipeMoveSpec,\r\n  TrackInfoSpec,\r\n  VSlickCarouselInstance,\r\n  SwipeEvent,\r\n  SlideNavigation,\r\n  SlideGroupChangeOptions,\r\n  SlideGroupChangeSpec,\r\n  OnSlideSpec,\r\n  WidthDetection\r\n} from '@lib/types'\r\nimport {\r\n  canUseDOM,\r\n  clearSelection,\r\n  filterUndefined,\r\n  getChangedSlideGroupIndex\r\n} from '@lib/utils'\r\nimport {\r\n  defaultPropValues,\r\n  defaultProps,\r\n  makeDefaultSliderState\r\n} from './props'\r\nimport enquireJs from '@dcufo/enquire.js'\r\nimport json2mq from 'json2mq'\r\nimport VSlickArrow from './VSlickArrow.vue'\r\nimport VSlickTrack from './VSlickTrack.vue'\r\nimport VSlickDots from './VSlickDots.vue'\r\nimport debounce from 'lodash.debounce'\r\nimport {\r\n  canGoNext as checkCanGoNext,\r\n  canGoPrev as checkCanGoPrev,\r\n  extractSlides,\r\n  getNavigationOnKeyType,\r\n  getOnDemandLazySlideGroups,\r\n  getSlideGroupCount,\r\n  getSliderState,\r\n  getStatesOnSlide,\r\n  getSwipeEndState,\r\n  getSwipeMoveState,\r\n  getSwipeStartState,\r\n  getTotalPostClones,\r\n  getTotalPreClones,\r\n  getTrackCSS,\r\n  getTrackLeft\r\n} from '@lib/utils/carousel-utils'\r\n\r\nconst props = defineProps(defaultProps) as Props\r\ndefineOptions({ inheritAttrs: false })\r\n\r\nconst emit = defineEmits([\r\n  'init',\r\n  'beforeChange',\r\n  'afterChange',\r\n  'lazyLoad',\r\n  'lazyLoadError',\r\n  'reInit',\r\n  'edge',\r\n  'swipe'\r\n])\r\n\r\nconst slots = useSlots()\r\nconst enquire = canUseDOM() ? enquireJs : undefined\r\n\r\nconst DEBOUNCE_RESIZE_DURATION = 50\r\n\r\nlet triggerSlideGroupHandler: number | undefined\r\nlet animationEndCallback: NodeJS.Timeout | null = null\r\nlet lazyLoadTimer: NodeJS.Timeout | null = null\r\nlet callbackTimers: NodeJS.Timeout[] = []\r\n\r\nconst vSlickListStyle = ref({\r\n  ...(getCurrentInstance()?.vnode?.props?.style || {})\r\n})\r\n\r\nlet isVSlickListClickable = true\r\nlet debouncedResize: ReturnType<typeof debounce> | null = null\r\nlet ro: ResizeObserver | null = null\r\n\r\nlet responsiveMediaHandlers: {\r\n  query: string\r\n  handler: () => void\r\n}[] = []\r\n\r\nconst media = (query: string, handler: () => void) => {\r\n  if (!enquire) return\r\n\r\n  enquire.register(query, handler)\r\n  responsiveMediaHandlers.push({ query, handler })\r\n}\r\n\r\nconst clearBreakpoints = () => {\r\n  responsiveMediaHandlers.forEach(({ query, handler }) =>\r\n    enquire?.unregister(query, handler)\r\n  )\r\n  responsiveMediaHandlers = []\r\n}\r\n\r\nconst makeBreakpoints = () => {\r\n  if (!props.responsive.length) return\r\n  const breakpoints = props.responsive.map((item) => item.breakpoint)\r\n  breakpoints.sort((a, b) => a - b)\r\n  breakpoints.forEach((_breakpoint, index) => {\r\n    const mediaQuery = json2mq({\r\n      minWidth: index === 0 ? 0 : breakpoints[index - 1] + 1,\r\n      maxWidth: _breakpoint\r\n    })\r\n    media(mediaQuery, () => {\r\n      breakpoint.value = _breakpoint\r\n    })\r\n  })\r\n  const query = json2mq({\r\n    minWidth: breakpoints.slice(-1)[0]\r\n  })\r\n  media(query, () => {\r\n    breakpoint.value = undefined\r\n  })\r\n}\r\n\r\nconst swipeStart = (e: SwipeEvent) => {\r\n  const swipeStartState = getSwipeStartState(\r\n    e,\r\n    settings.value.swipe,\r\n    settings.value.draggable\r\n  )\r\n  Object.assign(state.value, swipeStartState)\r\n}\r\n\r\nconst swipeEnd = (e: SwipeEvent) => {\r\n  const swipeEndState = getSwipeEndState(e, {\r\n    ...settings.value,\r\n    ...state.value,\r\n    trackEl: vSlickTrackRef.value?.$el,\r\n    listEl: vSlickListRef.value,\r\n    slideGroupIndex: state.value.currentSlideGroupIndex,\r\n    slideGroupCount: slideGroupCount.value\r\n  } as SwipeEndSpec)\r\n  if (!swipeEndState) return\r\n  const { triggerSlideGroupHandler: newTriggerSlideGroupHandler, ...rest } =\r\n    swipeEndState\r\n  triggerSlideGroupHandler = newTriggerSlideGroupHandler\r\n  Object.assign(state.value, rest)\r\n  if (triggerSlideGroupHandler !== undefined) {\r\n    slideGroupHandler(triggerSlideGroupHandler)\r\n  }\r\n}\r\n\r\nconst swipeMove = (e: SwipeEvent) => {\r\n  clearSelection()\r\n  const swipeMoveState = getSwipeMoveState(e, {\r\n    ...props,\r\n    ...state.value,\r\n    trackEl: vSlickTrackRef.value?.$el,\r\n    listEl: vSlickListRef.value,\r\n    slideGroupIndex: state.value.currentSlideGroupIndex,\r\n    slideGroupCount: slideGroupCount.value,\r\n    onEdge: (e: SwipeDirection | keyof typeof SwipeDirection) =>\r\n      emit('edge', e),\r\n    swipeEvent: (e: SwipeDirection | keyof typeof SwipeDirection) =>\r\n      emit('swipe', e)\r\n  } as SwipeMoveSpec)\r\n  if (!swipeMoveState) return\r\n  if (swipeMoveState.swiping) {\r\n    isVSlickListClickable = false\r\n  }\r\n  Object.assign(state.value, swipeMoveState)\r\n}\r\n\r\nconst play = () => {\r\n  let nextIndex\r\n  if (settings.value.rtl) {\r\n    nextIndex =\r\n      state.value.currentSlideGroupIndex - settings.value.groupsToScroll\r\n  } else {\r\n    if (canGoNext.value) {\r\n      nextIndex =\r\n        state.value.currentSlideGroupIndex + settings.value.groupsToScroll\r\n    } else {\r\n      return false\r\n    }\r\n  }\r\n\r\n  slideGroupHandler(nextIndex)\r\n}\r\n\r\nconst pause = (\r\n  pauseType: null | PlayingType | keyof typeof PlayingType = null\r\n) => {\r\n  if (state.value.autoplayTimer) {\r\n    clearInterval(state.value.autoplayTimer)\r\n    state.value.autoplayTimer = null\r\n  }\r\n  const autoplaying = state.value.autoplaying\r\n  if (pauseType === PlayingType.paused) {\r\n    state.value.autoplaying = PlayingType.paused\r\n  } else if (\r\n    pauseType === PlayingType.focused &&\r\n    (autoplaying === PlayingType.hovered || autoplaying === PlayingType.playing)\r\n  ) {\r\n    state.value.autoplaying = PlayingType.focused\r\n  } else if (autoplaying === PlayingType.playing) {\r\n    state.value.autoplaying = PlayingType.hovered\r\n  } else if (autoplaying === null) {\r\n    state.value.autoplaying = null\r\n  }\r\n}\r\n\r\nconst autoPlay = (playType: PlayingType | keyof typeof PlayingType) => {\r\n  if (state.value.autoplayTimer) {\r\n    clearInterval(state.value.autoplayTimer)\r\n  }\r\n  const autoplaying = state.value.autoplaying\r\n  if (playType === PlayingType.update) {\r\n    if (\r\n      autoplaying === PlayingType.hovered ||\r\n      autoplaying === PlayingType.focused ||\r\n      autoplaying === PlayingType.paused\r\n    ) {\r\n      return\r\n    }\r\n  } else if (playType === PlayingType.leave) {\r\n    if (\r\n      autoplaying === PlayingType.paused ||\r\n      autoplaying === PlayingType.focused\r\n    ) {\r\n      return\r\n    }\r\n  } else if (playType === PlayingType.blur) {\r\n    if (\r\n      autoplaying === PlayingType.paused ||\r\n      autoplaying === PlayingType.hovered\r\n    ) {\r\n      return\r\n    }\r\n  }\r\n  state.value.autoplayTimer = setInterval(\r\n    play,\r\n    settings.value.autoplaySpeed + 50\r\n  )\r\n  state.value.autoplaying = PlayingType.playing\r\n}\r\n\r\nconst adaptHeight = () => {\r\n  if (settings.value.adaptiveHeight && vSlickListRef.value) {\r\n    const activeSlideGroups = vSlickListRef.value.querySelectorAll<HTMLElement>(\r\n      '.v-slick-slide-group.active'\r\n    )\r\n    let maxHeight = 0\r\n    activeSlideGroups.forEach((slideGroup) => {\r\n      maxHeight = Math.max(maxHeight, slideGroup.offsetHeight)\r\n    })\r\n    vSlickListRef.value.style.height = maxHeight + 'px'\r\n  }\r\n}\r\n\r\nconst onTrackOver = () => {\r\n  if (settings.value.autoplay) pause(PlayingType.hovered)\r\n}\r\n\r\nconst onTrackLeave = () => {\r\n  if (\r\n    settings.value.autoplay &&\r\n    state.value.autoplaying === PlayingType.hovered\r\n  )\r\n    autoPlay(PlayingType.leave)\r\n}\r\n\r\nconst handleClickVSlickList = (e: Event) => {\r\n  if (isVSlickListClickable === false) {\r\n    e.stopPropagation()\r\n    e.preventDefault()\r\n  }\r\n  isVSlickListClickable = true\r\n}\r\n\r\nconst handleChildClickVSlickTrack = ({ index }: ChildClickPayload) => {\r\n  if (!settings.value.focusOnSelect) return\r\n  changeSlideGroup({\r\n    message: 'children',\r\n    index\r\n  })\r\n}\r\n\r\nconst handleKeyDownVSlickList = (e: KeyboardEvent) => {\r\n  if (!settings.value.accessibility) return\r\n  const navigation = getNavigationOnKeyType(\r\n    e,\r\n    settings.value.accessibility,\r\n    settings.value.rtl\r\n  )\r\n  if (!navigation) return\r\n  changeSlideGroup({ message: navigation as SlideNavigation })\r\n}\r\n\r\nconst handleMouseDownOrTouchStartVSlickList = (e: SwipeEvent) => {\r\n  if (!settings.value.touchMove) return\r\n  const target = e.target as HTMLElement | null\r\n  if (target?.classList.contains('no-swipe')) return\r\n  swipeStart(e)\r\n}\r\n\r\nconst handleMouseMoveOrTouchMoveVSlickList = (e: SwipeEvent) => {\r\n  if (!state.value.dragging || !settings.value.touchMove) return\r\n  const target = e.target as HTMLElement | null\r\n  if (target?.classList.contains('no-swipe')) return\r\n  swipeMove(e)\r\n}\r\n\r\nconst handleMouseUpOrTouchEndVSlickList = (e: SwipeEvent) => {\r\n  if (!settings.value.touchMove) return\r\n  swipeEnd(e)\r\n}\r\n\r\nconst handleMouseLeaveOrTouchCancelVSlickList = (e: SwipeEvent) => {\r\n  if (!state.value.dragging || !settings.value.touchMove) return\r\n  swipeEnd(e)\r\n}\r\n\r\nconst handleMouseEnterOrOverVSlickTrack = () => {\r\n  if (!settings.value.pauseOnHover) return\r\n  onTrackOver()\r\n}\r\n\r\nconst handleMouseLeaveVSlickTrack = () => {\r\n  if (!settings.value.pauseOnHover) return\r\n  onTrackLeave()\r\n}\r\n\r\nconst handleOverDots = () => {\r\n  if (settings.value.pauseOnDotsHover && settings.value.autoplay)\r\n    pause(PlayingType.hovered)\r\n}\r\nconst handleLeaveDots = () => {\r\n  if (\r\n    settings.value.pauseOnDotsHover &&\r\n    settings.value.autoplay &&\r\n    state.value.autoplaying === PlayingType.hovered\r\n  )\r\n    autoPlay(PlayingType.leave)\r\n}\r\n\r\nconst handleClickDot = ({ index }: DotClickPayload) => {\r\n  changeSlideGroup({\r\n    message: 'dots',\r\n    index\r\n  })\r\n}\r\n\r\nconst handleNextVSlickArrow = () => {\r\n  changeSlideGroup({\r\n    message: SlideNavigation.next\r\n  })\r\n}\r\n\r\nconst handlePrevVSlickArrow = () => {\r\n  changeSlideGroup({\r\n    message: SlideNavigation.previous\r\n  })\r\n}\r\n\r\nconst changeSlideGroup = (\r\n  options: SlideGroupChangeOptions,\r\n  dontAnimate = false\r\n) => {\r\n  const spec = {\r\n    ...settings.value,\r\n    ...state.value,\r\n    slideGroupCount: slideGroupCount.value\r\n  }\r\n  const targetSlideGroupIndex = getChangedSlideGroupIndex(\r\n    spec as SlideGroupChangeSpec,\r\n    options\r\n  )\r\n  if (targetSlideGroupIndex === undefined || targetSlideGroupIndex === null)\r\n    return\r\n  slideGroupHandler(\r\n    targetSlideGroupIndex,\r\n    dontAnimate === true ? true : undefined\r\n  )\r\n}\r\n\r\nconst slideGroupHandler = async (index: number, dontAnimate = false) => {\r\n  const { asNavFor, speed } = settings.value\r\n  const currentSlideGroupIndex = state.value.currentSlideGroupIndex\r\n  const states = getStatesOnSlide({\r\n    index,\r\n    ...settings.value,\r\n    ...state.value,\r\n    slideGroupCount: slideGroupCount.value,\r\n    trackEl: vSlickTrackRef.value?.$el,\r\n    useCSSTransitions: settings.value.useCSSTransitions && !dontAnimate\r\n  } as OnSlideSpec)\r\n  if (!states) return\r\n  const { slidingState, afterSlidingState } = states\r\n  emit(\r\n    'beforeChange',\r\n    currentSlideGroupIndex,\r\n    slidingState.currentSlideGroupIndex\r\n  )\r\n  const slidesToLoad =\r\n    slidingState.lazyLoadedList?.filter(\r\n      (value: number) => state.value.lazyLoadedList.indexOf(value) < 0\r\n    ) || []\r\n  if (slidesToLoad.length) {\r\n    emit('lazyLoad', slidesToLoad)\r\n  }\r\n  Object.assign(state.value, slidingState)\r\n  if (asNavFor) {\r\n    ;(asNavFor as VSlickCarouselInstance).goTo(index)\r\n  }\r\n  if (!afterSlidingState) return\r\n  await new Promise<void>((resolve) => {\r\n    animationEndCallback = setTimeout(() => {\r\n      const { animating, ...firstBatch } = afterSlidingState!\r\n      if (\r\n        settings.value.waitForAnimate ||\r\n        state.value.currentSlideGroupIndex ===\r\n          slidingState.currentSlideGroupIndex\r\n      ) {\r\n        Object.assign(state.value, firstBatch)\r\n      }\r\n      callbackTimers.push(\r\n        setTimeout(() => {\r\n          state.value.animating = animating || false\r\n        })\r\n      )\r\n      emit('afterChange', slidingState.currentSlideGroupIndex)\r\n      animationEndCallback = null\r\n      resolve()\r\n    }, speed)\r\n  })\r\n}\r\n\r\nconst updateState = (shouldSetTrackStyle?: boolean) => {\r\n  const updatedState = getSliderState({\r\n    ...settings.value,\r\n    ...state.value,\r\n    listEl: vSlickListRef.value,\r\n    trackEl: vSlickTrackRef.value?.$el,\r\n    slides: slides.value\r\n  })\r\n  const spec: TrackInfoSpec = {\r\n    ...props,\r\n    ...state,\r\n    ...updatedState,\r\n    trackEl: vSlickTrackRef.value?.$el,\r\n    slideGroupCount: slideGroupCount.value\r\n  }\r\n  const targetLeft = getTrackLeft(spec as TrackInfoSpec)\r\n  const trackStyle = getTrackCSS(spec as TrackInfoSpec, targetLeft)\r\n  if (shouldSetTrackStyle || slideGroupCount.value !== spec.slideGroupCount) {\r\n    updatedState.trackStyle = trackStyle\r\n  }\r\n  Object.assign(state.value, updatedState)\r\n}\r\n\r\nconst resize = async (\r\n  options: { shouldSetTrackStyle?: boolean; isWindowResize?: boolean } = {\r\n    shouldSetTrackStyle: true\r\n  }\r\n) => {\r\n  if (!vSlickTrackRef.value || !vSlickTrackRef.value.$el) {\r\n    return\r\n  }\r\n  if (\r\n    settings.value.widthDetection === WidthDetection.manual &&\r\n    options.isWindowResize\r\n  ) {\r\n    await detectWidth()\r\n  }\r\n  updateState(\r\n    options.shouldSetTrackStyle ||\r\n      (settings.value.widthDetection === WidthDetection.manual &&\r\n        options.isWindowResize)\r\n  )\r\n  if (props.autoplay) {\r\n    autoPlay(PlayingType.update)\r\n  } else {\r\n    pause()\r\n  }\r\n}\r\n\r\nconst onResize = (options?: {\r\n  shouldSetTrackStyle?: boolean\r\n  isWindowResize?: boolean\r\n}) => {\r\n  debouncedResize?.cancel()\r\n  debouncedResize = debounce(() => resize(options), DEBOUNCE_RESIZE_DURATION)\r\n  debouncedResize()\r\n}\r\n\r\nconst onResizeEventListener = () =>\r\n  onResize({\r\n    isWindowResize: true\r\n  })\r\n\r\nconst onSlideGroupFocus = () => {\r\n  if (settings.value.autoplay) pause(PlayingType.focused)\r\n}\r\nconst onSlideGroupBlur = () => {\r\n  if (\r\n    settings.value.autoplay &&\r\n    state.value.autoplaying === PlayingType.focused\r\n  )\r\n    autoPlay(PlayingType.blur)\r\n}\r\n\r\nconst progressiveLazyLoad = () => {\r\n  const slideGroupsToLoad = []\r\n  const spec = { ...settings.value, ...state.value }\r\n  const totalPostClones = getTotalPostClones({\r\n    ...spec,\r\n    slideGroupCount: slideGroupCount.value\r\n  })\r\n  const totalPreClones = getTotalPreClones({\r\n    ...spec,\r\n    slideGroupCount: slideGroupCount.value\r\n  })\r\n  for (\r\n    let index = state.value.currentSlideGroupIndex;\r\n    index < slideGroupCount.value + totalPostClones;\r\n    index++\r\n  ) {\r\n    if (state.value.lazyLoadedList.indexOf(index) < 0) {\r\n      slideGroupsToLoad.push(index)\r\n      break\r\n    }\r\n  }\r\n  for (\r\n    let index = state.value.currentSlideGroupIndex - 1;\r\n    index >= -totalPreClones;\r\n    index--\r\n  ) {\r\n    if (state.value.lazyLoadedList.indexOf(index) < 0) {\r\n      slideGroupsToLoad.push(index)\r\n      break\r\n    }\r\n  }\r\n  if (slideGroupsToLoad.length > 0) {\r\n    state.value.lazyLoadedList =\r\n      state.value.lazyLoadedList.concat(slideGroupsToLoad)\r\n    emit('lazyLoad', slideGroupsToLoad)\r\n  } else {\r\n    if (lazyLoadTimer) {\r\n      clearInterval(lazyLoadTimer)\r\n      lazyLoadTimer = null\r\n    }\r\n  }\r\n}\r\n\r\nconst checkImagesLoad = () => {\r\n  const images = vSlickListRef.value?.querySelectorAll<HTMLImageElement>(\r\n    '.v-slick-slide-group img'\r\n  )\r\n  const imagesCount = images?.length || 0\r\n  let loadedCount = 0\r\n  images?.forEach((image) => {\r\n    const handler = () => {\r\n      if (++loadedCount >= imagesCount) {\r\n        onResize()\r\n      }\r\n    }\r\n    if (!image.onclick) {\r\n      image.onclick = () => {\r\n        ;(image.closest('.v-slick-slide-group') as HTMLElement)?.focus()\r\n      }\r\n    } else {\r\n      const prevClickHandler = image.onclick.bind(image)\r\n      image.onclick = (e) => {\r\n        prevClickHandler(e)\r\n        ;(image.closest('.v-slick-slide-group') as HTMLElement)?.focus()\r\n      }\r\n    }\r\n    if (!image.onload) {\r\n      if (!settings.value.lazyLoad) return\r\n      image.onload = () => {\r\n        adaptHeight()\r\n        callbackTimers.push(setTimeout(onResize, settings.value.speed))\r\n      }\r\n    } else {\r\n      image.onload = handler\r\n      image.onerror = () => {\r\n        handler()\r\n        emit('lazyLoadError')\r\n      }\r\n    }\r\n  })\r\n}\r\n\r\nconst detectWidth = async () => {\r\n  state.value.detectingWidth = true\r\n  return new Promise<void>((resolve) =>\r\n    setTimeout(() => {\r\n      Object.assign(vSlickCarouselStyle.value, {\r\n        width: `${vSlickCarouselRef.value?.offsetWidth}px`\r\n      })\r\n      state.value.detectingWidth = false\r\n      resolve()\r\n    })\r\n  )\r\n}\r\n\r\nconst ssrInit = () => {\r\n  const spec = {\r\n    ...settings.value,\r\n    ...state.value,\r\n    slideGroupCount: slideGroupCount.value\r\n  }\r\n  const preClones = getTotalPreClones(spec)\r\n  const postClones = getTotalPostClones(spec)\r\n  if (settings.value.variableWidth) {\r\n    let trackWidth = [],\r\n      trackLeft = []\r\n    const childrenWidths: number[] = []\r\n    rawSlideGroups.value.forEach((slideGroup) => {\r\n      let maxWidth = 0\r\n      slideGroup.forEach((child) => {\r\n        const { width } = child.props?.style || {}\r\n        if (width) maxWidth = Math.max(maxWidth, width)\r\n      })\r\n      childrenWidths.push(maxWidth)\r\n      trackWidth.push(maxWidth)\r\n    })\r\n    for (let i = 0; i < preClones; i++) {\r\n      trackLeft.push(childrenWidths[childrenWidths.length - 1 - i])\r\n      trackWidth.push(childrenWidths[childrenWidths.length - 1 - i])\r\n    }\r\n    for (let i = 0; i < postClones; i++) {\r\n      trackWidth.push(childrenWidths[i])\r\n    }\r\n    for (let i = 0; i < state.value.currentSlideGroupIndex; i++) {\r\n      trackLeft.push(childrenWidths[i])\r\n    }\r\n    trackWidth = trackWidth.filter((o) => o)\r\n    trackLeft = trackLeft.filter((o) => o)\r\n    const trackStyle = {\r\n      width: `calc(${trackWidth.join(' + ')})`,\r\n      left: `calc(${trackLeft.map((o) => `-${o}`).join(' + ')})`\r\n    }\r\n    if (settings.value.centerMode) {\r\n      const currentWidth = childrenWidths[state.value.currentSlideGroupIndex]\r\n      trackStyle.left = `calc(${trackLeft\r\n        .map((o) => `-${o}`)\r\n        .join(' + ')} + (100% - ${currentWidth}) / 2 )`\r\n    }\r\n    state.value.trackStyle = trackStyle\r\n  } else {\r\n    const _slideGroupCount = preClones + postClones + slideGroupCount.value\r\n    const trackWidth = (100 / settings.value.groupsToShow) * _slideGroupCount\r\n    const slideGroupWidth = 100 / _slideGroupCount\r\n    let trackLeft =\r\n      (-slideGroupWidth *\r\n        (preClones + state.value.currentSlideGroupIndex) *\r\n        trackWidth) /\r\n      100\r\n    if (settings.value.centerMode) {\r\n      trackLeft += (100 - (slideGroupWidth * trackWidth) / 100) / 2\r\n    }\r\n    state.value.slideGroupWidth = slideGroupWidth + '%'\r\n    state.value.trackStyle = {\r\n      width: trackWidth + '%',\r\n      left: trackLeft + '%'\r\n    }\r\n  }\r\n}\r\n\r\nconst breakpoint = ref<number>()\r\n\r\nconst vSlickCarouselRef = ref<HTMLElement>()\r\nconst vSlickCarouselStyle = ref({})\r\nconst vSlickListRef = ref<HTMLElement>()\r\nconst vSlickTrackRef = ref<InstanceType<typeof VSlickTrack>>()\r\n\r\nconst settings = computed<Props>(() => {\r\n  const definedProps = filterUndefined(props)\r\n  let settings = { ...defaultPropValues, ...definedProps }\r\n  if (breakpoint.value) {\r\n    const newProps = props.responsive.find(\r\n      (item) => item.breakpoint === breakpoint.value\r\n    )\r\n    settings = {\r\n      ...settings,\r\n      ...newProps?.settings\r\n    }\r\n  }\r\n  // force scrolling by one group if 'centerMode' is enabled\r\n  if (settings.centerMode) {\r\n    if (settings.groupsToScroll > 1 && process.env.NODE_ENV !== 'production') {\r\n      // eslint-disable-next-line no-console\r\n      console.warn(\r\n        `centerMode is enabled: groupsToScroll should be 1; you are using ${settings.groupsToScroll}`\r\n      )\r\n    }\r\n    settings.groupsToScroll = 1\r\n  }\r\n  // force showing one group and scrolling by one if `fade` is enabled\r\n  if (settings.fade) {\r\n    if (settings.groupsToShow > 1 && process.env.NODE_ENV !== 'production') {\r\n      // eslint-disable-next-line no-console\r\n      console.warn(\r\n        `fade is enabled: groupsToShow should be 1; you are using ${settings.groupsToShow}`\r\n      )\r\n    }\r\n    if (settings.groupsToScroll > 1 && process.env.NODE_ENV !== 'production') {\r\n      // eslint-disable-next-line no-console\r\n      console.warn(\r\n        `fade is enabled: groupsToScroll should be 1; you are using ${settings.groupsToScroll}`\r\n      )\r\n    }\r\n    settings.groupsToShow = 1\r\n    settings.groupsToScroll = 1\r\n  }\r\n  // force disabling `variableWidth` if `slidesPerGroup` is bigger than 1\r\n  if (settings.slidesPerGroup > 1) {\r\n    if (settings.variableWidth && process.env.NODE_ENV !== 'production') {\r\n      // eslint-disable-next-line no-console\r\n      console.warn(`slidesPerGroup is bigger than 1: variableWidth is disabled`)\r\n    }\r\n    settings.variableWidth = false\r\n  }\r\n\r\n  if (settings.vertical && settings.rtl) {\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      // eslint-disable-next-line no-console\r\n      console.warn(`vertical mode is enabled: rtl is disabled`)\r\n    }\r\n    settings.rtl = false\r\n  }\r\n\r\n  return settings\r\n})\r\n\r\nconst canGoPrev = computed(() =>\r\n  checkCanGoPrev({\r\n    ...settings.value,\r\n    ...state.value,\r\n    slideGroupCount: slideGroupCount.value\r\n  })\r\n)\r\n\r\nconst canGoNext = computed(() =>\r\n  checkCanGoNext({\r\n    ...settings.value,\r\n    ...state.value,\r\n    slideGroupCount: slideGroupCount.value\r\n  })\r\n)\r\n\r\nconst pageCount = computed(() => {\r\n  if (settings.value.infinite) {\r\n    return Math.ceil(slideGroupCount.value / settings.value.groupsToScroll)\r\n  }\r\n  let pageCount =\r\n    Math.ceil(\r\n      (slideGroupCount.value - settings.value.groupsToShow) /\r\n        settings.value.groupsToScroll\r\n    ) + 1\r\n  if (\r\n    !settings.value.infinite &&\r\n    settings.value.groupsToShow > 1 &&\r\n    settings.value.centerMode\r\n  ) {\r\n    pageCount++\r\n  }\r\n  return pageCount < 0 ? 0 : pageCount\r\n})\r\n\r\nconst slides = ref<VNode[]>(slots.default ? extractSlides(slots.default()) : [])\r\n\r\nconst state = ref({\r\n  ...makeDefaultSliderState(),\r\n  currentSlideGroupIndex: settings.value.initialGroupIndex\r\n})\r\n\r\nconst currentSlideGroupIndex = computed(\r\n  () => state.value.currentSlideGroupIndex\r\n)\r\n\r\nconst currentGroupsToShow = computed(() => settings.value.groupsToShow)\r\n\r\nconst slideGroupCount = computed(() =>\r\n  getSlideGroupCount(slides.value.length, settings.value.slidesPerGroup)\r\n)\r\n\r\nconst rawSlideGroups = computed<VNode[][]>(() => {\r\n  const slideGroups: VNode[][] = []\r\n  const slidesPerGroup = settings.value.slidesPerGroup\r\n  const slideGroupsCount = slideGroupCount.value\r\n  for (let i = 0; i < slideGroupsCount; i++) {\r\n    const startIndex = i * slidesPerGroup\r\n    const endIndex = startIndex + slidesPerGroup\r\n    slideGroups.push(slides.value.slice(startIndex, endIndex))\r\n  }\r\n  return slideGroups\r\n})\r\n\r\nwatch(\r\n  () => props,\r\n  () => {\r\n    clearBreakpoints()\r\n    makeBreakpoints()\r\n  },\r\n  { deep: true }\r\n)\r\n\r\nwatch(\r\n  settings,\r\n  (newSettings: Props, oldSettings: Props) => {\r\n    let shouldSetTrackStyle = false\r\n    for (const key of Object.keys(settings.value)) {\r\n      if (!newSettings.hasOwnProperty(key)) {\r\n        shouldSetTrackStyle = true\r\n        break\r\n      }\r\n      if (\r\n        typeof newSettings[key as keyof typeof newSettings] === 'object' ||\r\n        typeof newSettings[key as keyof typeof newSettings] === 'function'\r\n      ) {\r\n        continue\r\n      }\r\n      if (\r\n        newSettings[key as keyof typeof newSettings] !==\r\n        oldSettings[key as keyof typeof newSettings]\r\n      ) {\r\n        shouldSetTrackStyle = true\r\n        break\r\n      }\r\n    }\r\n    updateState(shouldSetTrackStyle)\r\n    if (state.value.currentSlideGroupIndex >= slideGroupCount.value) {\r\n      changeSlideGroup({\r\n        message: 'index',\r\n        index: slideGroupCount.value - newSettings.groupsToShow\r\n      })\r\n    }\r\n    if (newSettings.autoplay) {\r\n      autoPlay(PlayingType.update)\r\n    } else {\r\n      pause(PlayingType.paused)\r\n    }\r\n  },\r\n  {\r\n    deep: true\r\n  }\r\n)\r\n\r\nwatch(\r\n  () => slots.default?.() || [],\r\n  (newSlots) => {\r\n    slides.value = extractSlides(newSlots)\r\n  }\r\n)\r\n\r\nwatch(\r\n  () => [\r\n    state.value.listHeight,\r\n    settings.value.centerMode,\r\n    settings.value.centerPadding,\r\n    settings.value.vertical\r\n  ],\r\n  ([listHeight, centerMode, centerPadding, vertical]) => {\r\n    let verticalHeightStyle = {\r\n      height: 'auto'\r\n    }\r\n    if (vertical) {\r\n      verticalHeightStyle = {\r\n        height: `${listHeight}px`\r\n      }\r\n    }\r\n\r\n    let centerPaddingStyle\r\n    if (!centerMode) {\r\n      centerPaddingStyle = {\r\n        padding: '0'\r\n      }\r\n    } else if (vertical) {\r\n      centerPaddingStyle = {\r\n        padding: centerPadding + ' 0px'\r\n      }\r\n    } else {\r\n      centerPaddingStyle = {\r\n        padding: '0px ' + centerPadding\r\n      }\r\n    }\r\n    vSlickListStyle.value = {\r\n      ...vSlickListStyle.value,\r\n      ...filterUndefined(verticalHeightStyle),\r\n      ...centerPaddingStyle\r\n    }\r\n  }\r\n)\r\n\r\nwatch(\r\n  () => [\r\n    settings.value.infinite,\r\n    state.value.currentSlideGroupIndex,\r\n    settings.value.groupsToShow,\r\n    slideGroupCount.value\r\n  ],\r\n  ([infinite, groupsIndex, groupToShow, slideGroupCount]) => {\r\n    if (\r\n      infinite ||\r\n      (groupsIndex as number) <=\r\n        (slideGroupCount as number) - (groupToShow as number) + 1\r\n    )\r\n      return\r\n    slideGroupHandler(pageCount.value - 1)\r\n  }\r\n)\r\n\r\nwatch(\r\n  () => state.value.dragging,\r\n  (dragging) => {\r\n    if (!vSlickListRef.value) return\r\n    if (dragging) {\r\n      vSlickListRef.value.onmousemove = handleMouseMoveOrTouchMoveVSlickList\r\n      vSlickListRef.value.ontouchmove = handleMouseMoveOrTouchMoveVSlickList\r\n      vSlickListRef.value.onmouseup = handleMouseUpOrTouchEndVSlickList\r\n      vSlickListRef.value.ontouchend = handleMouseUpOrTouchEndVSlickList\r\n      vSlickListRef.value.onmouseleave = handleMouseLeaveOrTouchCancelVSlickList\r\n      vSlickListRef.value.ontouchcancel =\r\n        handleMouseLeaveOrTouchCancelVSlickList\r\n    } else {\r\n      vSlickListRef.value.onmousemove = null\r\n      vSlickListRef.value.ontouchmove = null\r\n      vSlickListRef.value.onmouseup = null\r\n      vSlickListRef.value.ontouchend = null\r\n      vSlickListRef.value.onmouseleave = null\r\n      vSlickListRef.value.ontouchcancel = null\r\n    }\r\n  }\r\n)\r\n\r\ndefineExpose({\r\n  goTo: slideGroupHandler,\r\n  next: () => {\r\n    slideGroupHandler(\r\n      state.value.currentSlideGroupIndex + settings.value.groupsToScroll\r\n    )\r\n  },\r\n  prev: () => {\r\n    slideGroupHandler(\r\n      state.value.currentSlideGroupIndex - settings.value.groupsToScroll\r\n    )\r\n  },\r\n  canGoNext,\r\n  canGoPrev,\r\n  play,\r\n  pause,\r\n  autoPlay,\r\n  slideGroupCount,\r\n  currentSlideGroupIndex,\r\n  currentGroupsToShow,\r\n  pageCount\r\n})\r\n\r\nonMounted(async () => {\r\n  window.addEventListener('resize', onResizeEventListener)\r\n  if (settings.value.widthDetection === WidthDetection.manual) {\r\n    await detectWidth()\r\n  }\r\n  updateState(true)\r\n  adaptHeight()\r\n  if (settings.value.autoplay) {\r\n    autoPlay(PlayingType.update)\r\n  }\r\n  if (settings.value.lazyLoad === LazyLoadType.progressive) {\r\n    lazyLoadTimer = setInterval(progressiveLazyLoad, 1000)\r\n  }\r\n  ro = new ResizeObserver(() => {\r\n    if (state.value.animating) {\r\n      onResize({ shouldSetTrackStyle: false }) // do not set trackStyle so as to not break the animation\r\n      callbackTimers.push(setTimeout(() => onResize(), settings.value.speed))\r\n    } else {\r\n      onResize()\r\n    }\r\n  })\r\n  ro.observe(vSlickListRef.value as Element)\r\n  vSlickListRef.value\r\n    ?.querySelectorAll<HTMLElement>('.v-slick-slide-group')\r\n    .forEach((slideGroup) => {\r\n      slideGroup.onfocus = settings.value.pauseOnFocus\r\n        ? onSlideGroupFocus\r\n        : null\r\n      slideGroup.onblur = settings.value.pauseOnFocus ? onSlideGroupBlur : null\r\n    })\r\n})\r\n\r\nonUpdated(() => {\r\n  checkImagesLoad()\r\n  emit('reInit')\r\n  if (settings.value.lazyLoad) {\r\n    const slideGroupsToLoad = getOnDemandLazySlideGroups({\r\n      ...settings.value,\r\n      ...state.value\r\n    })\r\n    if (slideGroupsToLoad.length) {\r\n      state.value.lazyLoadedList =\r\n        state.value.lazyLoadedList.concat(slideGroupsToLoad)\r\n      emit('lazyLoad', slideGroupsToLoad)\r\n    }\r\n  }\r\n  adaptHeight()\r\n})\r\n\r\nonBeforeUnmount(() => {\r\n  window.removeEventListener('resize', onResizeEventListener)\r\n  ro?.unobserve(vSlickListRef.value as Element)\r\n  if (animationEndCallback) {\r\n    clearTimeout(animationEndCallback)\r\n  }\r\n  if (lazyLoadTimer) {\r\n    clearInterval(lazyLoadTimer)\r\n  }\r\n  if (callbackTimers.length) {\r\n    callbackTimers.forEach((timer) => clearTimeout(timer))\r\n    callbackTimers = []\r\n  }\r\n  if (state.value.autoplayTimer) {\r\n    clearInterval(state.value.autoplayTimer)\r\n  }\r\n})\r\n\r\nmakeBreakpoints()\r\nssrInit()\r\nemit('init')\r\n</script>\r\n\r\n<style scoped lang=\"scss\">\r\n.v-slick-slider {\r\n  position: relative;\r\n  display: block;\r\n  box-sizing: border-box;\r\n}\r\n.v-slick-list {\r\n  position: relative;\r\n  display: block;\r\n  overflow: hidden;\r\n  margin: 0;\r\n  padding: 0;\r\n  transform: translate3d(0, 0, 0);\r\n  &:focus {\r\n    outline: none;\r\n  }\r\n  &.dragging {\r\n    cursor: pointer;\r\n    cursor: hand;\r\n  }\r\n}\r\n</style>\r\n"],"names":["PlayingType","LazyLoadType","SwipeDirection","SlideNavigation","WidthDetection","extractSlides","vnodes","vnode","isSlide","getNavigationOnKeyType","accessibility","rtl","_a","getChangedSlideGroupIndex","spec","options","indexOffset","previousInt","slideGroupOffset","unevenOffset","targetSlideGroupIndex","groupsToScroll","groupsToShow","slideGroupCount","currentSlideGroupIndex","lazyLoad","infinite","direction","siblingDirection","totalVisibleGroupsOnRightOfCurrGroup","totalVisibleGroupsOnLeftOfCurrGroup","centerMode","centerPadding","right","left","getNavigableIndexes","max","breakpoint","counter","indexes","checkNavigable","index","navigables","prevNavigable","n","getSwipeStartState","swipe","draggable","getTraversedSlideGroupCount","centerOffset","swipedSlideGroup","slideGroups","grp","currentIndex","swipedSlideGroupIndex","getSwipeDirection","touchObject","verticalSwiping","xDist","yDist","r","swipeAngle","getSwipeEndState","dragging","listWidth","touchThreshold","listHeight","swipeToSlide","scrolling","onSwipe","minSwipe","swipeDirection","state","newSlideGroupIndex","currentLeft","getTrackLeft","getTrackAnimateCSS","getLazySlidesOnLeft","getLazySlidesOnRight","getLazyStartIndex","getLazyEndIndex","getOnDemandLazySlideGroups","onDemandSlideGroups","startIndex","endIndex","slideGroupIndex","getTrackCSS","trackWidth","trackHeight","trackChildren","getTotalSlideGroups","style","transform","getTotalPreClones","getTotalPostClones","trackEl","slideGroupWidth","variableWidth","slideGroupHeight","fade","vertical","targetLeft","targetSlide","verticalOffset","slidesToOffset","targetSlideIndex","slide","canGoPrev","canGoNext","canGo","getStatesOnSlide","waitForAnimate","animating","lazyLoadedList","useCSSTransitions","animationSlideGroupIndex","finalSlideGroupIndex","slidingState","afterSlidingState","finalLeft","animationLeft","getSwipeMoveState","edgeFriction","edgeDragged","onEdge","swiped","swiping","swipeEvent","swipeLeft","curLeft","verticalSwipeLength","positionOffset","dotCount","touchSwipeLength","getSlideGroupCount","slideCount","getSliderState","_b","centerPaddingAdj","_c","slideGroupsToLoad","sliderState","canUseDOM","filterUndefined","props","key","acc","clearSelection","makeDefaultProps","selectFields","defaultProps","defaultPropValues","makeDefaultSliderState","defaultTrackProps","defaultArrowProps","defaultDotsProps","QueryHandler","target","QueryHandler_1","each","collection","fn","i","length","cont","isArray","isFunction","Util","require$$0","require$$1","MediaQuery","query","isUnconditional","self","mql","handler","qh","handlers","h","action","MediaQuery_1","MediaQueryDispatch","q","shouldDegrade","queries","MediaQueryDispatch_1","src","camel2hyphen","str","match","camel2hyphen_1","isDimension","feature","re","obj2mq","obj","mq","features","value","json2mq","json2mq_1","__props","emit","__emit","clickHandler","computed","arrowSlotProps","getSlideGroupClasses","isActive","isCenter","isCurrent","getSlideGroupStyle","originalSlideGroups","rawSlideGroup","classes","slideGroup","preCloneSlideGroups","preCloneNo","postCloneSlideGroups","leftBound","rightBound","FUNC_ERROR_TEXT","NAN","symbolTag","reTrim","reIsBadHex","reIsBinary","reIsOctal","freeParseInt","freeGlobal","global","freeSelf","root","objectProto","objectToString","nativeMax","nativeMin","now","debounce","func","wait","lastArgs","lastThis","maxWait","result","timerId","lastCallTime","lastInvokeTime","leading","maxing","trailing","toNumber","isObject","invokeFunc","time","args","thisArg","leadingEdge","timerExpired","remainingWait","timeSinceLastCall","timeSinceLastInvoke","shouldInvoke","trailingEdge","cancel","flush","debounced","isInvoking","type","isObjectLike","isSymbol","other","isBinary","lodash_debounce","DEBOUNCE_RESIZE_DURATION","slots","useSlots","enquire","enquireJs","triggerSlideGroupHandler","animationEndCallback","lazyLoadTimer","callbackTimers","vSlickListStyle","ref","getCurrentInstance","isVSlickListClickable","debouncedResize","ro","responsiveMediaHandlers","media","clearBreakpoints","makeBreakpoints","breakpoints","item","a","b","_breakpoint","mediaQuery","swipeStart","e","swipeStartState","settings","swipeEnd","swipeEndState","vSlickTrackRef","vSlickListRef","newTriggerSlideGroupHandler","rest","slideGroupHandler","swipeMove","swipeMoveState","play","nextIndex","pause","pauseType","autoplaying","autoPlay","playType","adaptHeight","activeSlideGroups","maxHeight","onTrackOver","onTrackLeave","handleClickVSlickList","handleChildClickVSlickTrack","changeSlideGroup","handleKeyDownVSlickList","navigation","handleMouseDownOrTouchStartVSlickList","handleMouseMoveOrTouchMoveVSlickList","handleMouseUpOrTouchEndVSlickList","handleMouseLeaveOrTouchCancelVSlickList","handleMouseEnterOrOverVSlickTrack","handleMouseLeaveVSlickTrack","handleOverDots","handleLeaveDots","handleClickDot","handleNextVSlickArrow","handlePrevVSlickArrow","dontAnimate","asNavFor","speed","states","slidesToLoad","resolve","firstBatch","updateState","shouldSetTrackStyle","updatedState","slides","trackStyle","resize","detectWidth","onResize","onResizeEventListener","onSlideGroupFocus","onSlideGroupBlur","progressiveLazyLoad","totalPostClones","totalPreClones","checkImagesLoad","images","imagesCount","loadedCount","image","prevClickHandler","vSlickCarouselStyle","vSlickCarouselRef","ssrInit","preClones","postClones","trackLeft","childrenWidths","rawSlideGroups","maxWidth","child","width","o","currentWidth","_slideGroupCount","definedProps","newProps","checkCanGoPrev","checkCanGoNext","pageCount","currentGroupsToShow","slidesPerGroup","slideGroupsCount","watch","newSettings","oldSettings","newSlots","verticalHeightStyle","centerPaddingStyle","groupsIndex","groupToShow","__expose","onMounted","onUpdated","onBeforeUnmount","timer"],"mappings":"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","x_google_ignoreList":[4,5,6,7,8,9,10,14]}