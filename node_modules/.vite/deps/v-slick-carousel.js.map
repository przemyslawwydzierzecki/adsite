{
  "version": 3,
  "sources": ["../../v-slick-carousel/lib/types/enums.ts", "../../v-slick-carousel/lib/utils/carousel-utils.ts", "../../v-slick-carousel/lib/utils/index.ts", "../../v-slick-carousel/lib/components/props.ts", "../../.pnpm/@dcufo+enquire.js@2.1.9/node_modules/@dcufo/enquire.js/src/QueryHandler.js", "../../.pnpm/@dcufo+enquire.js@2.1.9/node_modules/@dcufo/enquire.js/src/Util.js", "../../.pnpm/@dcufo+enquire.js@2.1.9/node_modules/@dcufo/enquire.js/src/MediaQuery.js", "../../.pnpm/@dcufo+enquire.js@2.1.9/node_modules/@dcufo/enquire.js/src/MediaQueryDispatch.js", "../../.pnpm/@dcufo+enquire.js@2.1.9/node_modules/@dcufo/enquire.js/src/index.js", "../../.pnpm/string-convert@0.2.1/node_modules/string-convert/camel2hyphen.js", "../../.pnpm/json2mq@0.2.0/node_modules/json2mq/index.js", "../../v-slick-carousel/lib/components/VSlickArrow.vue", "../../v-slick-carousel/lib/components/VSlickTrack.vue", "../../v-slick-carousel/lib/components/VSlickDots.vue", "../../.pnpm/lodash.debounce@4.0.8/node_modules/lodash.debounce/index.js", "../../v-slick-carousel/lib/components/VSlickCarousel.vue"],
  "sourcesContent": ["export enum PlayingType {\r\n  play = 'play',\r\n  playing = 'playing',\r\n  paused = 'paused',\r\n  hovered = 'hovered',\r\n  focused = 'focused',\r\n  update = 'update',\r\n  leave = 'leave',\r\n  blur = 'blur'\r\n}\r\n\r\nexport enum LazyLoadType {\r\n  ondemand = 'ondemand',\r\n  progressive = 'progressive'\r\n}\r\n\r\nexport enum SwipeDirection {\r\n  left = 'left',\r\n  right = 'right',\r\n  up = 'up',\r\n  down = 'down',\r\n  vertical = 'vertical'\r\n}\r\n\r\nexport enum SlideNavigation {\r\n  next = 'next',\r\n  previous = 'previous'\r\n}\r\n\r\nexport enum WidthDetection {\r\n  auto = 'auto',\r\n  manual = 'manual'\r\n}\r\n", "import { VNode } from 'vue'\r\nimport {\r\n  CloneInfoSpec,\r\n  GoNextSpec,\r\n  GoPrevSpec,\r\n  LazyInfoSpec,\r\n  NavigableSpec,\r\n  OnSlideSpec,\r\n  PlayingType,\r\n  SlideGroupChangeOptions,\r\n  SlideGroupChangeSpec,\r\n  SlideGroupCountSpec,\r\n  SlideNavigation,\r\n  SliderState,\r\n  SliderStateInfoSpec,\r\n  SwipeDirection,\r\n  SwipeEndSpec,\r\n  SwipeEndState,\r\n  SwipeEvent,\r\n  SwipeMoveSpec,\r\n  SwipeMoveState,\r\n  TouchObject,\r\n  TrackInfoSpec\r\n} from '../types'\r\nimport { MarkRequiredWithPartialBase } from '@lib/types/helpers'\r\n\r\nexport const extractSlides = (vnodes: VNode[]): VNode[] => {\r\n  return vnodes.flatMap((vnode) =>\r\n    isSlide(vnode)\r\n      ? [vnode]\r\n      : Array.isArray(vnode.children) && vnode.children.length > 0\r\n        ? extractSlides(vnode.children as VNode[])\r\n        : []\r\n  )\r\n}\r\n\r\nfunction isSlide(vnode: VNode): boolean {\r\n  return !vnode.type.toString().startsWith('Symbol')\r\n}\r\n\r\nexport const getNavigationOnKeyType = (\r\n  e: KeyboardEvent,\r\n  accessibility: boolean,\r\n  rtl: boolean\r\n) => {\r\n  if (\r\n    (e.target as HTMLElement)?.tagName.match('TEXTAREA|INPUT|SELECT') ||\r\n    !accessibility\r\n  )\r\n    return ''\r\n  if (e.key === 'ArrowLeft')\r\n    return rtl ? SlideNavigation.next : SlideNavigation.previous\r\n  if (e.key === 'ArrowRight')\r\n    return rtl ? SlideNavigation.previous : SlideNavigation.next\r\n  return ''\r\n}\r\n\r\nexport const getChangedSlideGroupIndex = (\r\n  spec: SlideGroupChangeSpec,\r\n  options: SlideGroupChangeOptions\r\n) => {\r\n  let indexOffset,\r\n    previousInt,\r\n    slideGroupOffset,\r\n    unevenOffset,\r\n    targetSlideGroupIndex\r\n  const {\r\n    groupsToScroll,\r\n    groupsToShow,\r\n    slideGroupCount,\r\n    currentSlideGroupIndex,\r\n    lazyLoad,\r\n    infinite\r\n  } = spec\r\n  unevenOffset = slideGroupCount % groupsToScroll !== 0\r\n  indexOffset = unevenOffset\r\n    ? 0\r\n    : (slideGroupCount - currentSlideGroupIndex) % groupsToScroll\r\n\r\n  if (options.message === SlideNavigation.previous) {\r\n    slideGroupOffset =\r\n      indexOffset === 0 ? groupsToScroll : groupsToShow - indexOffset\r\n    targetSlideGroupIndex = currentSlideGroupIndex - slideGroupOffset\r\n    if (lazyLoad && !infinite) {\r\n      previousInt = currentSlideGroupIndex - slideGroupOffset\r\n      targetSlideGroupIndex =\r\n        previousInt === -1 ? slideGroupCount - 1 : previousInt\r\n    }\r\n  } else if (options.message === SlideNavigation.next) {\r\n    slideGroupOffset = indexOffset === 0 ? groupsToScroll : indexOffset\r\n    targetSlideGroupIndex = currentSlideGroupIndex + slideGroupOffset\r\n    if (lazyLoad && !infinite) {\r\n      targetSlideGroupIndex =\r\n        ((currentSlideGroupIndex + groupsToScroll) % slideGroupCount) +\r\n        indexOffset\r\n    }\r\n  } else if (options.message === 'dots') {\r\n    // Click on dots\r\n    targetSlideGroupIndex = (options.index || 0) * groupsToScroll\r\n    if (targetSlideGroupIndex === currentSlideGroupIndex) {\r\n      return null\r\n    }\r\n  } else if (options.message === 'children') {\r\n    // Click on the slides\r\n    targetSlideGroupIndex = options.index || 0\r\n    if (targetSlideGroupIndex === currentSlideGroupIndex) {\r\n      return null\r\n    }\r\n    if (infinite) {\r\n      let direction = siblingDirection({ ...spec, targetSlideGroupIndex })\r\n      if (\r\n        targetSlideGroupIndex > currentSlideGroupIndex &&\r\n        direction === 'left'\r\n      ) {\r\n        targetSlideGroupIndex = targetSlideGroupIndex - slideGroupCount\r\n      } else if (\r\n        targetSlideGroupIndex < currentSlideGroupIndex &&\r\n        direction === 'right'\r\n      ) {\r\n        targetSlideGroupIndex = targetSlideGroupIndex + slideGroupCount\r\n      }\r\n    }\r\n  } else if (options.message === 'index') {\r\n    targetSlideGroupIndex = Number(options.index)\r\n    if (targetSlideGroupIndex === currentSlideGroupIndex) {\r\n      return null\r\n    }\r\n  }\r\n  return targetSlideGroupIndex\r\n}\r\n\r\nexport const siblingDirection = (\r\n  spec: SlideGroupChangeSpec & { targetSlideGroupIndex: number }\r\n) => {\r\n  if (spec.targetSlideGroupIndex > spec.currentSlideGroupIndex) {\r\n    if (\r\n      spec.targetSlideGroupIndex >\r\n      spec.currentSlideGroupIndex + totalVisibleGroupsOnRightOfCurrGroup(spec)\r\n    ) {\r\n      return 'left'\r\n    }\r\n    return 'right'\r\n  } else {\r\n    if (\r\n      spec.targetSlideGroupIndex <\r\n      spec.currentSlideGroupIndex - totalVisibleGroupsOnLeftOfCurrGroup(spec)\r\n    ) {\r\n      return 'right'\r\n    }\r\n    return 'left'\r\n  }\r\n}\r\n\r\nconst totalVisibleGroupsOnRightOfCurrGroup = ({\r\n  groupsToShow,\r\n  centerMode,\r\n  rtl,\r\n  centerPadding\r\n}: SlideGroupChangeSpec) => {\r\n  if (centerMode) {\r\n    let right = (groupsToShow - 1) / 2 + 1\r\n    if (parseInt(centerPadding) > 0) right += 1\r\n    if (rtl && groupsToShow % 2 === 0) right += 1\r\n    return right\r\n  }\r\n  if (rtl) {\r\n    return 0\r\n  }\r\n  return groupsToShow - 1\r\n}\r\n\r\nconst totalVisibleGroupsOnLeftOfCurrGroup = ({\r\n  groupsToShow,\r\n  centerMode,\r\n  rtl,\r\n  centerPadding\r\n}: SlideGroupChangeSpec) => {\r\n  if (centerMode) {\r\n    let left = (groupsToShow - 1) / 2 + 1\r\n    if (parseInt(centerPadding) > 0) left += 1\r\n    if (!rtl && groupsToShow % 2 === 0) left += 1\r\n    return left\r\n  }\r\n  if (rtl) {\r\n    return groupsToShow - 1\r\n  }\r\n  return 0\r\n}\r\n\r\nexport const getNavigableIndexes = (spec: NavigableSpec) => {\r\n  let max = spec.infinite ? spec.slideGroupCount * 2 : spec.slideGroupCount\r\n  let breakpoint = spec.infinite ? spec.groupsToShow * -1 : 0\r\n  let counter = spec.infinite ? spec.groupsToShow * -1 : 0\r\n  let indexes = []\r\n  while (breakpoint < max) {\r\n    indexes.push(breakpoint)\r\n    breakpoint = counter + spec.groupsToScroll\r\n    counter += Math.min(spec.groupsToScroll, spec.groupsToShow)\r\n  }\r\n  return indexes\r\n}\r\n\r\nexport const checkNavigable = (spec: NavigableSpec, index: number) => {\r\n  const navigables = getNavigableIndexes(spec)\r\n  let prevNavigable = 0\r\n  if (index > navigables[navigables.length - 1]) {\r\n    index = navigables[navigables.length - 1]\r\n  } else {\r\n    for (let n in navigables) {\r\n      if (index < navigables[n]) {\r\n        index = prevNavigable\r\n        break\r\n      }\r\n      prevNavigable = navigables[n]\r\n    }\r\n  }\r\n  return index\r\n}\r\n\r\nexport const getSwipeStartState = (\r\n  e: SwipeEvent,\r\n  swipe: boolean,\r\n  draggable: boolean\r\n) => {\r\n  if (!swipe || (!draggable && e.type.indexOf('mouse') !== -1)) return\r\n  return {\r\n    dragging: true,\r\n    touchObject: {\r\n      startX:\r\n        window.TouchEvent && e instanceof TouchEvent\r\n          ? e.touches[0].pageX\r\n          : (e as MouseEvent).clientX,\r\n      startY:\r\n        window.TouchEvent && e instanceof TouchEvent\r\n          ? e.touches[0].pageY\r\n          : (e as MouseEvent).clientY,\r\n      curX:\r\n        window.TouchEvent && e instanceof TouchEvent\r\n          ? e.touches[0].pageX\r\n          : (e as MouseEvent).clientX,\r\n      curY:\r\n        window.TouchEvent && e instanceof TouchEvent\r\n          ? e.touches[0].pageY\r\n          : (e as MouseEvent).clientY\r\n    }\r\n  }\r\n}\r\n\r\nexport const getTraversedSlideGroupCount = (spec: SlideGroupCountSpec) => {\r\n  const centerOffset = spec.centerMode\r\n    ? +spec.slideGroupWidth * Math.floor(spec.groupsToShow / 2)\r\n    : 0\r\n  let swipedSlideGroup\r\n  const slickList = spec.listEl\r\n  const slideGroups = slickList.querySelectorAll<HTMLElement>(\r\n    '.v-slick-slide-group'\r\n  )\r\n  Array.from(slideGroups).every((grp) => {\r\n    if (!spec.vertical) {\r\n      if (\r\n        grp.offsetLeft - centerOffset + grp.offsetWidth / 2 >\r\n        spec.swipeLeft * -1\r\n      ) {\r\n        swipedSlideGroup = grp\r\n        return false\r\n      }\r\n    } else {\r\n      if (grp.offsetTop + grp.offsetHeight / 2 > spec.swipeLeft * -1) {\r\n        swipedSlideGroup = grp\r\n        return false\r\n      }\r\n    }\r\n\r\n    return true\r\n  })\r\n\r\n  if (!swipedSlideGroup) {\r\n    return 0\r\n  }\r\n  const currentIndex =\r\n    spec.rtl === true\r\n      ? spec.slideGroupCount - spec.currentSlideGroupIndex\r\n      : spec.currentSlideGroupIndex\r\n  const swipedSlideGroupIndex = (swipedSlideGroup as HTMLElement)?.dataset\r\n    ?.index\r\n  const groupsTraversed = Math.abs(\r\n    swipedSlideGroupIndex ? parseInt(swipedSlideGroupIndex) : 0 - currentIndex\r\n  )\r\n  return groupsTraversed\r\n}\r\n\r\nexport const getSwipeDirection = (\r\n  touchObject: TouchObject,\r\n  verticalSwiping = false\r\n): SwipeDirection => {\r\n  let xDist, yDist, r, swipeAngle\r\n  xDist = touchObject.startX - touchObject.curX\r\n  yDist = touchObject.startY - touchObject.curY\r\n  r = Math.atan2(yDist, xDist)\r\n  swipeAngle = Math.round((r * 180) / Math.PI)\r\n  if (swipeAngle < 0) {\r\n    swipeAngle = 360 - Math.abs(swipeAngle)\r\n  }\r\n  if (\r\n    (swipeAngle <= 45 && swipeAngle >= 0) ||\r\n    (swipeAngle <= 360 && swipeAngle >= 315)\r\n  ) {\r\n    return SwipeDirection.left\r\n  }\r\n  if (swipeAngle >= 135 && swipeAngle <= 225) {\r\n    return SwipeDirection.right\r\n  }\r\n  if (verticalSwiping === true) {\r\n    if (swipeAngle >= 35 && swipeAngle <= 135) {\r\n      return SwipeDirection.up\r\n    } else {\r\n      return SwipeDirection.down\r\n    }\r\n  }\r\n\r\n  return SwipeDirection.vertical\r\n}\r\n\r\nexport const getSwipeEndState = (\r\n  e: SwipeEvent,\r\n  spec: SwipeEndSpec\r\n): SwipeEndState | undefined => {\r\n  const {\r\n    dragging,\r\n    swipe,\r\n    touchObject,\r\n    listWidth,\r\n    touchThreshold,\r\n    verticalSwiping,\r\n    listHeight,\r\n    currentSlideGroupIndex,\r\n    swipeToSlide,\r\n    scrolling,\r\n    onSwipe,\r\n    rtl\r\n  } = spec\r\n  if (!dragging) {\r\n    if (swipe) e.preventDefault()\r\n    return\r\n  }\r\n  let minSwipe = verticalSwiping\r\n    ? listHeight / touchThreshold\r\n    : listWidth / touchThreshold\r\n  let swipeDirection = getSwipeDirection(touchObject, verticalSwiping)\r\n  if (rtl) {\r\n    if (swipeDirection === SwipeDirection.left) {\r\n      swipeDirection = SwipeDirection.right\r\n    } else if (swipeDirection === SwipeDirection.right) {\r\n      swipeDirection = SwipeDirection.left\r\n    }\r\n  }\r\n  // reset the state of touch related state variables.\r\n  let state: SwipeEndState = {\r\n    dragging: false,\r\n    edgeDragged: false,\r\n    scrolling: false,\r\n    swiping: false,\r\n    swiped: false,\r\n    swipeLeft: null,\r\n    touchObject: {}\r\n  }\r\n  if (scrolling) {\r\n    return state\r\n  }\r\n  if (!touchObject.swipeLength) {\r\n    return state\r\n  }\r\n  if (touchObject.swipeLength > minSwipe) {\r\n    e.preventDefault()\r\n    if (onSwipe) {\r\n      onSwipe(swipeDirection)\r\n    }\r\n    let slideGroupCount, newSlideGroupIndex\r\n    switch (swipeDirection) {\r\n      case 'left':\r\n      case 'up':\r\n        newSlideGroupIndex = spec.swipeToSlide\r\n          ? getTraversedSlideGroupCount(spec)\r\n          : currentSlideGroupIndex + spec.groupsToScroll\r\n        slideGroupCount = swipeToSlide\r\n          ? checkNavigable(spec, newSlideGroupIndex)\r\n          : newSlideGroupIndex\r\n        state.currentDirection = 0\r\n        break\r\n      case 'right':\r\n      case 'down':\r\n        newSlideGroupIndex = spec.swipeToSlide\r\n          ? getTraversedSlideGroupCount(spec)\r\n          : currentSlideGroupIndex - spec.groupsToScroll\r\n        slideGroupCount = swipeToSlide\r\n          ? checkNavigable(spec, newSlideGroupIndex)\r\n          : newSlideGroupIndex\r\n        state.currentDirection = 1\r\n        break\r\n      default:\r\n        slideGroupCount = currentSlideGroupIndex\r\n    }\r\n    state.triggerSlideGroupHandler = slideGroupCount\r\n  } else {\r\n    // Adjust the track back to its original position.\r\n    let currentLeft = getTrackLeft(spec)\r\n    state.trackStyle = getTrackAnimateCSS(spec, currentLeft)\r\n  }\r\n  return state\r\n}\r\n\r\nexport function getLazySlidesOnLeft(spec: LazyInfoSpec) {\r\n  return spec.centerMode\r\n    ? Math.floor(spec.groupsToShow / 2) +\r\n        (parseInt(spec.centerPadding) > 0 ? 1 : 0)\r\n    : 0\r\n}\r\n\r\nexport function getLazySlidesOnRight(spec: LazyInfoSpec) {\r\n  return spec.centerMode\r\n    ? Math.floor((spec.groupsToShow - 1) / 2) +\r\n        1 +\r\n        (parseInt(spec.centerPadding) > 0 ? 1 : 0)\r\n    : spec.groupsToShow\r\n}\r\n\r\nexport function getLazyStartIndex(spec: LazyInfoSpec) {\r\n  return spec.currentSlideGroupIndex - getLazySlidesOnLeft(spec)\r\n}\r\n\r\nexport function getLazyEndIndex(spec: LazyInfoSpec) {\r\n  return spec.currentSlideGroupIndex + getLazySlidesOnRight(spec)\r\n}\r\n\r\nexport function getOnDemandLazySlideGroups(spec: LazyInfoSpec) {\r\n  let onDemandSlideGroups = []\r\n  const startIndex = getLazyStartIndex(spec)\r\n  const endIndex = getLazyEndIndex(spec)\r\n  for (\r\n    let slideGroupIndex = startIndex;\r\n    slideGroupIndex < endIndex;\r\n    slideGroupIndex++\r\n  ) {\r\n    if (spec.lazyLoadedList?.indexOf(slideGroupIndex) < 0) {\r\n      onDemandSlideGroups.push(slideGroupIndex)\r\n    }\r\n  }\r\n  return onDemandSlideGroups\r\n}\r\n\r\nexport function getTrackCSS(spec: TrackInfoSpec, left: number) {\r\n  let trackWidth, trackHeight\r\n  const trackChildren = spec.slideGroupCount + 2 * spec.groupsToShow\r\n  if (!spec.vertical) {\r\n    trackWidth =\r\n      getTotalSlideGroups(spec) * parseInt(`${spec.slideGroupWidth || 0}`)\r\n  } else {\r\n    trackHeight = trackChildren * parseInt(`${spec.slideGroupHeight || 0}`)\r\n  }\r\n  let style: Record<string, string | number> = {\r\n    opacity: 1,\r\n    transition: ''\r\n  }\r\n  if (spec.useCSSTransform) {\r\n    let transform = !spec.vertical\r\n      ? 'translate3d(' + left + 'px, 0px, 0px)'\r\n      : 'translate3d(0px, ' + left + 'px, 0px)'\r\n    style = {\r\n      ...style,\r\n      transform\r\n    }\r\n  } else {\r\n    if (spec.vertical) {\r\n      style['top'] = left\r\n    } else {\r\n      style['left'] = left\r\n    }\r\n  }\r\n  if (spec.fade) style = { opacity: 1 }\r\n  if (trackWidth) style.width = trackWidth + 'px'\r\n  if (trackHeight) style.height = trackHeight + 'px'\r\n\r\n  return style\r\n}\r\n\r\nexport function getTotalSlideGroups(spec: TrackInfoSpec) {\r\n  return spec.slideGroupCount <= spec.groupsToShow\r\n    ? spec.slideGroupCount\r\n    : getTotalPreClones(spec) + spec.slideGroupCount + getTotalPostClones(spec)\r\n}\r\n\r\nexport function getTrackAnimateCSS(spec: TrackInfoSpec, left: number) {\r\n  let style = getTrackCSS(spec, left)\r\n  // useCSS is true by default so it can be undefined\r\n  if (spec.useCSSTransform) {\r\n    style.transition = 'transform ' + spec.speed + 'ms ' + spec.cssEase\r\n  } else {\r\n    if (spec.vertical) {\r\n      style.transition = 'top ' + spec.speed + 'ms ' + spec.cssEase\r\n    } else {\r\n      style.transition = 'left ' + spec.speed + 'ms ' + spec.cssEase\r\n    }\r\n  }\r\n  if (spec.ignorePrefersReducedMotion) {\r\n    style.transition += ' !important'\r\n  }\r\n  return style\r\n}\r\n\r\nexport function getTrackLeft(spec: TrackInfoSpec) {\r\n  let {\r\n    centerPadding,\r\n    currentSlideGroupIndex,\r\n    trackEl,\r\n    infinite,\r\n    centerMode,\r\n    slideGroupCount,\r\n    groupsToShow,\r\n    groupsToScroll,\r\n    slideGroupWidth,\r\n    listWidth,\r\n    variableWidth,\r\n    slideGroupHeight,\r\n    fade,\r\n    vertical,\r\n    rtl\r\n  } = spec\r\n  listWidth = listWidth || 0\r\n  slideGroupWidth = slideGroupWidth || 0\r\n  slideGroupHeight = slideGroupHeight || 0\r\n\r\n  let slideGroupOffset = 0\r\n  let targetLeft\r\n  let targetSlide: HTMLElement\r\n  let verticalOffset = 0\r\n\r\n  if (fade || slideGroupCount === 1) {\r\n    return 0\r\n  }\r\n\r\n  let slidesToOffset = 0\r\n  if (infinite) {\r\n    slidesToOffset = -getTotalPreClones(spec) // bring active slide to the beginning of visible area\r\n    // if next scroll doesn't have enough children, just reach till the end of original slides instead of shifting groupsToScroll children\r\n    if (\r\n      slideGroupCount % groupsToScroll !== 0 &&\r\n      currentSlideGroupIndex + groupsToScroll > slideGroupCount\r\n    ) {\r\n      slidesToOffset = -(currentSlideGroupIndex > slideGroupCount\r\n        ? groupsToShow - (currentSlideGroupIndex - slideGroupCount)\r\n        : slideGroupCount % groupsToScroll)\r\n    }\r\n    // in center mode, shift current slide group to the center of the frame\r\n    if (centerMode) {\r\n      slidesToOffset += Math.floor(groupsToShow / 2)\r\n    }\r\n  } else {\r\n    if (\r\n      slideGroupCount % groupsToScroll !== 0 &&\r\n      currentSlideGroupIndex + groupsToScroll > slideGroupCount\r\n    ) {\r\n      slidesToOffset = groupsToShow - (slideGroupCount % groupsToScroll)\r\n    }\r\n    if (centerMode) {\r\n      slidesToOffset = Math.floor(groupsToShow / 2)\r\n    }\r\n  }\r\n  slideGroupOffset = slidesToOffset * parseInt(`${slideGroupWidth}`)\r\n  verticalOffset = slidesToOffset * parseInt(`${slideGroupHeight}`)\r\n\r\n  if (!vertical) {\r\n    targetLeft =\r\n      currentSlideGroupIndex * parseInt(`${slideGroupWidth}`) * -1 +\r\n      slideGroupOffset\r\n  } else {\r\n    targetLeft =\r\n      currentSlideGroupIndex * parseInt(`${slideGroupHeight}`) * -1 +\r\n      verticalOffset\r\n  }\r\n\r\n  if (variableWidth === true) {\r\n    let targetSlideIndex\r\n    targetSlideIndex = currentSlideGroupIndex + getTotalPreClones(spec)\r\n    targetSlide =\r\n      trackEl && (trackEl.childNodes[targetSlideIndex] as HTMLElement)\r\n    targetLeft = targetSlide ? targetSlide.offsetLeft * -1 : 0\r\n    if (centerMode === true) {\r\n      targetSlideIndex = infinite\r\n        ? currentSlideGroupIndex + getTotalPreClones(spec)\r\n        : currentSlideGroupIndex\r\n      targetSlide =\r\n        trackEl && (trackEl.children[targetSlideIndex] as HTMLElement)\r\n      targetLeft = 0\r\n      for (let slide = 0; slide < targetSlideIndex; slide++) {\r\n        targetLeft -=\r\n          trackEl &&\r\n          trackEl.children[slide] &&\r\n          (trackEl.children[slide] as HTMLElement).offsetWidth\r\n      }\r\n      targetLeft -= parseInt(centerPadding)\r\n      targetLeft += targetSlide && (listWidth - targetSlide.offsetWidth) / 2\r\n    }\r\n  }\r\n\r\n  if (rtl) targetLeft = -targetLeft\r\n\r\n  return targetLeft\r\n}\r\n\r\nexport const canGoPrev = (spec: GoPrevSpec) => {\r\n  return (\r\n    spec.infinite ||\r\n    (spec.currentSlideGroupIndex !== 0 &&\r\n      spec.slideGroupCount > spec.groupsToShow)\r\n  )\r\n}\r\n\r\nexport const canGoNext = (spec: GoNextSpec) => {\r\n  let canGo = true\r\n  if (!spec.infinite) {\r\n    if (spec.centerMode) {\r\n      canGo = spec.currentSlideGroupIndex < spec.slideGroupCount - 1\r\n    } else if (\r\n      spec.slideGroupCount <= spec.groupsToShow ||\r\n      spec.currentSlideGroupIndex >= spec.slideGroupCount - spec.groupsToShow\r\n    ) {\r\n      canGo = false\r\n    }\r\n  }\r\n  return canGo\r\n}\r\n\r\nexport const getStatesOnSlide = (spec: OnSlideSpec) => {\r\n  let {\r\n    waitForAnimate,\r\n    animating,\r\n    fade,\r\n    infinite,\r\n    index,\r\n    slideGroupCount,\r\n    lazyLoadedList,\r\n    lazyLoad,\r\n    currentSlideGroupIndex,\r\n    centerMode,\r\n    groupsToScroll,\r\n    groupsToShow,\r\n    useCSSTransitions\r\n  } = spec\r\n  if (\r\n    (waitForAnimate && animating) ||\r\n    (fade && !infinite && (index < 0 || index >= slideGroupCount))\r\n  )\r\n    return\r\n  let animationSlideGroupIndex = index,\r\n    finalSlideGroupIndex\r\n  let slidingState: Partial<SliderState> = {},\r\n    afterSlidingState: Partial<SliderState> = {}\r\n  if (fade) {\r\n    if (index < 0) {\r\n      animationSlideGroupIndex += slideGroupCount\r\n    } else if (index >= slideGroupCount) {\r\n      animationSlideGroupIndex -= slideGroupCount\r\n    }\r\n    if (lazyLoad && lazyLoadedList.indexOf(animationSlideGroupIndex) < 0) {\r\n      lazyLoadedList.push(animationSlideGroupIndex)\r\n    }\r\n    slidingState = {\r\n      animating: true,\r\n      currentSlideGroupIndex: animationSlideGroupIndex,\r\n      lazyLoadedList\r\n    }\r\n    afterSlidingState = { animating: false }\r\n    return {\r\n      slidingState,\r\n      afterSlidingState\r\n    }\r\n  }\r\n  finalSlideGroupIndex = animationSlideGroupIndex\r\n  if (animationSlideGroupIndex < 0) {\r\n    finalSlideGroupIndex = animationSlideGroupIndex + slideGroupCount\r\n    if (!infinite) finalSlideGroupIndex = 0\r\n    else if (slideGroupCount % groupsToScroll !== 0)\r\n      finalSlideGroupIndex =\r\n        slideGroupCount - (slideGroupCount % groupsToScroll)\r\n  } else if (\r\n    !canGoNext(spec) &&\r\n    animationSlideGroupIndex > currentSlideGroupIndex\r\n  ) {\r\n    animationSlideGroupIndex = finalSlideGroupIndex = currentSlideGroupIndex\r\n  } else if (centerMode && animationSlideGroupIndex >= slideGroupCount) {\r\n    animationSlideGroupIndex = infinite ? slideGroupCount : slideGroupCount - 1\r\n    finalSlideGroupIndex = infinite ? 0 : slideGroupCount - 1\r\n  } else if (animationSlideGroupIndex >= slideGroupCount) {\r\n    finalSlideGroupIndex = animationSlideGroupIndex - slideGroupCount\r\n    if (!infinite) finalSlideGroupIndex = slideGroupCount - groupsToShow\r\n    else if (slideGroupCount % groupsToScroll !== 0) finalSlideGroupIndex = 0\r\n  }\r\n  let finalLeft = getTrackLeft({\r\n    ...spec,\r\n    currentSlideGroupIndex: finalSlideGroupIndex\r\n  })\r\n  let animationLeft = getTrackLeft({\r\n    ...spec,\r\n    currentSlideGroupIndex: animationSlideGroupIndex\r\n  })\r\n  if (!infinite) {\r\n    if (animationLeft === finalLeft)\r\n      animationSlideGroupIndex = finalSlideGroupIndex\r\n    animationLeft = finalLeft\r\n  }\r\n  if (lazyLoad)\r\n    lazyLoadedList = lazyLoadedList.concat(\r\n      getOnDemandLazySlideGroups({\r\n        ...spec,\r\n        currentSlideGroupIndex: animationSlideGroupIndex\r\n      })\r\n    )\r\n  if (!useCSSTransitions) {\r\n    slidingState = {\r\n      currentSlideGroupIndex: finalSlideGroupIndex,\r\n      trackStyle: getTrackCSS(spec, finalLeft),\r\n      lazyLoadedList\r\n    }\r\n    return {\r\n      slidingState,\r\n      afterSlidingState\r\n    }\r\n  }\r\n  slidingState = {\r\n    animating: true,\r\n    currentSlideGroupIndex: finalSlideGroupIndex,\r\n    trackStyle: getTrackAnimateCSS(spec, animationLeft),\r\n    lazyLoadedList\r\n  }\r\n  afterSlidingState = {\r\n    animating: false,\r\n    currentSlideGroupIndex: finalSlideGroupIndex,\r\n    trackStyle: getTrackCSS(spec, finalLeft),\r\n    swipeLeft: undefined\r\n  }\r\n  return { slidingState, afterSlidingState }\r\n}\r\n\r\nexport function getTotalPreClones(spec: CloneInfoSpec) {\r\n  if (!spec.infinite) {\r\n    return 0\r\n  }\r\n  if (spec.variableWidth) {\r\n    return spec.slideGroupCount\r\n  }\r\n  return spec.groupsToShow + (spec.centerMode ? 1 : 0)\r\n}\r\n\r\nexport function getTotalPostClones(spec: CloneInfoSpec) {\r\n  if (!spec.infinite) {\r\n    return 0\r\n  }\r\n  return spec.slideGroupCount\r\n}\r\n\r\nexport const getSwipeMoveState = (\r\n  e: SwipeEvent,\r\n  spec: SwipeMoveSpec\r\n): SwipeMoveState | undefined => {\r\n  const {\r\n    scrolling,\r\n    animating,\r\n    vertical,\r\n    swipeToSlide,\r\n    verticalSwiping,\r\n    rtl,\r\n    currentSlideGroupIndex,\r\n    edgeFriction,\r\n    edgeDragged,\r\n    onEdge,\r\n    swiped,\r\n    swiping,\r\n    slideGroupCount,\r\n    groupsToScroll,\r\n    infinite,\r\n    touchObject,\r\n    swipeEvent,\r\n    listHeight,\r\n    listWidth\r\n  } = spec\r\n  if (scrolling) return\r\n  if (animating) {\r\n    e.preventDefault()\r\n    return\r\n  }\r\n  if (vertical && swipeToSlide && verticalSwiping) e.preventDefault()\r\n  let swipeLeft,\r\n    state: SwipeMoveState = {}\r\n  let curLeft = getTrackLeft(spec)\r\n  touchObject.curX =\r\n    window.TouchEvent && e instanceof TouchEvent\r\n      ? e.touches[0].pageX\r\n      : (e as MouseEvent).clientX\r\n  touchObject.curY =\r\n    window.TouchEvent && e instanceof TouchEvent\r\n      ? e.touches[0].pageY\r\n      : (e as MouseEvent).clientY\r\n  touchObject.swipeLength = Math.round(\r\n    Math.sqrt(Math.pow(touchObject.curX - touchObject.startX, 2))\r\n  )\r\n  let verticalSwipeLength = Math.round(\r\n    Math.sqrt(Math.pow(touchObject.curY - touchObject.startY, 2))\r\n  )\r\n  if (!verticalSwiping && !swiping && verticalSwipeLength > 10) {\r\n    return { scrolling: true }\r\n  }\r\n  if (verticalSwiping) touchObject.swipeLength = verticalSwipeLength\r\n  let positionOffset =\r\n    (!rtl ? 1 : -1) * (touchObject.curX > touchObject.startX ? 1 : -1)\r\n  if (verticalSwiping)\r\n    positionOffset = touchObject.curY > touchObject.startY ? 1 : -1\r\n\r\n  let dotCount = Math.ceil(slideGroupCount / groupsToScroll)\r\n  let swipeDirection = getSwipeDirection(spec.touchObject, verticalSwiping)\r\n  let touchSwipeLength = touchObject.swipeLength\r\n  if (!infinite) {\r\n    if (\r\n      (currentSlideGroupIndex === 0 && swipeDirection === 'right') ||\r\n      (currentSlideGroupIndex + 1 >= dotCount && swipeDirection === 'left') ||\r\n      (!canGoNext(spec) && swipeDirection === 'left')\r\n    ) {\r\n      touchSwipeLength = Math.round(touchObject.swipeLength * edgeFriction)\r\n      if (edgeDragged === false && onEdge) {\r\n        onEdge(swipeDirection)\r\n        state.edgeDragged = true\r\n      }\r\n    }\r\n  }\r\n  if (!swiped && swipeEvent) {\r\n    swipeEvent(swipeDirection)\r\n    state.swiped = true\r\n  }\r\n  if (!vertical) {\r\n    if (!rtl) {\r\n      swipeLeft = curLeft + touchSwipeLength * positionOffset\r\n    } else {\r\n      swipeLeft = curLeft - touchSwipeLength * positionOffset\r\n    }\r\n  } else {\r\n    swipeLeft =\r\n      curLeft + touchSwipeLength * (listHeight / listWidth) * positionOffset\r\n  }\r\n  if (verticalSwiping) {\r\n    swipeLeft = curLeft + touchSwipeLength * positionOffset\r\n  }\r\n  state = {\r\n    ...state,\r\n    touchObject,\r\n    swipeLeft,\r\n    trackStyle: getTrackCSS(spec, swipeLeft)\r\n  }\r\n  if (\r\n    Math.abs(touchObject.curX - touchObject.startX) <\r\n    Math.abs(touchObject.curY - touchObject.startY) * 0.8\r\n  ) {\r\n    return state\r\n  }\r\n  if (touchObject.swipeLength > 10) {\r\n    state.swiping = true\r\n    e.preventDefault()\r\n  }\r\n  return state\r\n}\r\n\r\nexport function getSlideGroupCount(slideCount: number, groupsToShow: number) {\r\n  return Math.ceil(slideCount / groupsToShow)\r\n}\r\n\r\nexport function getSliderState(spec: SliderStateInfoSpec) {\r\n  let slideGroupCount = getSlideGroupCount(\r\n    spec.slides.length,\r\n    spec.groupsToShow\r\n  )\r\n  let listWidth = Math.ceil(spec.listEl?.offsetWidth || 0)\r\n  let trackWidth = Math.ceil(spec.trackEl?.offsetWidth || 0)\r\n  let slideGroupWidth\r\n  if (!spec.vertical) {\r\n    let centerPaddingAdj = spec.centerMode\r\n      ? parseInt(spec.centerPadding) * 2\r\n      : 0\r\n    if (\r\n      typeof spec.centerPadding === 'string' &&\r\n      spec.centerPadding.slice(-1) === '%'\r\n    ) {\r\n      centerPaddingAdj *= listWidth / 100\r\n    }\r\n    slideGroupWidth = Math.ceil(\r\n      (listWidth - centerPaddingAdj) / spec.groupsToShow\r\n    )\r\n  } else {\r\n    slideGroupWidth = listWidth\r\n  }\r\n  let slideGroupHeight =\r\n    spec.listEl && spec.listEl.querySelector('[data-index=\"0\"]')\r\n      ? spec.listEl.querySelector<HTMLElement>('[data-index=\"0\"]')\r\n          ?.offsetHeight || 0\r\n      : 0\r\n  let listHeight = slideGroupHeight * spec.groupsToShow\r\n  let currentSlideGroupIndex =\r\n    spec.currentSlideGroupIndex === undefined\r\n      ? spec.initialGroupIndex\r\n      : spec.currentSlideGroupIndex\r\n  if (spec.rtl && spec.currentSlideGroupIndex === undefined) {\r\n    currentSlideGroupIndex = slideGroupCount - 1 - spec.initialGroupIndex\r\n  }\r\n  let lazyLoadedList = spec.lazyLoadedList || []\r\n  let slideGroupsToLoad = getOnDemandLazySlideGroups(spec as LazyInfoSpec)\r\n  lazyLoadedList.concat(slideGroupsToLoad)\r\n\r\n  let sliderState: MarkRequiredWithPartialBase<\r\n    SliderState,\r\n    | 'currentSlideGroupIndex'\r\n    | 'listWidth'\r\n    | 'slideGroupHeight'\r\n    | 'slideGroupWidth'\r\n  > & { slideGroupCount: number } = {\r\n    slideGroupCount,\r\n    slideGroupWidth,\r\n    listWidth,\r\n    trackWidth,\r\n    currentSlideGroupIndex,\r\n    slideGroupHeight,\r\n    listHeight,\r\n    lazyLoadedList\r\n  }\r\n\r\n  if (spec.autoplaying === null && spec.autoplay) {\r\n    sliderState.autoplaying = PlayingType.playing\r\n  }\r\n\r\n  return sliderState\r\n}\r\n", "export * from './carousel-utils'\r\n\r\nexport const canUseDOM = () =>\r\n  !!(\r\n    typeof window !== 'undefined' &&\r\n    window.document &&\r\n    window.document.createElement\r\n  )\r\n\r\nexport const filterUndefined = <T extends object>(props: T) =>\r\n  Object.keys(props)\r\n    .filter((key) => props[key as keyof T] !== undefined)\r\n    .reduce((acc, key) => {\r\n      acc[key as keyof T] = props[key as keyof T]\r\n      return acc\r\n    }, {} as T)\r\n\r\nexport function clearSelection() {\r\n  if (!window.getSelection) return\r\n  if (window.getSelection()?.empty) {\r\n    window.getSelection()!.empty()\r\n  } else if (window.getSelection()?.removeAllRanges) {\r\n    window.getSelection()!.removeAllRanges()\r\n  }\r\n}\r\n", "import { PropType, VNode } from 'vue'\r\nimport {\r\n  ArrowProps,\r\n  DotsProps,\r\n  Props,\r\n  Responsive,\r\n  SlideNavigation,\r\n  SliderState,\r\n  TrackProps,\r\n  WidthDetection\r\n} from '../types'\r\n\r\ntype VuePropDef<T extends string> = Record<\r\n  T,\r\n  { type: PropType<unknown>; default: unknown }\r\n>\r\n\r\nconst makeDefaultProps = (selectFields?: string[]) => {\r\n  const defaultProps = {\r\n    accessibility: { type: Boolean, default: true },\r\n    adaptiveHeight: { type: Boolean, default: false },\r\n    arrows: { type: Boolean, default: true },\r\n    asNavFor: {\r\n      type: Object,\r\n      default: null\r\n    },\r\n    autoplay: { type: Boolean, default: false },\r\n    autoplaySpeed: { type: Number, default: 3000 },\r\n    centerMode: { type: Boolean, default: false },\r\n    centerPadding: { type: String, default: '50px' },\r\n    cssEase: { type: String, default: 'ease' },\r\n    dots: { type: Boolean, default: false },\r\n    dotsClass: { type: String, default: 'v-slick-dots' },\r\n    draggable: { type: Boolean, default: true },\r\n    edgeFriction: { type: Number, default: 0.35 },\r\n    fade: { type: Boolean, default: false },\r\n    focusOnSelect: { type: Boolean, default: false },\r\n    ignorePrefersReducedMotion: { type: Boolean, default: false },\r\n    infinite: { type: Boolean, default: true },\r\n    initialGroupIndex: { type: Number, default: 0 },\r\n    lazyLoad: { type: String, default: null },\r\n    nextArrowLabel: { type: String, default: 'Next' },\r\n    pauseOnDotsHover: { type: Boolean, default: false },\r\n    pauseOnFocus: { type: Boolean, default: false },\r\n    pauseOnHover: { type: Boolean, default: true },\r\n    prevArrowLabel: { type: String, default: 'Previous' },\r\n    responsive: { type: Array as PropType<Responsive[]>, default: [] },\r\n    rtl: { type: Boolean, default: false },\r\n    slidesPerGroup: { type: Number, default: 1 },\r\n    groupsToScroll: { type: Number, default: 1 },\r\n    groupsToShow: { type: Number, default: 1 },\r\n    speed: { type: Number, default: 500 },\r\n    swipe: { type: Boolean, default: true },\r\n    swipeToSlide: { type: Boolean, default: false },\r\n    touchMove: { type: Boolean, default: true },\r\n    touchThreshold: { type: Number, default: 5 },\r\n    useCSSTransitions: { type: Boolean, default: true },\r\n    useCSSTransform: { type: Boolean, default: true },\r\n    variableWidth: { type: Boolean, default: false },\r\n    vertical: { type: Boolean, default: false },\r\n    verticalSwiping: { type: Boolean, default: false },\r\n    waitForAnimate: { type: Boolean, default: true },\r\n    widthDetection: { type: String, default: WidthDetection.auto }\r\n  } satisfies VuePropDef<keyof Props>\r\n  if (!selectFields) return defaultProps\r\n  return Object.keys(defaultProps).reduce<{\r\n    [key: string]: { type: PropType<unknown>; default: unknown }\r\n  }>((acc, key) => {\r\n    if (selectFields.includes(key)) {\r\n      acc[key as keyof Props] = (defaultProps as any)[key]\r\n    }\r\n    return acc\r\n  }, {}) as typeof defaultProps\r\n}\r\n\r\nexport const defaultProps = makeDefaultProps() satisfies VuePropDef<keyof Props>\r\n\r\nexport const defaultPropValues = Object.keys(defaultProps).reduce<{\r\n  [key: string]: unknown\r\n}>((acc, key) => {\r\n  acc[key] = (defaultProps as any)[key].default\r\n  return acc\r\n}, {}) as {\r\n  [K in keyof Props]: unknown\r\n} as Props\r\n\r\nexport const makeDefaultSliderState: () => SliderState = () => ({\r\n  animating: false,\r\n  autoplaying: null,\r\n  autoplayTimer: null,\r\n  currentDirection: 0,\r\n  currentLeft: null,\r\n  currentSlideGroupIndex: 0,\r\n  detectingWidth: false,\r\n  direction: 1,\r\n  dragging: false,\r\n  edgeDragged: false,\r\n  initialized: false,\r\n  lazyLoadedList: [],\r\n  listHeight: undefined,\r\n  listWidth: undefined,\r\n  scrolling: false,\r\n  slideGroupHeight: undefined,\r\n  slideGroupWidth: undefined,\r\n  swipeLeft: undefined,\r\n  swiped: false,\r\n  swiping: false,\r\n  touchObject: { startX: 0, startY: 0, curX: 0, curY: 0, swipeLength: 0 },\r\n  trackStyle: {},\r\n  trackWidth: 0\r\n})\r\n\r\nexport const defaultTrackProps = {\r\n  ...makeDefaultProps([\r\n    'centerMode',\r\n    'centerPadding',\r\n    'cssEase',\r\n    'fade',\r\n    'ignorePrefersReducedMotion',\r\n    'infinite',\r\n    'lazyLoad',\r\n    'rtl',\r\n    'groupsToScroll',\r\n    'groupsToShow',\r\n    'speed',\r\n    'variableWidth',\r\n    'vertical'\r\n  ]),\r\n  ...{\r\n    currentSlideGroupIndex: { type: Number, default: 0 },\r\n    detectingWidth: { type: Boolean, default: false },\r\n    lazyLoadedList: {\r\n      type: Array as PropType<number[]>,\r\n      default: []\r\n    },\r\n    listHeight: { type: Number, default: undefined },\r\n    trackStyle: { type: Object, default: {} },\r\n    slideGroupCount: { type: Number, default: 0 },\r\n    rawSlideGroups: { type: Array as PropType<VNode[][]>, default: [] },\r\n    slideGroupHeight: { type: [String, Number], default: undefined },\r\n    slideGroupWidth: { type: [String, Number], default: undefined }\r\n  }\r\n} satisfies VuePropDef<keyof TrackProps>\r\n\r\nexport const defaultArrowProps = {\r\n  ...makeDefaultProps([\r\n    'centerMode',\r\n    'infinite',\r\n    'groupsToShow',\r\n    'prevArrowLabel',\r\n    'nextArrowLabel'\r\n  ]),\r\n  ...{\r\n    currentSlideGroupIndex: { type: Number, default: 0 },\r\n    disabled: { type: Boolean, default: false },\r\n    slideGroupCount: { type: Number, default: 0 },\r\n    type: { type: String as PropType<SlideNavigation>, default: 'prev' }\r\n  }\r\n} satisfies VuePropDef<keyof ArrowProps>\r\n\r\nexport const defaultDotsProps = {\r\n  ...makeDefaultProps([\r\n    'dotsClass',\r\n    'infinite',\r\n    'groupsToScroll',\r\n    'groupsToShow'\r\n  ]),\r\n  ...{\r\n    currentSlideGroupIndex: { type: Number, default: 0 },\r\n    slideGroupCount: { type: Number, default: 0 },\r\n    pageCount: { type: Number, default: 0 }\r\n  }\r\n} satisfies VuePropDef<keyof DotsProps>\r\n", "/**\r\n * Delegate to handle a media query being matched and unmatched.\r\n *\r\n * @param {object} options\r\n * @param {function} options.match callback for when the media query is matched\r\n * @param {function} [options.unmatch] callback for when the media query is unmatched\r\n * @param {function} [options.setup] one-time callback triggered the first time a query is matched\r\n * @param {boolean} [options.deferSetup=false] should the setup callback be run immediately, rather than first time query is matched?\r\n * @constructor\r\n */\r\nfunction QueryHandler(options) {\r\n    this.options = options;\r\n    !options.deferSetup && this.setup();\r\n}\r\n\r\nQueryHandler.prototype = {\r\n\r\n    constructor : QueryHandler,\r\n\r\n    /**\r\n     * coordinates setup of the handler\r\n     *\r\n     * @function\r\n     */\r\n    setup : function() {\r\n        if(this.options.setup) {\r\n            this.options.setup();\r\n        }\r\n        this.initialised = true;\r\n    },\r\n\r\n    /**\r\n     * coordinates setup and triggering of the handler\r\n     *\r\n     * @function\r\n     */\r\n    on : function() {\r\n        !this.initialised && this.setup();\r\n        this.options.match && this.options.match();\r\n    },\r\n\r\n    /**\r\n     * coordinates the unmatch event for the handler\r\n     *\r\n     * @function\r\n     */\r\n    off : function() {\r\n        this.options.unmatch && this.options.unmatch();\r\n    },\r\n\r\n    /**\r\n     * called when a handler is to be destroyed.\r\n     * delegates to the destroy or unmatch callbacks, depending on availability.\r\n     *\r\n     * @function\r\n     */\r\n    destroy : function() {\r\n        this.options.destroy ? this.options.destroy() : this.off();\r\n    },\r\n\r\n    /**\r\n     * determines equality by reference.\r\n     * if object is supplied compare options, if function, compare match callback\r\n     *\r\n     * @function\r\n     * @param {object || function} [target] the target for comparison\r\n     */\r\n    equals : function(target) {\r\n        return this.options === target || this.options.match === target;\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = QueryHandler;\r\n", "/**\r\n * Helper function for iterating over a collection\r\n *\r\n * @param collection\r\n * @param fn\r\n */\r\nfunction each(collection, fn) {\r\n    var i      = 0,\r\n        length = collection.length,\r\n        cont;\r\n\r\n    for(i; i < length; i++) {\r\n        cont = fn(collection[i], i);\r\n        if(cont === false) {\r\n            break; //allow early exit\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Helper function for determining whether target object is an array\r\n *\r\n * @param target the object under test\r\n * @return {Boolean} true if array, false otherwise\r\n */\r\nfunction isArray(target) {\r\n    return Object.prototype.toString.apply(target) === '[object Array]';\r\n}\r\n\r\n/**\r\n * Helper function for determining whether target object is a function\r\n *\r\n * @param target the object under test\r\n * @return {Boolean} true if function, false otherwise\r\n */\r\nfunction isFunction(target) {\r\n    return typeof target === 'function';\r\n}\r\n\r\nmodule.exports = {\r\n    isFunction : isFunction,\r\n    isArray : isArray,\r\n    each : each\r\n};\r\n", "var QueryHandler = require('./QueryHandler');\r\nvar each = require('./Util').each;\r\n\r\n/**\r\n * Represents a single media query, manages it's state and registered handlers for this query\r\n *\r\n * @constructor\r\n * @param {string} query the media query string\r\n * @param {boolean} [isUnconditional=false] whether the media query should run regardless of whether the conditions are met. Primarily for helping older browsers deal with mobile-first design\r\n */\r\nfunction MediaQuery(query, isUnconditional) {\r\n    this.query = query;\r\n    this.isUnconditional = isUnconditional;\r\n    this.handlers = [];\r\n    this.mql = window?.matchMedia(query);\r\n\r\n    var self = this;\r\n    this.listener = function(mql) {\r\n        // Chrome passes an MediaQueryListEvent object, while other browsers pass MediaQueryList directly\r\n        self.mql = mql.currentTarget || mql;\r\n        self.assess();\r\n    };\r\n    this.mql.addListener(this.listener);\r\n}\r\n\r\nMediaQuery.prototype = {\r\n\r\n    constuctor : MediaQuery,\r\n\r\n    /**\r\n     * add a handler for this query, triggering if already active\r\n     *\r\n     * @param {object} handler\r\n     * @param {function} handler.match callback for when query is activated\r\n     * @param {function} [handler.unmatch] callback for when query is deactivated\r\n     * @param {function} [handler.setup] callback for immediate execution when a query handler is registered\r\n     * @param {boolean} [handler.deferSetup=false] should the setup callback be deferred until the first time the handler is matched?\r\n     */\r\n    addHandler : function(handler) {\r\n        var qh = new QueryHandler(handler);\r\n        this.handlers.push(qh);\r\n\r\n        this.matches() && qh.on();\r\n    },\r\n\r\n    /**\r\n     * removes the given handler from the collection, and calls it's destroy methods\r\n     *\r\n     * @param {object || function} handler the handler to remove\r\n     */\r\n    removeHandler : function(handler) {\r\n        var handlers = this.handlers;\r\n        each(handlers, function(h, i) {\r\n            if(h.equals(handler)) {\r\n                h.destroy();\r\n                return !handlers.splice(i,1); //remove from array and exit each early\r\n            }\r\n        });\r\n    },\r\n\r\n    /**\r\n     * Determine whether the media query should be considered a match\r\n     *\r\n     * @return {Boolean} true if media query can be considered a match, false otherwise\r\n     */\r\n    matches : function() {\r\n        return this.mql.matches || this.isUnconditional;\r\n    },\r\n\r\n    /**\r\n     * Clears all handlers and unbinds events\r\n     */\r\n    clear : function() {\r\n        each(this.handlers, function(handler) {\r\n            handler.destroy();\r\n        });\r\n        this.mql.removeListener(this.listener);\r\n        this.handlers.length = 0; //clear array\r\n    },\r\n\r\n    /*\r\n        * Assesses the query, turning on all handlers if it matches, turning them off if it doesn't match\r\n        */\r\n    assess : function() {\r\n        var action = this.matches() ? 'on' : 'off';\r\n\r\n        each(this.handlers, function(handler) {\r\n            handler[action]();\r\n        });\r\n    }\r\n};\r\n\r\nmodule.exports = MediaQuery;\r\n", "var MediaQuery = require('./MediaQuery');\r\nvar Util = require('./Util');\r\nvar each = Util.each;\r\nvar isFunction = Util.isFunction;\r\nvar isArray = Util.isArray;\r\n\r\n/**\r\n * Allows for registration of query handlers.\r\n * Manages the query handler's state and is responsible for wiring up browser events\r\n *\r\n * @constructor\r\n */\r\nfunction MediaQueryDispatch () {\r\n    if(typeof window !== 'undefined' && !window.matchMedia) {\r\n        throw new Error('matchMedia not present, legacy browsers require a polyfill');\r\n    }\r\n\r\n    this.queries = {};\r\n    if (typeof window !== 'undefined') {\r\n        this.browserIsIncapable = !window.matchMedia('only all').matches;\r\n    }\r\n}\r\n\r\nMediaQueryDispatch.prototype = {\r\n\r\n    constructor : MediaQueryDispatch,\r\n\r\n    /**\r\n     * Registers a handler for the given media query\r\n     *\r\n     * @param {string} q the media query\r\n     * @param {object || Array || Function} options either a single query handler object, a function, or an array of query handlers\r\n     * @param {function} options.match fired when query matched\r\n     * @param {function} [options.unmatch] fired when a query is no longer matched\r\n     * @param {function} [options.setup] fired when handler first triggered\r\n     * @param {boolean} [options.deferSetup=false] whether setup should be run immediately or deferred until query is first matched\r\n     * @param {boolean} [shouldDegrade=false] whether this particular media query should always run on incapable browsers\r\n     */\r\n    register : function(q, options, shouldDegrade) {\r\n        var queries         = this.queries,\r\n            isUnconditional = shouldDegrade && this.browserIsIncapable;\r\n\r\n        if(!queries[q]) {\r\n            queries[q] = new MediaQuery(q, isUnconditional);\r\n        }\r\n\r\n        //normalise to object in an array\r\n        if(isFunction(options)) {\r\n            options = { match : options };\r\n        }\r\n        if(!isArray(options)) {\r\n            options = [options];\r\n        }\r\n        each(options, function(handler) {\r\n            if (isFunction(handler)) {\r\n                handler = { match : handler };\r\n            }\r\n            queries[q].addHandler(handler);\r\n        });\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * unregisters a query and all it's handlers, or a specific handler for a query\r\n     *\r\n     * @param {string} q the media query to target\r\n     * @param {object || function} [handler] specific handler to unregister\r\n     */\r\n    unregister : function(q, handler) {\r\n        var query = this.queries[q];\r\n\r\n        if(query) {\r\n            if(handler) {\r\n                query.removeHandler(handler);\r\n            }\r\n            else {\r\n                query.clear();\r\n                delete this.queries[q];\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n};\r\n\r\nmodule.exports = MediaQueryDispatch;\r\n", "var MediaQueryDispatch = require('./MediaQueryDispatch');\r\nmodule.exports = new MediaQueryDispatch();\r\n", "var camel2hyphen = function (str) {\n  return str\n          .replace(/[A-Z]/g, function (match) {\n            return '-' + match.toLowerCase();\n          })\n          .toLowerCase();\n};\n\nmodule.exports = camel2hyphen;", "var camel2hyphen = require('string-convert/camel2hyphen');\n\nvar isDimension = function (feature) {\n  var re = /[height|width]$/;\n  return re.test(feature);\n};\n\nvar obj2mq = function (obj) {\n  var mq = '';\n  var features = Object.keys(obj);\n  features.forEach(function (feature, index) {\n    var value = obj[feature];\n    feature = camel2hyphen(feature);\n    // Add px to dimension features\n    if (isDimension(feature) && typeof value === 'number') {\n      value = value + 'px';\n    }\n    if (value === true) {\n      mq += feature;\n    } else if (value === false) {\n      mq += 'not ' + feature;\n    } else {\n      mq += '(' + feature + ': ' + value + ')';\n    }\n    if (index < features.length-1) {\n      mq += ' and '\n    }\n  });\n  return mq;\n};\n\nvar json2mq = function (query) {\n  var mq = '';\n  if (typeof query === 'string') {\n    return query;\n  }\n  // Handling array of media queries\n  if (query instanceof Array) {\n    query.forEach(function (q, index) {\n      mq += obj2mq(q);\n      if (index < query.length-1) {\n        mq += ', '\n      }\n    });\n    return mq;\n  }\n  // Handling single media query\n  return obj2mq(query);\n};\n\nmodule.exports = json2mq;", "<template>\r\n  <template v-if=\"type === SlideNavigation.previous\">\r\n    <slot name=\"prevArrow\" v-bind=\"arrowSlotProps\">\r\n      <button\r\n        type=\"button\"\r\n        data-role=\"none\"\r\n        class=\"v-slick-arrow prev\"\r\n        :class=\"{ disabled }\"\r\n        @click=\"clickHandler\"\r\n      >\r\n        {{ prevArrowLabel }}\r\n      </button>\r\n    </slot>\r\n  </template>\r\n  <template v-else>\r\n    <slot name=\"nextArrow\" v-bind=\"arrowSlotProps\">\r\n      <button\r\n        type=\"button\"\r\n        data-role=\"none\"\r\n        class=\"v-slick-arrow next\"\r\n        :class=\"{ disabled }\"\r\n        @click=\"clickHandler\"\r\n      >\r\n        {{ nextArrowLabel }}\r\n      </button>\r\n    </slot>\r\n  </template>\r\n</template>\r\n<script setup lang=\"ts\">\r\nimport { ArrowSlotProps, SlideNavigation } from '@lib/types'\r\nimport { computed } from 'vue'\r\nimport { defaultArrowProps } from './props'\r\n\r\nconst props = defineProps(defaultArrowProps)\r\nconst emit = defineEmits([SlideNavigation.previous, SlideNavigation.next])\r\nconst clickHandler = computed(() => () => {\r\n  if (props.disabled) return\r\n  emit(props.type)\r\n})\r\nconst arrowSlotProps = computed<ArrowSlotProps>(() => ({\r\n  currentSlideGroupIndex: props.currentSlideGroupIndex,\r\n  slideGroupCount: props.slideGroupCount,\r\n  onClick: clickHandler.value,\r\n  disabled: !props.disabled\r\n}))\r\n</script>\r\n<style scoped>\r\n.v-slick-arrow {\r\n  display: block;\r\n}\r\n</style>\r\n", "<template>\r\n  <div\r\n    class=\"v-slick-track\"\r\n    :class=\"{ center: centerMode, vertical: vertical }\"\r\n    :style=\"[trackStyle, detectingWidth ? { width: '0 !important' } : {}]\"\r\n  >\r\n    <div\r\n      v-for=\"(slideGroup, i) in preCloneSlideGroups\"\r\n      :key=\"slideGroup.key\"\r\n      tabindex=\"-1\"\r\n      :class=\"slideGroup.class\"\r\n      :style=\"slideGroup.style\"\r\n      class=\"v-slick-slide-group clone\"\r\n      v-bind=\"slideGroup.attrs\"\r\n      @click=\"slideGroup.onClick\"\r\n    >\r\n      <component\r\n        :is=\"slide\"\r\n        v-for=\"(slide, j) of slideGroup.slides\"\r\n        :key=\"`slide-${i}-${j}` + (slide.key ? `-${String(slide.key)}` : '')\"\r\n      />\r\n    </div>\r\n    <div\r\n      v-for=\"(slideGroup, i) in originalSlideGroups\"\r\n      :key=\"slideGroup.key\"\r\n      tabindex=\"-1\"\r\n      class=\"v-slick-slide-group\"\r\n      :class=\"slideGroup.class\"\r\n      :style=\"slideGroup.style\"\r\n      v-bind=\"slideGroup.attrs\"\r\n      @click=\"slideGroup.onClick\"\r\n    >\r\n      <component\r\n        :is=\"slide\"\r\n        v-for=\"(slide, j) of slideGroup.slides\"\r\n        :key=\"`slide-${i}-${j}` + (slide.key ? `-${String(slide.key)}` : '')\"\r\n      />\r\n    </div>\r\n    <div\r\n      v-for=\"(slideGroup, i) in postCloneSlideGroups\"\r\n      :key=\"slideGroup.key\"\r\n      tabindex=\"-1\"\r\n      :class=\"slideGroup.class\"\r\n      :style=\"slideGroup.style\"\r\n      class=\"v-slick-slide-group clone\"\r\n      v-bind=\"slideGroup.attrs\"\r\n      @click=\"slideGroup.onClick\"\r\n    >\r\n      <component\r\n        :is=\"slide\"\r\n        v-for=\"(slide, j) of slideGroup.slides\"\r\n        :key=\"`slide-${i}-${j}` + (slide.key ? `-${String(slide.key)}` : '')\"\r\n      />\r\n    </div>\r\n  </div>\r\n</template>\r\n\r\n<script setup lang=\"ts\">\r\nimport { computed } from 'vue'\r\nimport { defaultTrackProps } from './props'\r\nimport {\r\n  ChildClickPayload,\r\n  CloneInfoSpec,\r\n  LazyInfoSpec,\r\n  SlideGroup,\r\n  TrackProps\r\n} from '@lib/types'\r\nimport {\r\n  getLazyEndIndex,\r\n  getLazyStartIndex,\r\n  getTotalPreClones\r\n} from '@lib/utils'\r\n\r\nconst props = defineProps(defaultTrackProps) as TrackProps\r\nconst emit = defineEmits<{\r\n  childClick: [payload: ChildClickPayload]\r\n}>()\r\n\r\nconst getSlideGroupClasses = (index: number) => {\r\n  let isActive = false,\r\n    isCenter = false,\r\n    isCurrent = false,\r\n    centerOffset: number\r\n  if (props.centerMode) {\r\n    centerOffset = Math.floor(props.groupsToShow / 2)\r\n    isCenter =\r\n      (index - props.currentSlideGroupIndex) % props.slideGroupCount === 0\r\n    if (\r\n      index > props.currentSlideGroupIndex - centerOffset - 1 &&\r\n      index <= props.currentSlideGroupIndex + centerOffset\r\n    ) {\r\n      isActive = true\r\n    }\r\n  } else {\r\n    isActive =\r\n      props.currentSlideGroupIndex <= index &&\r\n      index < props.currentSlideGroupIndex + props.groupsToShow\r\n  }\r\n  isCurrent = index === props.currentSlideGroupIndex\r\n  return Object.entries({\r\n    active: isActive,\r\n    center: isCenter,\r\n    current: isCurrent\r\n  })\r\n    .filter(([, value]) => value)\r\n    .map(([key]) => key)\r\n}\r\n\r\nconst getSlideGroupStyle = (index: number) => {\r\n  let style: {\r\n    width?: string\r\n    position?: string\r\n    top?: string\r\n    left?: string\r\n    opacity?: number\r\n    transition?: string\r\n  } = {}\r\n\r\n  if (props.variableWidth === undefined || props.variableWidth === false) {\r\n    style.width =\r\n      typeof props.slideGroupWidth === 'number'\r\n        ? `${props.slideGroupWidth}px`\r\n        : props.slideGroupWidth\r\n  }\r\n\r\n  if (props.fade) {\r\n    style.position = 'relative'\r\n    if (props.vertical) {\r\n      const slideGroupHeight = !props.slideGroupHeight\r\n        ? 0\r\n        : typeof props.slideGroupHeight === 'string'\r\n          ? parseFloat(props.slideGroupHeight)\r\n          : props.slideGroupHeight\r\n      style.top = `${-index * slideGroupHeight}px`\r\n    } else {\r\n      const slideGroupWidth = !props.slideGroupWidth\r\n        ? 0\r\n        : typeof props.slideGroupWidth === 'string'\r\n          ? parseFloat(props.slideGroupWidth)\r\n          : props.slideGroupWidth\r\n\r\n      const left = props.rtl\r\n        ? index * slideGroupWidth\r\n        : -index * slideGroupWidth\r\n      style.left = `${left}px`\r\n    }\r\n    style.opacity = props.currentSlideGroupIndex === index ? 1 : 0\r\n    style.transition =\r\n      'opacity ' +\r\n      props.speed +\r\n      'ms ' +\r\n      props.cssEase +\r\n      ', ' +\r\n      'visibility ' +\r\n      props.speed +\r\n      'ms ' +\r\n      props.cssEase\r\n    if (props.ignorePrefersReducedMotion) {\r\n      style.transition += ' !important'\r\n    }\r\n  }\r\n\r\n  return style\r\n}\r\n\r\nconst originalSlideGroups = computed<SlideGroup[]>(() => {\r\n  const slideGroups = props.rawSlideGroups.map((rawSlideGroup, index) => {\r\n    const style = getSlideGroupStyle(index)\r\n    const classes = getSlideGroupClasses(index)\r\n    if (props.fade && classes.includes('active')) {\r\n      Object.assign(style, { zIndex: 1 })\r\n    }\r\n    const slideGroup: SlideGroup = {\r\n      slides: [],\r\n      key: `original-${index}`,\r\n      class: classes,\r\n      style,\r\n      attrs: {\r\n        'data-index': index,\r\n        'aria-hidden': `${!classes.includes('active')}`\r\n      },\r\n      onClick: () => {\r\n        emit('childClick', {\r\n          index:\r\n            props.rtl && props.infinite ? props.slideGroupCount + index : index\r\n        })\r\n      }\r\n    }\r\n    if (\r\n      !props.lazyLoad ||\r\n      (props.lazyLoad && props.lazyLoadedList.indexOf(index) >= 0)\r\n    ) {\r\n      slideGroup.slides = rawSlideGroup\r\n    }\r\n    return slideGroup\r\n  })\r\n  // return props.rtl ? slideGroups.reverse() : slideGroups\r\n  return slideGroups\r\n})\r\n\r\nconst preCloneSlideGroups = computed<SlideGroup[]>(() => {\r\n  if (\r\n    !props.infinite ||\r\n    props.fade ||\r\n    props.slideGroupCount <= props.groupsToShow\r\n  ) {\r\n    return []\r\n  }\r\n  const slideGroups = props.rawSlideGroups\r\n    .map((rawSlideGroup, index) => {\r\n      const preCloneNo = props.slideGroupCount - index\r\n      if (preCloneNo > getTotalPreClones(props as CloneInfoSpec)) return\r\n      const key = -preCloneNo\r\n      const slideGroup: SlideGroup = {\r\n        slides: [],\r\n        key: `preclone-${key}`,\r\n        class: getSlideGroupClasses(key),\r\n        style: getSlideGroupStyle(index),\r\n        attrs: {\r\n          'data-index': key,\r\n          'aria-hidden': 'true'\r\n        },\r\n        onClick: () => {\r\n          emit('childClick', {\r\n            index: key\r\n          })\r\n        }\r\n      }\r\n      if (\r\n        key >= getLazyStartIndex(props as LazyInfoSpec) ||\r\n        !props.lazyLoad ||\r\n        (props.lazyLoad && props.lazyLoadedList.indexOf(index) >= 0)\r\n      ) {\r\n        slideGroup.slides = rawSlideGroup\r\n      }\r\n      return slideGroup\r\n    })\r\n    .filter((slideGroup) => slideGroup) as SlideGroup[]\r\n  // return props.rtl ? slideGroups.reverse() : slideGroups\r\n  return slideGroups\r\n})\r\n\r\nconst postCloneSlideGroups = computed<SlideGroup[]>(() => {\r\n  if (\r\n    !props.infinite ||\r\n    props.fade ||\r\n    props.slideGroupCount <= props.groupsToShow\r\n  ) {\r\n    return []\r\n  }\r\n  const slideGroups = props.rawSlideGroups.map((rawSlideGroup, index) => {\r\n    const key = props.slideGroupCount + index\r\n    const slideGroup: SlideGroup = {\r\n      slides: [],\r\n      key: `postclone-${key}`,\r\n      class: getSlideGroupClasses(key),\r\n      style: getSlideGroupStyle(index),\r\n      attrs: {\r\n        'data-index': key,\r\n        'aria-hidden':\r\n          props.infinite &&\r\n          props.slideGroupCount - props.currentSlideGroupIndex <\r\n            props.groupsToShow &&\r\n          index <\r\n            props.groupsToShow -\r\n              (props.slideGroupCount - props.currentSlideGroupIndex)\r\n            ? 'false'\r\n            : 'true'\r\n      },\r\n      onClick: () => {\r\n        emit('childClick', {\r\n          index: props.rtl ? props.slideGroupCount + key : key\r\n        })\r\n      }\r\n    }\r\n    if (\r\n      key < getLazyEndIndex(props as LazyInfoSpec) ||\r\n      !props.lazyLoad ||\r\n      (props.lazyLoad && props.lazyLoadedList.indexOf(index) >= 0)\r\n    ) {\r\n      slideGroup.slides = rawSlideGroup\r\n    }\r\n    return slideGroup\r\n  })\r\n  // return props.rtl ? slideGroups.reverse() : slideGroups\r\n  return slideGroups\r\n})\r\n</script>\r\n\r\n<style scoped lang=\"scss\">\r\n.v-slick-track {\r\n  position: relative;\r\n  top: 0;\r\n  left: 0;\r\n  display: flex;\r\n  transform: translate3d(0, 0, 0);\r\n  &.center {\r\n    margin-left: auto;\r\n    margin-right: auto;\r\n  }\r\n  &.vertical {\r\n    flex-direction: column;\r\n    .v-slick-slide-group {\r\n      flex-direction: row;\r\n      height: auto;\r\n      & > * {\r\n        flex-grow: 1;\r\n      }\r\n    }\r\n  }\r\n  &.dragging img {\r\n    pointer-events: none;\r\n  }\r\n}\r\n.v-slick-slide-group {\r\n  display: flex;\r\n  flex-direction: column;\r\n  height: 100%;\r\n  min-height: 1px;\r\n  flex-shrink: 0;\r\n  outline: none;\r\n}\r\n</style>\r\n", "<template>\r\n  <ul\r\n    :class=\"dotsClass\"\r\n    style=\"display: block\"\r\n    @mouseenter=\"$emit('dotsLeave')\"\r\n    @mouseleave=\"$emit('dotsLeave')\"\r\n    @mouseover=\"$emit('dotsOver')\"\r\n  >\r\n    <li\r\n      v-for=\"i in pageCount\"\r\n      :key=\"i\"\r\n      :class=\"{ active: isActive(i - 1) }\"\r\n      @click=\"\r\n        $emit('dotClick', {\r\n          index: i - 1,\r\n          groupsToScroll\r\n        })\r\n      \"\r\n    >\r\n      <slot name=\"customPaging\" :page=\"i - 1\">\r\n        <button>{{ i }}</button>\r\n      </slot>\r\n    </li>\r\n  </ul>\r\n</template>\r\n<script setup lang=\"ts\">\r\nimport { DotClickPayload } from '@lib/types'\r\nimport { defaultDotsProps } from './props'\r\ndefineEmits<{\r\n  dotClick: [payload: DotClickPayload]\r\n  dotsOver: []\r\n  dotsLeave: []\r\n}>()\r\nconst props = defineProps(defaultDotsProps)\r\nconst isActive = (i: number) => {\r\n  const leftBound = i * props.groupsToScroll\r\n  const rightBound = leftBound + props.groupsToScroll - 1\r\n  return (\r\n    props.currentSlideGroupIndex >= leftBound &&\r\n    props.currentSlideGroupIndex <= rightBound\r\n  )\r\n}\r\n</script>\r\n", "/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        result = wait - timeSinceLastCall;\n\n    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = debounce;\n", "<template>\r\n  <div\r\n    ref=\"vSlickCarouselRef\"\r\n    class=\"v-slick-carousel\"\r\n    :style=\"\r\n      widthDetection === WidthDetection.manual\r\n        ? state.detectingWidth\r\n          ? { width: '100%' }\r\n          : vSlickCarouselStyle\r\n        : {}\r\n    \"\r\n  >\r\n    <div class=\"v-slick-slider\" :dir=\"settings.rtl ? 'rtl' : 'ltr'\">\r\n      <VSlickArrow\r\n        v-if=\"settings.arrows\"\r\n        :type=\"SlideNavigation.previous\"\r\n        :center-mode=\"settings.centerMode\"\r\n        :infinite=\"settings.infinite\"\r\n        :groups-to-show=\"settings.groupsToShow\"\r\n        :slide-group-count=\"slideGroupCount\"\r\n        :current-slide-group-index=\"state.currentSlideGroupIndex\"\r\n        :disabled=\"!canGoPrev\"\r\n        @previous=\"handlePrevVSlickArrow\"\r\n      >\r\n        <template #prevArrow=\"arrowSlotProps\">\r\n          <slot name=\"prevArrow\" v-bind=\"arrowSlotProps\" />\r\n        </template>\r\n      </VSlickArrow>\r\n      <div\r\n        ref=\"vSlickListRef\"\r\n        class=\"v-slick-list\"\r\n        :class=\"{ dragging: state.dragging }\"\r\n        :style=\"vSlickListStyle\"\r\n        @click=\"handleClickVSlickList\"\r\n        @mousedown=\"handleMouseDownOrTouchStartVSlickList\"\r\n        @touchstart.passive=\"handleMouseDownOrTouchStartVSlickList\"\r\n        @keydown=\"handleKeyDownVSlickList\"\r\n      >\r\n        <VSlickTrack\r\n          ref=\"vSlickTrackRef\"\r\n          :center-mode=\"settings.centerMode\"\r\n          :center-padding=\"settings.centerPadding\"\r\n          :raw-slide-groups=\"rawSlideGroups\"\r\n          :css-ease=\"cssEase\"\r\n          :current-slide-group-index=\"state.currentSlideGroupIndex\"\r\n          :detecting-width=\"state.detectingWidth\"\r\n          :fade=\"settings.fade\"\r\n          :ignore-prefers-reduced-motion=\"settings.ignorePrefersReducedMotion\"\r\n          :infinite=\"settings.infinite\"\r\n          :lazy-load=\"settings.lazyLoad\"\r\n          :lazy-loaded-list=\"state.lazyLoadedList\"\r\n          :list-height=\"state.listHeight\"\r\n          :rtl=\"settings.rtl\"\r\n          :slide-group-count=\"slideGroupCount\"\r\n          :slide-group-height=\"state.slideGroupHeight\"\r\n          :slide-group-width=\"state.slideGroupWidth\"\r\n          :groups-to-scroll=\"settings.groupsToScroll\"\r\n          :groups-to-show=\"settings.groupsToShow\"\r\n          :speed=\"settings.speed\"\r\n          :track-style=\"state.trackStyle\"\r\n          :variable-width=\"settings.variableWidth\"\r\n          :vertical=\"settings.vertical\"\r\n          @mouseenter=\"handleMouseEnterOrOverVSlickTrack\"\r\n          @mouseleave=\"handleMouseLeaveVSlickTrack\"\r\n          @mouseover=\"handleMouseEnterOrOverVSlickTrack\"\r\n          @child-click=\"handleChildClickVSlickTrack\"\r\n        />\r\n      </div>\r\n      <VSlickArrow\r\n        v-if=\"settings.arrows\"\r\n        :type=\"SlideNavigation.next\"\r\n        :center-mode=\"settings.centerMode\"\r\n        :infinite=\"settings.infinite\"\r\n        :groups-to-show=\"settings.groupsToShow\"\r\n        :slide-group-count=\"slideGroupCount\"\r\n        :current-slide-group-index=\"state.currentSlideGroupIndex\"\r\n        :disabled=\"!canGoNext\"\r\n        @next=\"handleNextVSlickArrow\"\r\n      >\r\n        <template #nextArrow=\"arrowSlotProps\">\r\n          <slot name=\"nextArrow\" v-bind=\"arrowSlotProps\" />\r\n        </template>\r\n      </VSlickArrow>\r\n    </div>\r\n    <VSlickDots\r\n      v-if=\"settings.dots\"\r\n      :current-slide-group-index=\"state.currentSlideGroupIndex\"\r\n      :infinite=\"settings.infinite\"\r\n      :slide-group-count=\"slideGroupCount\"\r\n      :groups-to-scroll=\"settings.groupsToScroll\"\r\n      :groups-to-show=\"settings.groupsToShow\"\r\n      :dots-class=\"settings.dotsClass\"\r\n      :page-count=\"pageCount\"\r\n      @dot-click=\"handleClickDot\"\r\n      @dots-over=\"handleOverDots\"\r\n      @dots-leave=\"handleLeaveDots\"\r\n    >\r\n      <template #customPaging=\"paging\">\r\n        <slot name=\"customPaging\" v-bind=\"paging\" />\r\n      </template>\r\n    </VSlickDots>\r\n  </div>\r\n</template>\r\n\r\n<script setup lang=\"ts\">\r\nimport {\r\n  ref,\r\n  computed,\r\n  watch,\r\n  VNode,\r\n  useSlots,\r\n  getCurrentInstance,\r\n  onMounted,\r\n  onBeforeUnmount,\r\n  onUpdated\r\n} from 'vue'\r\nimport {\r\n  ChildClickPayload,\r\n  DotClickPayload,\r\n  LazyLoadType,\r\n  PlayingType,\r\n  Props,\r\n  SwipeDirection,\r\n  SwipeEndSpec,\r\n  SwipeMoveSpec,\r\n  TrackInfoSpec,\r\n  VSlickCarouselInstance,\r\n  SwipeEvent,\r\n  SlideNavigation,\r\n  SlideGroupChangeOptions,\r\n  SlideGroupChangeSpec,\r\n  OnSlideSpec,\r\n  WidthDetection\r\n} from '@lib/types'\r\nimport {\r\n  canUseDOM,\r\n  clearSelection,\r\n  filterUndefined,\r\n  getChangedSlideGroupIndex\r\n} from '@lib/utils'\r\nimport {\r\n  defaultPropValues,\r\n  defaultProps,\r\n  makeDefaultSliderState\r\n} from './props'\r\nimport enquireJs from '@dcufo/enquire.js'\r\nimport json2mq from 'json2mq'\r\nimport VSlickArrow from './VSlickArrow.vue'\r\nimport VSlickTrack from './VSlickTrack.vue'\r\nimport VSlickDots from './VSlickDots.vue'\r\nimport debounce from 'lodash.debounce'\r\nimport {\r\n  canGoNext as checkCanGoNext,\r\n  canGoPrev as checkCanGoPrev,\r\n  extractSlides,\r\n  getNavigationOnKeyType,\r\n  getOnDemandLazySlideGroups,\r\n  getSlideGroupCount,\r\n  getSliderState,\r\n  getStatesOnSlide,\r\n  getSwipeEndState,\r\n  getSwipeMoveState,\r\n  getSwipeStartState,\r\n  getTotalPostClones,\r\n  getTotalPreClones,\r\n  getTrackCSS,\r\n  getTrackLeft\r\n} from '@lib/utils/carousel-utils'\r\n\r\nconst props = defineProps(defaultProps) as Props\r\ndefineOptions({ inheritAttrs: false })\r\n\r\nconst emit = defineEmits([\r\n  'init',\r\n  'beforeChange',\r\n  'afterChange',\r\n  'lazyLoad',\r\n  'lazyLoadError',\r\n  'reInit',\r\n  'edge',\r\n  'swipe'\r\n])\r\n\r\nconst slots = useSlots()\r\nconst enquire = canUseDOM() ? enquireJs : undefined\r\n\r\nconst DEBOUNCE_RESIZE_DURATION = 50\r\n\r\nlet triggerSlideGroupHandler: number | undefined\r\nlet animationEndCallback: NodeJS.Timeout | null = null\r\nlet lazyLoadTimer: NodeJS.Timeout | null = null\r\nlet callbackTimers: NodeJS.Timeout[] = []\r\n\r\nconst vSlickListStyle = ref({\r\n  ...(getCurrentInstance()?.vnode?.props?.style || {})\r\n})\r\n\r\nlet isVSlickListClickable = true\r\nlet debouncedResize: ReturnType<typeof debounce> | null = null\r\nlet ro: ResizeObserver | null = null\r\n\r\nlet responsiveMediaHandlers: {\r\n  query: string\r\n  handler: () => void\r\n}[] = []\r\n\r\nconst media = (query: string, handler: () => void) => {\r\n  if (!enquire) return\r\n\r\n  enquire.register(query, handler)\r\n  responsiveMediaHandlers.push({ query, handler })\r\n}\r\n\r\nconst clearBreakpoints = () => {\r\n  responsiveMediaHandlers.forEach(({ query, handler }) =>\r\n    enquire?.unregister(query, handler)\r\n  )\r\n  responsiveMediaHandlers = []\r\n}\r\n\r\nconst makeBreakpoints = () => {\r\n  if (!props.responsive.length) return\r\n  const breakpoints = props.responsive.map((item) => item.breakpoint)\r\n  breakpoints.sort((a, b) => a - b)\r\n  breakpoints.forEach((_breakpoint, index) => {\r\n    const mediaQuery = json2mq({\r\n      minWidth: index === 0 ? 0 : breakpoints[index - 1] + 1,\r\n      maxWidth: _breakpoint\r\n    })\r\n    media(mediaQuery, () => {\r\n      breakpoint.value = _breakpoint\r\n    })\r\n  })\r\n  const query = json2mq({\r\n    minWidth: breakpoints.slice(-1)[0]\r\n  })\r\n  media(query, () => {\r\n    breakpoint.value = undefined\r\n  })\r\n}\r\n\r\nconst swipeStart = (e: SwipeEvent) => {\r\n  const swipeStartState = getSwipeStartState(\r\n    e,\r\n    settings.value.swipe,\r\n    settings.value.draggable\r\n  )\r\n  Object.assign(state.value, swipeStartState)\r\n}\r\n\r\nconst swipeEnd = (e: SwipeEvent) => {\r\n  const swipeEndState = getSwipeEndState(e, {\r\n    ...settings.value,\r\n    ...state.value,\r\n    trackEl: vSlickTrackRef.value?.$el,\r\n    listEl: vSlickListRef.value,\r\n    slideGroupIndex: state.value.currentSlideGroupIndex,\r\n    slideGroupCount: slideGroupCount.value\r\n  } as SwipeEndSpec)\r\n  if (!swipeEndState) return\r\n  const { triggerSlideGroupHandler: newTriggerSlideGroupHandler, ...rest } =\r\n    swipeEndState\r\n  triggerSlideGroupHandler = newTriggerSlideGroupHandler\r\n  Object.assign(state.value, rest)\r\n  if (triggerSlideGroupHandler !== undefined) {\r\n    slideGroupHandler(triggerSlideGroupHandler)\r\n  }\r\n}\r\n\r\nconst swipeMove = (e: SwipeEvent) => {\r\n  clearSelection()\r\n  const swipeMoveState = getSwipeMoveState(e, {\r\n    ...props,\r\n    ...state.value,\r\n    trackEl: vSlickTrackRef.value?.$el,\r\n    listEl: vSlickListRef.value,\r\n    slideGroupIndex: state.value.currentSlideGroupIndex,\r\n    slideGroupCount: slideGroupCount.value,\r\n    onEdge: (e: SwipeDirection | keyof typeof SwipeDirection) =>\r\n      emit('edge', e),\r\n    swipeEvent: (e: SwipeDirection | keyof typeof SwipeDirection) =>\r\n      emit('swipe', e)\r\n  } as SwipeMoveSpec)\r\n  if (!swipeMoveState) return\r\n  if (swipeMoveState.swiping) {\r\n    isVSlickListClickable = false\r\n  }\r\n  Object.assign(state.value, swipeMoveState)\r\n}\r\n\r\nconst play = () => {\r\n  let nextIndex\r\n  if (settings.value.rtl) {\r\n    nextIndex =\r\n      state.value.currentSlideGroupIndex - settings.value.groupsToScroll\r\n  } else {\r\n    if (canGoNext.value) {\r\n      nextIndex =\r\n        state.value.currentSlideGroupIndex + settings.value.groupsToScroll\r\n    } else {\r\n      return false\r\n    }\r\n  }\r\n\r\n  slideGroupHandler(nextIndex)\r\n}\r\n\r\nconst pause = (\r\n  pauseType: null | PlayingType | keyof typeof PlayingType = null\r\n) => {\r\n  if (state.value.autoplayTimer) {\r\n    clearInterval(state.value.autoplayTimer)\r\n    state.value.autoplayTimer = null\r\n  }\r\n  const autoplaying = state.value.autoplaying\r\n  if (pauseType === PlayingType.paused) {\r\n    state.value.autoplaying = PlayingType.paused\r\n  } else if (\r\n    pauseType === PlayingType.focused &&\r\n    (autoplaying === PlayingType.hovered || autoplaying === PlayingType.playing)\r\n  ) {\r\n    state.value.autoplaying = PlayingType.focused\r\n  } else if (autoplaying === PlayingType.playing) {\r\n    state.value.autoplaying = PlayingType.hovered\r\n  } else if (autoplaying === null) {\r\n    state.value.autoplaying = null\r\n  }\r\n}\r\n\r\nconst autoPlay = (playType: PlayingType | keyof typeof PlayingType) => {\r\n  if (state.value.autoplayTimer) {\r\n    clearInterval(state.value.autoplayTimer)\r\n  }\r\n  const autoplaying = state.value.autoplaying\r\n  if (playType === PlayingType.update) {\r\n    if (\r\n      autoplaying === PlayingType.hovered ||\r\n      autoplaying === PlayingType.focused ||\r\n      autoplaying === PlayingType.paused\r\n    ) {\r\n      return\r\n    }\r\n  } else if (playType === PlayingType.leave) {\r\n    if (\r\n      autoplaying === PlayingType.paused ||\r\n      autoplaying === PlayingType.focused\r\n    ) {\r\n      return\r\n    }\r\n  } else if (playType === PlayingType.blur) {\r\n    if (\r\n      autoplaying === PlayingType.paused ||\r\n      autoplaying === PlayingType.hovered\r\n    ) {\r\n      return\r\n    }\r\n  }\r\n  state.value.autoplayTimer = setInterval(\r\n    play,\r\n    settings.value.autoplaySpeed + 50\r\n  )\r\n  state.value.autoplaying = PlayingType.playing\r\n}\r\n\r\nconst adaptHeight = () => {\r\n  if (settings.value.adaptiveHeight && vSlickListRef.value) {\r\n    const activeSlideGroups = vSlickListRef.value.querySelectorAll<HTMLElement>(\r\n      '.v-slick-slide-group.active'\r\n    )\r\n    let maxHeight = 0\r\n    activeSlideGroups.forEach((slideGroup) => {\r\n      maxHeight = Math.max(maxHeight, slideGroup.offsetHeight)\r\n    })\r\n    vSlickListRef.value.style.height = maxHeight + 'px'\r\n  }\r\n}\r\n\r\nconst onTrackOver = () => {\r\n  if (settings.value.autoplay) pause(PlayingType.hovered)\r\n}\r\n\r\nconst onTrackLeave = () => {\r\n  if (\r\n    settings.value.autoplay &&\r\n    state.value.autoplaying === PlayingType.hovered\r\n  )\r\n    autoPlay(PlayingType.leave)\r\n}\r\n\r\nconst handleClickVSlickList = (e: Event) => {\r\n  if (isVSlickListClickable === false) {\r\n    e.stopPropagation()\r\n    e.preventDefault()\r\n  }\r\n  isVSlickListClickable = true\r\n}\r\n\r\nconst handleChildClickVSlickTrack = ({ index }: ChildClickPayload) => {\r\n  if (!settings.value.focusOnSelect) return\r\n  changeSlideGroup({\r\n    message: 'children',\r\n    index\r\n  })\r\n}\r\n\r\nconst handleKeyDownVSlickList = (e: KeyboardEvent) => {\r\n  if (!settings.value.accessibility) return\r\n  const navigation = getNavigationOnKeyType(\r\n    e,\r\n    settings.value.accessibility,\r\n    settings.value.rtl\r\n  )\r\n  if (!navigation) return\r\n  changeSlideGroup({ message: navigation as SlideNavigation })\r\n}\r\n\r\nconst handleMouseDownOrTouchStartVSlickList = (e: SwipeEvent) => {\r\n  if (!settings.value.touchMove) return\r\n  const target = e.target as HTMLElement | null\r\n  if (target?.classList.contains('no-swipe')) return\r\n  swipeStart(e)\r\n}\r\n\r\nconst handleMouseMoveOrTouchMoveVSlickList = (e: SwipeEvent) => {\r\n  if (!state.value.dragging || !settings.value.touchMove) return\r\n  const target = e.target as HTMLElement | null\r\n  if (target?.classList.contains('no-swipe')) return\r\n  swipeMove(e)\r\n}\r\n\r\nconst handleMouseUpOrTouchEndVSlickList = (e: SwipeEvent) => {\r\n  if (!settings.value.touchMove) return\r\n  swipeEnd(e)\r\n}\r\n\r\nconst handleMouseLeaveOrTouchCancelVSlickList = (e: SwipeEvent) => {\r\n  if (!state.value.dragging || !settings.value.touchMove) return\r\n  swipeEnd(e)\r\n}\r\n\r\nconst handleMouseEnterOrOverVSlickTrack = () => {\r\n  if (!settings.value.pauseOnHover) return\r\n  onTrackOver()\r\n}\r\n\r\nconst handleMouseLeaveVSlickTrack = () => {\r\n  if (!settings.value.pauseOnHover) return\r\n  onTrackLeave()\r\n}\r\n\r\nconst handleOverDots = () => {\r\n  if (settings.value.pauseOnDotsHover && settings.value.autoplay)\r\n    pause(PlayingType.hovered)\r\n}\r\nconst handleLeaveDots = () => {\r\n  if (\r\n    settings.value.pauseOnDotsHover &&\r\n    settings.value.autoplay &&\r\n    state.value.autoplaying === PlayingType.hovered\r\n  )\r\n    autoPlay(PlayingType.leave)\r\n}\r\n\r\nconst handleClickDot = ({ index }: DotClickPayload) => {\r\n  changeSlideGroup({\r\n    message: 'dots',\r\n    index\r\n  })\r\n}\r\n\r\nconst handleNextVSlickArrow = () => {\r\n  changeSlideGroup({\r\n    message: SlideNavigation.next\r\n  })\r\n}\r\n\r\nconst handlePrevVSlickArrow = () => {\r\n  changeSlideGroup({\r\n    message: SlideNavigation.previous\r\n  })\r\n}\r\n\r\nconst changeSlideGroup = (\r\n  options: SlideGroupChangeOptions,\r\n  dontAnimate = false\r\n) => {\r\n  const spec = {\r\n    ...settings.value,\r\n    ...state.value,\r\n    slideGroupCount: slideGroupCount.value\r\n  }\r\n  const targetSlideGroupIndex = getChangedSlideGroupIndex(\r\n    spec as SlideGroupChangeSpec,\r\n    options\r\n  )\r\n  if (targetSlideGroupIndex === undefined || targetSlideGroupIndex === null)\r\n    return\r\n  slideGroupHandler(\r\n    targetSlideGroupIndex,\r\n    dontAnimate === true ? true : undefined\r\n  )\r\n}\r\n\r\nconst slideGroupHandler = async (index: number, dontAnimate = false) => {\r\n  const { asNavFor, speed } = settings.value\r\n  const currentSlideGroupIndex = state.value.currentSlideGroupIndex\r\n  const states = getStatesOnSlide({\r\n    index,\r\n    ...settings.value,\r\n    ...state.value,\r\n    slideGroupCount: slideGroupCount.value,\r\n    trackEl: vSlickTrackRef.value?.$el,\r\n    useCSSTransitions: settings.value.useCSSTransitions && !dontAnimate\r\n  } as OnSlideSpec)\r\n  if (!states) return\r\n  const { slidingState, afterSlidingState } = states\r\n  emit(\r\n    'beforeChange',\r\n    currentSlideGroupIndex,\r\n    slidingState.currentSlideGroupIndex\r\n  )\r\n  const slidesToLoad =\r\n    slidingState.lazyLoadedList?.filter(\r\n      (value: number) => state.value.lazyLoadedList.indexOf(value) < 0\r\n    ) || []\r\n  if (slidesToLoad.length) {\r\n    emit('lazyLoad', slidesToLoad)\r\n  }\r\n  Object.assign(state.value, slidingState)\r\n  if (asNavFor) {\r\n    ;(asNavFor as VSlickCarouselInstance).goTo(index)\r\n  }\r\n  if (!afterSlidingState) return\r\n  await new Promise<void>((resolve) => {\r\n    animationEndCallback = setTimeout(() => {\r\n      const { animating, ...firstBatch } = afterSlidingState!\r\n      if (\r\n        settings.value.waitForAnimate ||\r\n        state.value.currentSlideGroupIndex ===\r\n          slidingState.currentSlideGroupIndex\r\n      ) {\r\n        Object.assign(state.value, firstBatch)\r\n      }\r\n      callbackTimers.push(\r\n        setTimeout(() => {\r\n          state.value.animating = animating || false\r\n        })\r\n      )\r\n      emit('afterChange', slidingState.currentSlideGroupIndex)\r\n      animationEndCallback = null\r\n      resolve()\r\n    }, speed)\r\n  })\r\n}\r\n\r\nconst updateState = (shouldSetTrackStyle?: boolean) => {\r\n  const updatedState = getSliderState({\r\n    ...settings.value,\r\n    ...state.value,\r\n    listEl: vSlickListRef.value,\r\n    trackEl: vSlickTrackRef.value?.$el,\r\n    slides: slides.value\r\n  })\r\n  const spec: TrackInfoSpec = {\r\n    ...props,\r\n    ...state,\r\n    ...updatedState,\r\n    trackEl: vSlickTrackRef.value?.$el,\r\n    slideGroupCount: slideGroupCount.value\r\n  }\r\n  const targetLeft = getTrackLeft(spec as TrackInfoSpec)\r\n  const trackStyle = getTrackCSS(spec as TrackInfoSpec, targetLeft)\r\n  if (shouldSetTrackStyle || slideGroupCount.value !== spec.slideGroupCount) {\r\n    updatedState.trackStyle = trackStyle\r\n  }\r\n  Object.assign(state.value, updatedState)\r\n}\r\n\r\nconst resize = async (\r\n  options: { shouldSetTrackStyle?: boolean; isWindowResize?: boolean } = {\r\n    shouldSetTrackStyle: true\r\n  }\r\n) => {\r\n  if (!vSlickTrackRef.value || !vSlickTrackRef.value.$el) {\r\n    return\r\n  }\r\n  if (\r\n    settings.value.widthDetection === WidthDetection.manual &&\r\n    options.isWindowResize\r\n  ) {\r\n    await detectWidth()\r\n  }\r\n  updateState(\r\n    options.shouldSetTrackStyle ||\r\n      (settings.value.widthDetection === WidthDetection.manual &&\r\n        options.isWindowResize)\r\n  )\r\n  if (props.autoplay) {\r\n    autoPlay(PlayingType.update)\r\n  } else {\r\n    pause()\r\n  }\r\n}\r\n\r\nconst onResize = (options?: {\r\n  shouldSetTrackStyle?: boolean\r\n  isWindowResize?: boolean\r\n}) => {\r\n  debouncedResize?.cancel()\r\n  debouncedResize = debounce(() => resize(options), DEBOUNCE_RESIZE_DURATION)\r\n  debouncedResize()\r\n}\r\n\r\nconst onResizeEventListener = () =>\r\n  onResize({\r\n    isWindowResize: true\r\n  })\r\n\r\nconst onSlideGroupFocus = () => {\r\n  if (settings.value.autoplay) pause(PlayingType.focused)\r\n}\r\nconst onSlideGroupBlur = () => {\r\n  if (\r\n    settings.value.autoplay &&\r\n    state.value.autoplaying === PlayingType.focused\r\n  )\r\n    autoPlay(PlayingType.blur)\r\n}\r\n\r\nconst progressiveLazyLoad = () => {\r\n  const slideGroupsToLoad = []\r\n  const spec = { ...settings.value, ...state.value }\r\n  const totalPostClones = getTotalPostClones({\r\n    ...spec,\r\n    slideGroupCount: slideGroupCount.value\r\n  })\r\n  const totalPreClones = getTotalPreClones({\r\n    ...spec,\r\n    slideGroupCount: slideGroupCount.value\r\n  })\r\n  for (\r\n    let index = state.value.currentSlideGroupIndex;\r\n    index < slideGroupCount.value + totalPostClones;\r\n    index++\r\n  ) {\r\n    if (state.value.lazyLoadedList.indexOf(index) < 0) {\r\n      slideGroupsToLoad.push(index)\r\n      break\r\n    }\r\n  }\r\n  for (\r\n    let index = state.value.currentSlideGroupIndex - 1;\r\n    index >= -totalPreClones;\r\n    index--\r\n  ) {\r\n    if (state.value.lazyLoadedList.indexOf(index) < 0) {\r\n      slideGroupsToLoad.push(index)\r\n      break\r\n    }\r\n  }\r\n  if (slideGroupsToLoad.length > 0) {\r\n    state.value.lazyLoadedList =\r\n      state.value.lazyLoadedList.concat(slideGroupsToLoad)\r\n    emit('lazyLoad', slideGroupsToLoad)\r\n  } else {\r\n    if (lazyLoadTimer) {\r\n      clearInterval(lazyLoadTimer)\r\n      lazyLoadTimer = null\r\n    }\r\n  }\r\n}\r\n\r\nconst checkImagesLoad = () => {\r\n  const images = vSlickListRef.value?.querySelectorAll<HTMLImageElement>(\r\n    '.v-slick-slide-group img'\r\n  )\r\n  const imagesCount = images?.length || 0\r\n  let loadedCount = 0\r\n  images?.forEach((image) => {\r\n    const handler = () => {\r\n      if (++loadedCount >= imagesCount) {\r\n        onResize()\r\n      }\r\n    }\r\n    if (!image.onclick) {\r\n      image.onclick = () => {\r\n        ;(image.closest('.v-slick-slide-group') as HTMLElement)?.focus()\r\n      }\r\n    } else {\r\n      const prevClickHandler = image.onclick.bind(image)\r\n      image.onclick = (e) => {\r\n        prevClickHandler(e)\r\n        ;(image.closest('.v-slick-slide-group') as HTMLElement)?.focus()\r\n      }\r\n    }\r\n    if (!image.onload) {\r\n      if (!settings.value.lazyLoad) return\r\n      image.onload = () => {\r\n        adaptHeight()\r\n        callbackTimers.push(setTimeout(onResize, settings.value.speed))\r\n      }\r\n    } else {\r\n      image.onload = handler\r\n      image.onerror = () => {\r\n        handler()\r\n        emit('lazyLoadError')\r\n      }\r\n    }\r\n  })\r\n}\r\n\r\nconst detectWidth = async () => {\r\n  state.value.detectingWidth = true\r\n  return new Promise<void>((resolve) =>\r\n    setTimeout(() => {\r\n      Object.assign(vSlickCarouselStyle.value, {\r\n        width: `${vSlickCarouselRef.value?.offsetWidth}px`\r\n      })\r\n      state.value.detectingWidth = false\r\n      resolve()\r\n    })\r\n  )\r\n}\r\n\r\nconst ssrInit = () => {\r\n  const spec = {\r\n    ...settings.value,\r\n    ...state.value,\r\n    slideGroupCount: slideGroupCount.value\r\n  }\r\n  const preClones = getTotalPreClones(spec)\r\n  const postClones = getTotalPostClones(spec)\r\n  if (settings.value.variableWidth) {\r\n    let trackWidth = [],\r\n      trackLeft = []\r\n    const childrenWidths: number[] = []\r\n    rawSlideGroups.value.forEach((slideGroup) => {\r\n      let maxWidth = 0\r\n      slideGroup.forEach((child) => {\r\n        const { width } = child.props?.style || {}\r\n        if (width) maxWidth = Math.max(maxWidth, width)\r\n      })\r\n      childrenWidths.push(maxWidth)\r\n      trackWidth.push(maxWidth)\r\n    })\r\n    for (let i = 0; i < preClones; i++) {\r\n      trackLeft.push(childrenWidths[childrenWidths.length - 1 - i])\r\n      trackWidth.push(childrenWidths[childrenWidths.length - 1 - i])\r\n    }\r\n    for (let i = 0; i < postClones; i++) {\r\n      trackWidth.push(childrenWidths[i])\r\n    }\r\n    for (let i = 0; i < state.value.currentSlideGroupIndex; i++) {\r\n      trackLeft.push(childrenWidths[i])\r\n    }\r\n    trackWidth = trackWidth.filter((o) => o)\r\n    trackLeft = trackLeft.filter((o) => o)\r\n    const trackStyle = {\r\n      width: `calc(${trackWidth.join(' + ')})`,\r\n      left: `calc(${trackLeft.map((o) => `-${o}`).join(' + ')})`\r\n    }\r\n    if (settings.value.centerMode) {\r\n      const currentWidth = childrenWidths[state.value.currentSlideGroupIndex]\r\n      trackStyle.left = `calc(${trackLeft\r\n        .map((o) => `-${o}`)\r\n        .join(' + ')} + (100% - ${currentWidth}) / 2 )`\r\n    }\r\n    state.value.trackStyle = trackStyle\r\n  } else {\r\n    const _slideGroupCount = preClones + postClones + slideGroupCount.value\r\n    const trackWidth = (100 / settings.value.groupsToShow) * _slideGroupCount\r\n    const slideGroupWidth = 100 / _slideGroupCount\r\n    let trackLeft =\r\n      (-slideGroupWidth *\r\n        (preClones + state.value.currentSlideGroupIndex) *\r\n        trackWidth) /\r\n      100\r\n    if (settings.value.centerMode) {\r\n      trackLeft += (100 - (slideGroupWidth * trackWidth) / 100) / 2\r\n    }\r\n    state.value.slideGroupWidth = slideGroupWidth + '%'\r\n    state.value.trackStyle = {\r\n      width: trackWidth + '%',\r\n      left: trackLeft + '%'\r\n    }\r\n  }\r\n}\r\n\r\nconst breakpoint = ref<number>()\r\n\r\nconst vSlickCarouselRef = ref<HTMLElement>()\r\nconst vSlickCarouselStyle = ref({})\r\nconst vSlickListRef = ref<HTMLElement>()\r\nconst vSlickTrackRef = ref<InstanceType<typeof VSlickTrack>>()\r\n\r\nconst settings = computed<Props>(() => {\r\n  const definedProps = filterUndefined(props)\r\n  let settings = { ...defaultPropValues, ...definedProps }\r\n  if (breakpoint.value) {\r\n    const newProps = props.responsive.find(\r\n      (item) => item.breakpoint === breakpoint.value\r\n    )\r\n    settings = {\r\n      ...settings,\r\n      ...newProps?.settings\r\n    }\r\n  }\r\n  // force scrolling by one group if 'centerMode' is enabled\r\n  if (settings.centerMode) {\r\n    if (settings.groupsToScroll > 1 && process.env.NODE_ENV !== 'production') {\r\n      // eslint-disable-next-line no-console\r\n      console.warn(\r\n        `centerMode is enabled: groupsToScroll should be 1; you are using ${settings.groupsToScroll}`\r\n      )\r\n    }\r\n    settings.groupsToScroll = 1\r\n  }\r\n  // force showing one group and scrolling by one if `fade` is enabled\r\n  if (settings.fade) {\r\n    if (settings.groupsToShow > 1 && process.env.NODE_ENV !== 'production') {\r\n      // eslint-disable-next-line no-console\r\n      console.warn(\r\n        `fade is enabled: groupsToShow should be 1; you are using ${settings.groupsToShow}`\r\n      )\r\n    }\r\n    if (settings.groupsToScroll > 1 && process.env.NODE_ENV !== 'production') {\r\n      // eslint-disable-next-line no-console\r\n      console.warn(\r\n        `fade is enabled: groupsToScroll should be 1; you are using ${settings.groupsToScroll}`\r\n      )\r\n    }\r\n    settings.groupsToShow = 1\r\n    settings.groupsToScroll = 1\r\n  }\r\n  // force disabling `variableWidth` if `slidesPerGroup` is bigger than 1\r\n  if (settings.slidesPerGroup > 1) {\r\n    if (settings.variableWidth && process.env.NODE_ENV !== 'production') {\r\n      // eslint-disable-next-line no-console\r\n      console.warn(`slidesPerGroup is bigger than 1: variableWidth is disabled`)\r\n    }\r\n    settings.variableWidth = false\r\n  }\r\n\r\n  if (settings.vertical && settings.rtl) {\r\n    if (process.env.NODE_ENV !== 'production') {\r\n      // eslint-disable-next-line no-console\r\n      console.warn(`vertical mode is enabled: rtl is disabled`)\r\n    }\r\n    settings.rtl = false\r\n  }\r\n\r\n  return settings\r\n})\r\n\r\nconst canGoPrev = computed(() =>\r\n  checkCanGoPrev({\r\n    ...settings.value,\r\n    ...state.value,\r\n    slideGroupCount: slideGroupCount.value\r\n  })\r\n)\r\n\r\nconst canGoNext = computed(() =>\r\n  checkCanGoNext({\r\n    ...settings.value,\r\n    ...state.value,\r\n    slideGroupCount: slideGroupCount.value\r\n  })\r\n)\r\n\r\nconst pageCount = computed(() => {\r\n  if (settings.value.infinite) {\r\n    return Math.ceil(slideGroupCount.value / settings.value.groupsToScroll)\r\n  }\r\n  let pageCount =\r\n    Math.ceil(\r\n      (slideGroupCount.value - settings.value.groupsToShow) /\r\n        settings.value.groupsToScroll\r\n    ) + 1\r\n  if (\r\n    !settings.value.infinite &&\r\n    settings.value.groupsToShow > 1 &&\r\n    settings.value.centerMode\r\n  ) {\r\n    pageCount++\r\n  }\r\n  return pageCount < 0 ? 0 : pageCount\r\n})\r\n\r\nconst slides = ref<VNode[]>(slots.default ? extractSlides(slots.default()) : [])\r\n\r\nconst state = ref({\r\n  ...makeDefaultSliderState(),\r\n  currentSlideGroupIndex: settings.value.initialGroupIndex\r\n})\r\n\r\nconst currentSlideGroupIndex = computed(\r\n  () => state.value.currentSlideGroupIndex\r\n)\r\n\r\nconst currentGroupsToShow = computed(() => settings.value.groupsToShow)\r\n\r\nconst slideGroupCount = computed(() =>\r\n  getSlideGroupCount(slides.value.length, settings.value.slidesPerGroup)\r\n)\r\n\r\nconst rawSlideGroups = computed<VNode[][]>(() => {\r\n  const slideGroups: VNode[][] = []\r\n  const slidesPerGroup = settings.value.slidesPerGroup\r\n  const slideGroupsCount = slideGroupCount.value\r\n  for (let i = 0; i < slideGroupsCount; i++) {\r\n    const startIndex = i * slidesPerGroup\r\n    const endIndex = startIndex + slidesPerGroup\r\n    slideGroups.push(slides.value.slice(startIndex, endIndex))\r\n  }\r\n  return slideGroups\r\n})\r\n\r\nwatch(\r\n  () => props,\r\n  () => {\r\n    clearBreakpoints()\r\n    makeBreakpoints()\r\n  },\r\n  { deep: true }\r\n)\r\n\r\nwatch(\r\n  settings,\r\n  (newSettings: Props, oldSettings: Props) => {\r\n    let shouldSetTrackStyle = false\r\n    for (const key of Object.keys(settings.value)) {\r\n      if (!newSettings.hasOwnProperty(key)) {\r\n        shouldSetTrackStyle = true\r\n        break\r\n      }\r\n      if (\r\n        typeof newSettings[key as keyof typeof newSettings] === 'object' ||\r\n        typeof newSettings[key as keyof typeof newSettings] === 'function'\r\n      ) {\r\n        continue\r\n      }\r\n      if (\r\n        newSettings[key as keyof typeof newSettings] !==\r\n        oldSettings[key as keyof typeof newSettings]\r\n      ) {\r\n        shouldSetTrackStyle = true\r\n        break\r\n      }\r\n    }\r\n    updateState(shouldSetTrackStyle)\r\n    if (state.value.currentSlideGroupIndex >= slideGroupCount.value) {\r\n      changeSlideGroup({\r\n        message: 'index',\r\n        index: slideGroupCount.value - newSettings.groupsToShow\r\n      })\r\n    }\r\n    if (newSettings.autoplay) {\r\n      autoPlay(PlayingType.update)\r\n    } else {\r\n      pause(PlayingType.paused)\r\n    }\r\n  },\r\n  {\r\n    deep: true\r\n  }\r\n)\r\n\r\nwatch(\r\n  () => slots.default?.() || [],\r\n  (newSlots) => {\r\n    slides.value = extractSlides(newSlots)\r\n  }\r\n)\r\n\r\nwatch(\r\n  () => [\r\n    state.value.listHeight,\r\n    settings.value.centerMode,\r\n    settings.value.centerPadding,\r\n    settings.value.vertical\r\n  ],\r\n  ([listHeight, centerMode, centerPadding, vertical]) => {\r\n    let verticalHeightStyle = {\r\n      height: 'auto'\r\n    }\r\n    if (vertical) {\r\n      verticalHeightStyle = {\r\n        height: `${listHeight}px`\r\n      }\r\n    }\r\n\r\n    let centerPaddingStyle\r\n    if (!centerMode) {\r\n      centerPaddingStyle = {\r\n        padding: '0'\r\n      }\r\n    } else if (vertical) {\r\n      centerPaddingStyle = {\r\n        padding: centerPadding + ' 0px'\r\n      }\r\n    } else {\r\n      centerPaddingStyle = {\r\n        padding: '0px ' + centerPadding\r\n      }\r\n    }\r\n    vSlickListStyle.value = {\r\n      ...vSlickListStyle.value,\r\n      ...filterUndefined(verticalHeightStyle),\r\n      ...centerPaddingStyle\r\n    }\r\n  }\r\n)\r\n\r\nwatch(\r\n  () => [\r\n    settings.value.infinite,\r\n    state.value.currentSlideGroupIndex,\r\n    settings.value.groupsToShow,\r\n    slideGroupCount.value\r\n  ],\r\n  ([infinite, groupsIndex, groupToShow, slideGroupCount]) => {\r\n    if (\r\n      infinite ||\r\n      (groupsIndex as number) <=\r\n        (slideGroupCount as number) - (groupToShow as number) + 1\r\n    )\r\n      return\r\n    slideGroupHandler(pageCount.value - 1)\r\n  }\r\n)\r\n\r\nwatch(\r\n  () => state.value.dragging,\r\n  (dragging) => {\r\n    if (!vSlickListRef.value) return\r\n    if (dragging) {\r\n      vSlickListRef.value.onmousemove = handleMouseMoveOrTouchMoveVSlickList\r\n      vSlickListRef.value.ontouchmove = handleMouseMoveOrTouchMoveVSlickList\r\n      vSlickListRef.value.onmouseup = handleMouseUpOrTouchEndVSlickList\r\n      vSlickListRef.value.ontouchend = handleMouseUpOrTouchEndVSlickList\r\n      vSlickListRef.value.onmouseleave = handleMouseLeaveOrTouchCancelVSlickList\r\n      vSlickListRef.value.ontouchcancel =\r\n        handleMouseLeaveOrTouchCancelVSlickList\r\n    } else {\r\n      vSlickListRef.value.onmousemove = null\r\n      vSlickListRef.value.ontouchmove = null\r\n      vSlickListRef.value.onmouseup = null\r\n      vSlickListRef.value.ontouchend = null\r\n      vSlickListRef.value.onmouseleave = null\r\n      vSlickListRef.value.ontouchcancel = null\r\n    }\r\n  }\r\n)\r\n\r\ndefineExpose({\r\n  goTo: slideGroupHandler,\r\n  next: () => {\r\n    slideGroupHandler(\r\n      state.value.currentSlideGroupIndex + settings.value.groupsToScroll\r\n    )\r\n  },\r\n  prev: () => {\r\n    slideGroupHandler(\r\n      state.value.currentSlideGroupIndex - settings.value.groupsToScroll\r\n    )\r\n  },\r\n  canGoNext,\r\n  canGoPrev,\r\n  play,\r\n  pause,\r\n  autoPlay,\r\n  slideGroupCount,\r\n  currentSlideGroupIndex,\r\n  currentGroupsToShow,\r\n  pageCount\r\n})\r\n\r\nonMounted(async () => {\r\n  window.addEventListener('resize', onResizeEventListener)\r\n  if (settings.value.widthDetection === WidthDetection.manual) {\r\n    await detectWidth()\r\n  }\r\n  updateState(true)\r\n  adaptHeight()\r\n  if (settings.value.autoplay) {\r\n    autoPlay(PlayingType.update)\r\n  }\r\n  if (settings.value.lazyLoad === LazyLoadType.progressive) {\r\n    lazyLoadTimer = setInterval(progressiveLazyLoad, 1000)\r\n  }\r\n  ro = new ResizeObserver(() => {\r\n    if (state.value.animating) {\r\n      onResize({ shouldSetTrackStyle: false }) // do not set trackStyle so as to not break the animation\r\n      callbackTimers.push(setTimeout(() => onResize(), settings.value.speed))\r\n    } else {\r\n      onResize()\r\n    }\r\n  })\r\n  ro.observe(vSlickListRef.value as Element)\r\n  vSlickListRef.value\r\n    ?.querySelectorAll<HTMLElement>('.v-slick-slide-group')\r\n    .forEach((slideGroup) => {\r\n      slideGroup.onfocus = settings.value.pauseOnFocus\r\n        ? onSlideGroupFocus\r\n        : null\r\n      slideGroup.onblur = settings.value.pauseOnFocus ? onSlideGroupBlur : null\r\n    })\r\n})\r\n\r\nonUpdated(() => {\r\n  checkImagesLoad()\r\n  emit('reInit')\r\n  if (settings.value.lazyLoad) {\r\n    const slideGroupsToLoad = getOnDemandLazySlideGroups({\r\n      ...settings.value,\r\n      ...state.value\r\n    })\r\n    if (slideGroupsToLoad.length) {\r\n      state.value.lazyLoadedList =\r\n        state.value.lazyLoadedList.concat(slideGroupsToLoad)\r\n      emit('lazyLoad', slideGroupsToLoad)\r\n    }\r\n  }\r\n  adaptHeight()\r\n})\r\n\r\nonBeforeUnmount(() => {\r\n  window.removeEventListener('resize', onResizeEventListener)\r\n  ro?.unobserve(vSlickListRef.value as Element)\r\n  if (animationEndCallback) {\r\n    clearTimeout(animationEndCallback)\r\n  }\r\n  if (lazyLoadTimer) {\r\n    clearInterval(lazyLoadTimer)\r\n  }\r\n  if (callbackTimers.length) {\r\n    callbackTimers.forEach((timer) => clearTimeout(timer))\r\n    callbackTimers = []\r\n  }\r\n  if (state.value.autoplayTimer) {\r\n    clearInterval(state.value.autoplayTimer)\r\n  }\r\n})\r\n\r\nmakeBreakpoints()\r\nssrInit()\r\nemit('init')\r\n</script>\r\n\r\n<style scoped lang=\"scss\">\r\n.v-slick-slider {\r\n  position: relative;\r\n  display: block;\r\n  box-sizing: border-box;\r\n}\r\n.v-slick-list {\r\n  position: relative;\r\n  display: block;\r\n  overflow: hidden;\r\n  margin: 0;\r\n  padding: 0;\r\n  transform: translate3d(0, 0, 0);\r\n  &:focus {\r\n    outline: none;\r\n  }\r\n  &.dragging {\r\n    cursor: pointer;\r\n    cursor: hand;\r\n  }\r\n}\r\n</style>\r\n"],
  "mappings": "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",
  "names": ["PlayingType", "LazyLoadType", "SwipeDirection", "SlideNavigation", "WidthDetection", "extractSlides", "vnodes", "vnode", "isSlide", "getNavigationOnKeyType", "accessibility", "rtl", "_a", "getChangedSlideGroupIndex", "spec", "options", "indexOffset", "previousInt", "slideGroupOffset", "unevenOffset", "targetSlideGroupIndex", "groupsToScroll", "groupsToShow", "slideGroupCount", "currentSlideGroupIndex", "lazyLoad", "infinite", "direction", "siblingDirection", "totalVisibleGroupsOnRightOfCurrGroup", "totalVisibleGroupsOnLeftOfCurrGroup", "centerMode", "centerPadding", "right", "left", "getNavigableIndexes", "max", "breakpoint", "counter", "indexes", "checkNavigable", "index", "navigables", "prevNavigable", "n", "getSwipeStartState", "swipe", "draggable", "getTraversedSlideGroupCount", "centerOffset", "swipedSlideGroup", "slideGroups", "grp", "currentIndex", "swipedSlideGroupIndex", "getSwipeDirection", "touchObject", "verticalSwiping", "xDist", "yDist", "r", "swipeAngle", "getSwipeEndState", "dragging", "listWidth", "touchThreshold", "listHeight", "swipeToSlide", "scrolling", "onSwipe", "minSwipe", "swipeDirection", "state", "newSlideGroupIndex", "currentLeft", "getTrackLeft", "getTrackAnimateCSS", "getLazySlidesOnLeft", "getLazySlidesOnRight", "getLazyStartIndex", "getLazyEndIndex", "getOnDemandLazySlideGroups", "onDemandSlideGroups", "startIndex", "endIndex", "slideGroupIndex", "getTrackCSS", "trackWidth", "trackHeight", "trackChildren", "getTotalSlideGroups", "style", "transform", "getTotalPreClones", "getTotalPostClones", "trackEl", "slideGroupWidth", "variableWidth", "slideGroupHeight", "fade", "vertical", "targetLeft", "targetSlide", "verticalOffset", "slidesToOffset", "targetSlideIndex", "slide", "canGoPrev", "canGoNext", "canGo", "getStatesOnSlide", "waitForAnimate", "animating", "lazyLoadedList", "useCSSTransitions", "animationSlideGroupIndex", "finalSlideGroupIndex", "slidingState", "afterSlidingState", "finalLeft", "animationLeft", "getSwipeMoveState", "edgeFriction", "edgeDragged", "onEdge", "swiped", "swiping", "swipeEvent", "swipeLeft", "curLeft", "verticalSwipeLength", "positionOffset", "dotCount", "touchSwipeLength", "getSlideGroupCount", "slideCount", "getSliderState", "_b", "centerPaddingAdj", "_c", "slideGroupsToLoad", "sliderState", "canUseDOM", "filterUndefined", "props", "key", "acc", "clearSelection", "makeDefaultProps", "selectFields", "defaultProps", "defaultPropValues", "makeDefaultSliderState", "defaultTrackProps", "defaultArrowProps", "defaultDotsProps", "QueryHandler", "target", "QueryHandler_1", "each", "collection", "fn", "i", "length", "cont", "isArray", "isFunction", "Util", "require$$0", "require$$1", "MediaQuery", "query", "isUnconditional", "self", "mql", "handler", "qh", "handlers", "h", "action", "MediaQuery_1", "MediaQueryDispatch", "q", "shouldDegrade", "queries", "MediaQueryDispatch_1", "src", "camel2hyphen", "str", "match", "camel2hyphen_1", "isDimension", "feature", "re", "obj2mq", "obj", "mq", "features", "value", "json2mq", "json2mq_1", "__props", "emit", "__emit", "clickHandler", "computed", "arrowSlotProps", "getSlideGroupClasses", "isActive", "isCenter", "isCurrent", "getSlideGroupStyle", "originalSlideGroups", "rawSlideGroup", "classes", "slideGroup", "preCloneSlideGroups", "preCloneNo", "postCloneSlideGroups", "leftBound", "rightBound", "FUNC_ERROR_TEXT", "NAN", "symbolTag", "reTrim", "reIsBadHex", "reIsBinary", "reIsOctal", "freeParseInt", "freeGlobal", "global", "freeSelf", "root", "objectProto", "objectToString", "nativeMax", "nativeMin", "now", "debounce", "func", "wait", "lastArgs", "lastThis", "maxWait", "result", "timerId", "lastCallTime", "lastInvokeTime", "leading", "maxing", "trailing", "toNumber", "isObject", "invokeFunc", "time", "args", "thisArg", "leadingEdge", "timerExpired", "remainingWait", "timeSinceLastCall", "timeSinceLastInvoke", "shouldInvoke", "trailingEdge", "cancel", "flush", "debounced", "isInvoking", "type", "isObjectLike", "isSymbol", "other", "isBinary", "lodash_debounce", "DEBOUNCE_RESIZE_DURATION", "slots", "useSlots", "enquire", "enquireJs", "triggerSlideGroupHandler", "animationEndCallback", "lazyLoadTimer", "callbackTimers", "vSlickListStyle", "ref", "getCurrentInstance", "isVSlickListClickable", "debouncedResize", "ro", "responsiveMediaHandlers", "media", "clearBreakpoints", "makeBreakpoints", "breakpoints", "item", "a", "b", "_breakpoint", "mediaQuery", "swipeStart", "e", "swipeStartState", "settings", "swipeEnd", "swipeEndState", "vSlickTrackRef", "vSlickListRef", "newTriggerSlideGroupHandler", "rest", "slideGroupHandler", "swipeMove", "swipeMoveState", "play", "nextIndex", "pause", "pauseType", "autoplaying", "autoPlay", "playType", "adaptHeight", "activeSlideGroups", "maxHeight", "onTrackOver", "onTrackLeave", "handleClickVSlickList", "handleChildClickVSlickTrack", "changeSlideGroup", "handleKeyDownVSlickList", "navigation", "handleMouseDownOrTouchStartVSlickList", "handleMouseMoveOrTouchMoveVSlickList", "handleMouseUpOrTouchEndVSlickList", "handleMouseLeaveOrTouchCancelVSlickList", "handleMouseEnterOrOverVSlickTrack", "handleMouseLeaveVSlickTrack", "handleOverDots", "handleLeaveDots", "handleClickDot", "handleNextVSlickArrow", "handlePrevVSlickArrow", "dontAnimate", "asNavFor", "speed", "states", "slidesToLoad", "resolve", "firstBatch", "updateState", "shouldSetTrackStyle", "updatedState", "slides", "trackStyle", "resize", "detectWidth", "onResize", "onResizeEventListener", "onSlideGroupFocus", "onSlideGroupBlur", "progressiveLazyLoad", "totalPostClones", "totalPreClones", "checkImagesLoad", "images", "imagesCount", "loadedCount", "image", "prevClickHandler", "vSlickCarouselStyle", "vSlickCarouselRef", "ssrInit", "preClones", "postClones", "trackLeft", "childrenWidths", "rawSlideGroups", "maxWidth", "child", "width", "o", "currentWidth", "_slideGroupCount", "definedProps", "newProps", "checkCanGoPrev", "checkCanGoNext", "pageCount", "currentGroupsToShow", "slidesPerGroup", "slideGroupsCount", "watch", "newSettings", "oldSettings", "newSlots", "verticalHeightStyle", "centerPaddingStyle", "groupsIndex", "groupToShow", "__expose", "onMounted", "onUpdated", "onBeforeUnmount", "timer"]
}
