import {
  Fragment,
  computed,
  createBaseVNode,
  createBlock,
  createCommentVNode,
  createElementBlock,
  createVNode,
  defineComponent,
  getCurrentInstance,
  guardReactiveProps,
  mergeProps,
  normalizeClass,
  normalizeProps,
  normalizeStyle,
  onBeforeUnmount,
  onMounted,
  onUpdated,
  openBlock,
  ref,
  renderList,
  renderSlot,
  resolveDynamicComponent,
  toDisplayString,
  unref,
  useSlots,
  watch,
  withCtx
} from "./chunk-6EG4E354.js";
import "./chunk-BUSYA2B4.js";

// node_modules/v-slick-carousel/dist/index.es.mjs
var T = ((e) => (e.play = "play", e.playing = "playing", e.paused = "paused", e.hovered = "hovered", e.focused = "focused", e.update = "update", e.leave = "leave", e.blur = "blur", e))(T || {});
var pt = ((e) => (e.ondemand = "ondemand", e.progressive = "progressive", e))(pt || {});
var R = ((e) => (e.left = "left", e.right = "right", e.up = "up", e.down = "down", e.vertical = "vertical", e))(R || {});
var H = ((e) => (e.next = "next", e.previous = "previous", e))(H || {});
var oe = ((e) => (e.auto = "auto", e.manual = "manual", e))(oe || {});
var $e = (e) => e.flatMap(
  (r) => Rt(r) ? [r] : Array.isArray(r.children) && r.children.length > 0 ? $e(r.children) : []
);
function Rt(e) {
  return !e.type.toString().startsWith("Symbol");
}
var Ft = (e, r, t) => {
  var i;
  return (i = e.target) != null && i.tagName.match("TEXTAREA|INPUT|SELECT") || !r ? "" : e.key === "ArrowLeft" ? t ? H.next : H.previous : e.key === "ArrowRight" ? t ? H.previous : H.next : "";
};
var Xt = (e, r) => {
  let t, i, a, u, s;
  const {
    groupsToScroll: v,
    groupsToShow: k,
    slideGroupCount: f,
    currentSlideGroupIndex: p,
    lazyLoad: c,
    infinite: S
  } = e;
  if (u = f % v !== 0, t = u ? 0 : (f - p) % v, r.message === H.previous)
    a = t === 0 ? v : k - t, s = p - a, c && !S && (i = p - a, s = i === -1 ? f - 1 : i);
  else if (r.message === H.next)
    a = t === 0 ? v : t, s = p + a, c && !S && (s = (p + v) % f + t);
  else if (r.message === "dots") {
    if (s = (r.index || 0) * v, s === p)
      return null;
  } else if (r.message === "children") {
    if (s = r.index || 0, s === p)
      return null;
    if (S) {
      let h = qt({ ...e, targetSlideGroupIndex: s });
      s > p && h === "left" ? s = s - f : s < p && h === "right" && (s = s + f);
    }
  } else if (r.message === "index" && (s = Number(r.index), s === p))
    return null;
  return s;
};
var qt = (e) => e.targetSlideGroupIndex > e.currentSlideGroupIndex ? e.targetSlideGroupIndex > e.currentSlideGroupIndex + Yt(e) ? "left" : "right" : e.targetSlideGroupIndex < e.currentSlideGroupIndex - Ut(e) ? "right" : "left";
var Yt = ({
  groupsToShow: e,
  centerMode: r,
  rtl: t,
  centerPadding: i
}) => {
  if (r) {
    let a = (e - 1) / 2 + 1;
    return parseInt(i) > 0 && (a += 1), t && e % 2 === 0 && (a += 1), a;
  }
  return t ? 0 : e - 1;
};
var Ut = ({
  groupsToShow: e,
  centerMode: r,
  rtl: t,
  centerPadding: i
}) => {
  if (r) {
    let a = (e - 1) / 2 + 1;
    return parseInt(i) > 0 && (a += 1), !t && e % 2 === 0 && (a += 1), a;
  }
  return t ? e - 1 : 0;
};
var Qt = (e) => {
  let r = e.infinite ? e.slideGroupCount * 2 : e.slideGroupCount, t = e.infinite ? e.groupsToShow * -1 : 0, i = e.infinite ? e.groupsToShow * -1 : 0, a = [];
  for (; t < r; )
    a.push(t), t = i + e.groupsToScroll, i += Math.min(e.groupsToScroll, e.groupsToShow);
  return a;
};
var it = (e, r) => {
  const t = Qt(e);
  let i = 0;
  if (r > t[t.length - 1])
    r = t[t.length - 1];
  else
    for (let a in t) {
      if (r < t[a]) {
        r = i;
        break;
      }
      i = t[a];
    }
  return r;
};
var Kt = (e, r, t) => {
  if (!(!r || !t && e.type.indexOf("mouse") !== -1))
    return {
      dragging: true,
      touchObject: {
        startX: window.TouchEvent && e instanceof TouchEvent ? e.touches[0].pageX : e.clientX,
        startY: window.TouchEvent && e instanceof TouchEvent ? e.touches[0].pageY : e.clientY,
        curX: window.TouchEvent && e instanceof TouchEvent ? e.touches[0].pageX : e.clientX,
        curY: window.TouchEvent && e instanceof TouchEvent ? e.touches[0].pageY : e.clientY
      }
    };
};
var nt = (e) => {
  var k;
  const r = e.centerMode ? +e.slideGroupWidth * Math.floor(e.groupsToShow / 2) : 0;
  let t;
  const a = e.listEl.querySelectorAll(
    ".v-slick-slide-group"
  );
  if (Array.from(a).every((f) => {
    if (e.vertical) {
      if (f.offsetTop + f.offsetHeight / 2 > e.swipeLeft * -1)
        return t = f, false;
    } else if (f.offsetLeft - r + f.offsetWidth / 2 > e.swipeLeft * -1)
      return t = f, false;
    return true;
  }), !t)
    return 0;
  const u = e.rtl === true ? e.slideGroupCount - e.currentSlideGroupIndex : e.currentSlideGroupIndex, s = (k = t == null ? void 0 : t.dataset) == null ? void 0 : k.index;
  return Math.abs(
    s ? parseInt(s) : 0 - u
  );
};
var vt = (e, r = false) => {
  let t, i, a, u;
  return t = e.startX - e.curX, i = e.startY - e.curY, a = Math.atan2(i, t), u = Math.round(a * 180 / Math.PI), u < 0 && (u = 360 - Math.abs(u)), u <= 45 && u >= 0 || u <= 360 && u >= 315 ? R.left : u >= 135 && u <= 225 ? R.right : r === true ? u >= 35 && u <= 135 ? R.up : R.down : R.vertical;
};
var Zt = (e, r) => {
  const {
    dragging: t,
    swipe: i,
    touchObject: a,
    listWidth: u,
    touchThreshold: s,
    verticalSwiping: v,
    listHeight: k,
    currentSlideGroupIndex: f,
    swipeToSlide: p,
    scrolling: c,
    onSwipe: S,
    rtl: h
  } = r;
  if (!t) {
    i && e.preventDefault();
    return;
  }
  let y = v ? k / s : u / s, x = vt(a, v);
  h && (x === R.left ? x = R.right : x === R.right && (x = R.left));
  let M = {
    dragging: false,
    edgeDragged: false,
    scrolling: false,
    swiping: false,
    swiped: false,
    swipeLeft: null,
    touchObject: {}
  };
  if (c || !a.swipeLength)
    return M;
  if (a.swipeLength > y) {
    e.preventDefault(), S && S(x);
    let g, C;
    switch (x) {
      case "left":
      case "up":
        C = r.swipeToSlide ? nt(r) : f + r.groupsToScroll, g = p ? it(r, C) : C, M.currentDirection = 0;
        break;
      case "right":
      case "down":
        C = r.swipeToSlide ? nt(r) : f - r.groupsToScroll, g = p ? it(r, C) : C, M.currentDirection = 1;
        break;
      default:
        g = f;
    }
    M.triggerSlideGroupHandler = g;
  } else {
    let g = fe(r);
    M.trackStyle = St(r, g);
  }
  return M;
};
function Jt(e) {
  return e.centerMode ? Math.floor(e.groupsToShow / 2) + (parseInt(e.centerPadding) > 0 ? 1 : 0) : 0;
}
function er(e) {
  return e.centerMode ? Math.floor((e.groupsToShow - 1) / 2) + 1 + (parseInt(e.centerPadding) > 0 ? 1 : 0) : e.groupsToShow;
}
function ht(e) {
  return e.currentSlideGroupIndex - Jt(e);
}
function gt(e) {
  return e.currentSlideGroupIndex + er(e);
}
function He(e) {
  var a;
  let r = [];
  const t = ht(e), i = gt(e);
  for (let u = t; u < i; u++)
    ((a = e.lazyLoadedList) == null ? void 0 : a.indexOf(u)) < 0 && r.push(u);
  return r;
}
function ce(e, r) {
  let t, i;
  const a = e.slideGroupCount + 2 * e.groupsToShow;
  e.vertical ? i = a * parseInt(`${e.slideGroupHeight || 0}`) : t = tr(e) * parseInt(`${e.slideGroupWidth || 0}`);
  let u = {
    opacity: 1,
    transition: ""
  };
  if (e.useCSSTransform) {
    let s = e.vertical ? "translate3d(0px, " + r + "px, 0px)" : "translate3d(" + r + "px, 0px, 0px)";
    u = {
      ...u,
      transform: s
    };
  } else
    e.vertical ? u.top = r : u.left = r;
  return e.fade && (u = { opacity: 1 }), t && (u.width = t + "px"), i && (u.height = i + "px"), u;
}
function tr(e) {
  return e.slideGroupCount <= e.groupsToShow ? e.slideGroupCount : Z(e) + e.slideGroupCount + We(e);
}
function St(e, r) {
  let t = ce(e, r);
  return e.useCSSTransform ? t.transition = "transform " + e.speed + "ms " + e.cssEase : e.vertical ? t.transition = "top " + e.speed + "ms " + e.cssEase : t.transition = "left " + e.speed + "ms " + e.cssEase, e.ignorePrefersReducedMotion && (t.transition += " !important"), t;
}
function fe(e) {
  let {
    centerPadding: r,
    currentSlideGroupIndex: t,
    trackEl: i,
    infinite: a,
    centerMode: u,
    slideGroupCount: s,
    groupsToShow: v,
    groupsToScroll: k,
    slideGroupWidth: f,
    listWidth: p,
    variableWidth: c,
    slideGroupHeight: S,
    fade: h,
    vertical: y,
    rtl: x
  } = e;
  p = p || 0, f = f || 0, S = S || 0;
  let M = 0, g, C, B = 0;
  if (h || s === 1)
    return 0;
  let D = 0;
  if (a ? (D = -Z(e), s % k !== 0 && t + k > s && (D = -(t > s ? v - (t - s) : s % k)), u && (D += Math.floor(v / 2))) : (s % k !== 0 && t + k > s && (D = v - s % k), u && (D = Math.floor(v / 2))), M = D * parseInt(`${f}`), B = D * parseInt(`${S}`), y ? g = t * parseInt(`${S}`) * -1 + B : g = t * parseInt(`${f}`) * -1 + M, c === true) {
    let A;
    if (A = t + Z(e), C = i && i.childNodes[A], g = C ? C.offsetLeft * -1 : 0, u === true) {
      A = a ? t + Z(e) : t, C = i && i.children[A], g = 0;
      for (let b = 0; b < A; b++)
        g -= i && i.children[b] && i.children[b].offsetWidth;
      g -= parseInt(r), g += C && (p - C.offsetWidth) / 2;
    }
  }
  return x && (g = -g), g;
}
var rr = (e) => e.infinite || e.currentSlideGroupIndex !== 0 && e.slideGroupCount > e.groupsToShow;
var je = (e) => {
  let r = true;
  return e.infinite || (e.centerMode ? r = e.currentSlideGroupIndex < e.slideGroupCount - 1 : (e.slideGroupCount <= e.groupsToShow || e.currentSlideGroupIndex >= e.slideGroupCount - e.groupsToShow) && (r = false)), r;
};
var or = (e) => {
  let {
    waitForAnimate: r,
    animating: t,
    fade: i,
    infinite: a,
    index: u,
    slideGroupCount: s,
    lazyLoadedList: v,
    lazyLoad: k,
    currentSlideGroupIndex: f,
    centerMode: p,
    groupsToScroll: c,
    groupsToShow: S,
    useCSSTransitions: h
  } = e;
  if (r && t || i && !a && (u < 0 || u >= s))
    return;
  let y = u, x, M = {}, g = {};
  if (i)
    return u < 0 ? y += s : u >= s && (y -= s), k && v.indexOf(y) < 0 && v.push(y), M = {
      animating: true,
      currentSlideGroupIndex: y,
      lazyLoadedList: v
    }, g = { animating: false }, {
      slidingState: M,
      afterSlidingState: g
    };
  x = y, y < 0 ? (x = y + s, a ? s % c !== 0 && (x = s - s % c) : x = 0) : !je(e) && y > f ? y = x = f : p && y >= s ? (y = a ? s : s - 1, x = a ? 0 : s - 1) : y >= s && (x = y - s, a ? s % c !== 0 && (x = 0) : x = s - S);
  let C = fe({
    ...e,
    currentSlideGroupIndex: x
  }), B = fe({
    ...e,
    currentSlideGroupIndex: y
  });
  return a || (B === C && (y = x), B = C), k && (v = v.concat(
    He({
      ...e,
      currentSlideGroupIndex: y
    })
  )), h ? (M = {
    animating: true,
    currentSlideGroupIndex: x,
    trackStyle: St(e, B),
    lazyLoadedList: v
  }, g = {
    animating: false,
    currentSlideGroupIndex: x,
    trackStyle: ce(e, C),
    swipeLeft: void 0
  }, { slidingState: M, afterSlidingState: g }) : (M = {
    currentSlideGroupIndex: x,
    trackStyle: ce(e, C),
    lazyLoadedList: v
  }, {
    slidingState: M,
    afterSlidingState: g
  });
};
function Z(e) {
  return e.infinite ? e.variableWidth ? e.slideGroupCount : e.groupsToShow + (e.centerMode ? 1 : 0) : 0;
}
function We(e) {
  return e.infinite ? e.slideGroupCount : 0;
}
var ir = (e, r) => {
  const {
    scrolling: t,
    animating: i,
    vertical: a,
    swipeToSlide: u,
    verticalSwiping: s,
    rtl: v,
    currentSlideGroupIndex: k,
    edgeFriction: f,
    edgeDragged: p,
    onEdge: c,
    swiped: S,
    swiping: h,
    slideGroupCount: y,
    groupsToScroll: x,
    infinite: M,
    touchObject: g,
    swipeEvent: C,
    listHeight: B,
    listWidth: D
  } = r;
  if (t) return;
  if (i) {
    e.preventDefault();
    return;
  }
  a && u && s && e.preventDefault();
  let A, b = {}, $ = fe(r);
  g.curX = window.TouchEvent && e instanceof TouchEvent ? e.touches[0].pageX : e.clientX, g.curY = window.TouchEvent && e instanceof TouchEvent ? e.touches[0].pageY : e.clientY, g.swipeLength = Math.round(
    Math.sqrt(Math.pow(g.curX - g.startX, 2))
  );
  let N = Math.round(
    Math.sqrt(Math.pow(g.curY - g.startY, 2))
  );
  if (!s && !h && N > 10)
    return { scrolling: true };
  s && (g.swipeLength = N);
  let _ = (v ? -1 : 1) * (g.curX > g.startX ? 1 : -1);
  s && (_ = g.curY > g.startY ? 1 : -1);
  let we = Math.ceil(y / x), q = vt(r.touchObject, s), Y = g.swipeLength;
  return M || (k === 0 && q === "right" || k + 1 >= we && q === "left" || !je(r) && q === "left") && (Y = Math.round(g.swipeLength * f), p === false && c && (c(q), b.edgeDragged = true)), !S && C && (C(q), b.swiped = true), a ? A = $ + Y * (B / D) * _ : v ? A = $ - Y * _ : A = $ + Y * _, s && (A = $ + Y * _), b = {
    ...b,
    touchObject: g,
    swipeLeft: A,
    trackStyle: ce(r, A)
  }, Math.abs(g.curX - g.startX) < Math.abs(g.curY - g.startY) * 0.8 || g.swipeLength > 10 && (b.swiping = true, e.preventDefault()), b;
};
function yt(e, r) {
  return Math.ceil(e / r);
}
function nr(e) {
  var c, S, h;
  let r = yt(
    e.slides.length,
    e.groupsToShow
  ), t = Math.ceil(((c = e.listEl) == null ? void 0 : c.offsetWidth) || 0), i = Math.ceil(((S = e.trackEl) == null ? void 0 : S.offsetWidth) || 0), a;
  if (e.vertical)
    a = t;
  else {
    let y = e.centerMode ? parseInt(e.centerPadding) * 2 : 0;
    typeof e.centerPadding == "string" && e.centerPadding.slice(-1) === "%" && (y *= t / 100), a = Math.ceil(
      (t - y) / e.groupsToShow
    );
  }
  let u = e.listEl && e.listEl.querySelector('[data-index="0"]') && ((h = e.listEl.querySelector('[data-index="0"]')) == null ? void 0 : h.offsetHeight) || 0, s = u * e.groupsToShow, v = e.currentSlideGroupIndex === void 0 ? e.initialGroupIndex : e.currentSlideGroupIndex;
  e.rtl && e.currentSlideGroupIndex === void 0 && (v = r - 1 - e.initialGroupIndex);
  let k = e.lazyLoadedList || [], f = He(e);
  k.concat(f);
  let p = {
    slideGroupCount: r,
    slideGroupWidth: a,
    listWidth: t,
    trackWidth: i,
    currentSlideGroupIndex: v,
    slideGroupHeight: u,
    listHeight: s,
    lazyLoadedList: k
  };
  return e.autoplaying === null && e.autoplay && (p.autoplaying = T.playing), p;
}
var lr = () => !!(typeof window < "u" && window.document && window.document.createElement);
var lt = (e) => Object.keys(e).filter((r) => e[r] !== void 0).reduce((r, t) => (r[t] = e[t], r), {});
function ar() {
  var e, r;
  window.getSelection && ((e = window.getSelection()) != null && e.empty ? window.getSelection().empty() : (r = window.getSelection()) != null && r.removeAllRanges && window.getSelection().removeAllRanges());
}
var me = (e) => {
  const r = {
    accessibility: { type: Boolean, default: true },
    adaptiveHeight: { type: Boolean, default: false },
    arrows: { type: Boolean, default: true },
    asNavFor: {
      type: Object,
      default: null
    },
    autoplay: { type: Boolean, default: false },
    autoplaySpeed: { type: Number, default: 3e3 },
    centerMode: { type: Boolean, default: false },
    centerPadding: { type: String, default: "50px" },
    cssEase: { type: String, default: "ease" },
    dots: { type: Boolean, default: false },
    dotsClass: { type: String, default: "v-slick-dots" },
    draggable: { type: Boolean, default: true },
    edgeFriction: { type: Number, default: 0.35 },
    fade: { type: Boolean, default: false },
    focusOnSelect: { type: Boolean, default: false },
    ignorePrefersReducedMotion: { type: Boolean, default: false },
    infinite: { type: Boolean, default: true },
    initialGroupIndex: { type: Number, default: 0 },
    lazyLoad: { type: String, default: null },
    nextArrowLabel: { type: String, default: "Next" },
    pauseOnDotsHover: { type: Boolean, default: false },
    pauseOnFocus: { type: Boolean, default: false },
    pauseOnHover: { type: Boolean, default: true },
    prevArrowLabel: { type: String, default: "Previous" },
    responsive: { type: Array, default: [] },
    rtl: { type: Boolean, default: false },
    slidesPerGroup: { type: Number, default: 1 },
    groupsToScroll: { type: Number, default: 1 },
    groupsToShow: { type: Number, default: 1 },
    speed: { type: Number, default: 500 },
    swipe: { type: Boolean, default: true },
    swipeToSlide: { type: Boolean, default: false },
    touchMove: { type: Boolean, default: true },
    touchThreshold: { type: Number, default: 5 },
    useCSSTransitions: { type: Boolean, default: true },
    useCSSTransform: { type: Boolean, default: true },
    variableWidth: { type: Boolean, default: false },
    vertical: { type: Boolean, default: false },
    verticalSwiping: { type: Boolean, default: false },
    waitForAnimate: { type: Boolean, default: true },
    widthDetection: { type: String, default: oe.auto }
  };
  return e ? Object.keys(r).reduce((t, i) => (e.includes(i) && (t[i] = r[i]), t), {}) : r;
};
var ze = me();
var ur = Object.keys(ze).reduce((e, r) => (e[r] = ze[r].default, e), {});
var sr = () => ({
  animating: false,
  autoplaying: null,
  autoplayTimer: null,
  currentDirection: 0,
  currentLeft: null,
  currentSlideGroupIndex: 0,
  detectingWidth: false,
  direction: 1,
  dragging: false,
  edgeDragged: false,
  initialized: false,
  lazyLoadedList: [],
  listHeight: void 0,
  listWidth: void 0,
  scrolling: false,
  slideGroupHeight: void 0,
  slideGroupWidth: void 0,
  swipeLeft: void 0,
  swiped: false,
  swiping: false,
  touchObject: { startX: 0, startY: 0, curX: 0, curY: 0, swipeLength: 0 },
  trackStyle: {},
  trackWidth: 0
});
var dr = {
  ...me([
    "centerMode",
    "centerPadding",
    "cssEase",
    "fade",
    "ignorePrefersReducedMotion",
    "infinite",
    "lazyLoad",
    "rtl",
    "groupsToScroll",
    "groupsToShow",
    "speed",
    "variableWidth",
    "vertical"
  ]),
  currentSlideGroupIndex: { type: Number, default: 0 },
  detectingWidth: { type: Boolean, default: false },
  lazyLoadedList: {
    type: Array,
    default: []
  },
  listHeight: { type: Number, default: void 0 },
  trackStyle: { type: Object, default: {} },
  slideGroupCount: { type: Number, default: 0 },
  rawSlideGroups: { type: Array, default: [] },
  slideGroupHeight: { type: [String, Number], default: void 0 },
  slideGroupWidth: { type: [String, Number], default: void 0 }
};
var cr = {
  ...me([
    "centerMode",
    "infinite",
    "groupsToShow",
    "prevArrowLabel",
    "nextArrowLabel"
  ]),
  currentSlideGroupIndex: { type: Number, default: 0 },
  disabled: { type: Boolean, default: false },
  slideGroupCount: { type: Number, default: 0 },
  type: { type: String, default: "prev" }
};
var fr = {
  ...me([
    "dotsClass",
    "infinite",
    "groupsToScroll",
    "groupsToShow"
  ]),
  currentSlideGroupIndex: { type: Number, default: 0 },
  slideGroupCount: { type: Number, default: 0 },
  pageCount: { type: Number, default: 0 }
};
var ge = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Be(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function Ae(e) {
  this.options = e, !e.deferSetup && this.setup();
}
Ae.prototype = {
  constructor: Ae,
  /**
   * coordinates setup of the handler
   *
   * @function
   */
  setup: function() {
    this.options.setup && this.options.setup(), this.initialised = true;
  },
  /**
   * coordinates setup and triggering of the handler
   *
   * @function
   */
  on: function() {
    !this.initialised && this.setup(), this.options.match && this.options.match();
  },
  /**
   * coordinates the unmatch event for the handler
   *
   * @function
   */
  off: function() {
    this.options.unmatch && this.options.unmatch();
  },
  /**
   * called when a handler is to be destroyed.
   * delegates to the destroy or unmatch callbacks, depending on availability.
   *
   * @function
   */
  destroy: function() {
    this.options.destroy ? this.options.destroy() : this.off();
  },
  /**
   * determines equality by reference.
   * if object is supplied compare options, if function, compare match callback
   *
   * @function
   * @param {object || function} [target] the target for comparison
   */
  equals: function(e) {
    return this.options === e || this.options.match === e;
  }
};
var pr = Ae;
function vr(e, r) {
  var t = 0, i = e.length, a;
  for (t; t < i && (a = r(e[t], t), a !== false); t++)
    ;
}
function hr(e) {
  return Object.prototype.toString.apply(e) === "[object Array]";
}
function gr(e) {
  return typeof e == "function";
}
var mt = {
  isFunction: gr,
  isArray: hr,
  each: vr
};
var Sr = pr;
var Le = mt.each;
function Ne(e, r) {
  this.query = e, this.isUnconditional = r, this.handlers = [], this.mql = window == null ? void 0 : window.matchMedia(e);
  var t = this;
  this.listener = function(i) {
    t.mql = i.currentTarget || i, t.assess();
  }, this.mql.addListener(this.listener);
}
Ne.prototype = {
  constuctor: Ne,
  /**
   * add a handler for this query, triggering if already active
   *
   * @param {object} handler
   * @param {function} handler.match callback for when query is activated
   * @param {function} [handler.unmatch] callback for when query is deactivated
   * @param {function} [handler.setup] callback for immediate execution when a query handler is registered
   * @param {boolean} [handler.deferSetup=false] should the setup callback be deferred until the first time the handler is matched?
   */
  addHandler: function(e) {
    var r = new Sr(e);
    this.handlers.push(r), this.matches() && r.on();
  },
  /**
   * removes the given handler from the collection, and calls it's destroy methods
   *
   * @param {object || function} handler the handler to remove
   */
  removeHandler: function(e) {
    var r = this.handlers;
    Le(r, function(t, i) {
      if (t.equals(e))
        return t.destroy(), !r.splice(i, 1);
    });
  },
  /**
   * Determine whether the media query should be considered a match
   *
   * @return {Boolean} true if media query can be considered a match, false otherwise
   */
  matches: function() {
    return this.mql.matches || this.isUnconditional;
  },
  /**
   * Clears all handlers and unbinds events
   */
  clear: function() {
    Le(this.handlers, function(e) {
      e.destroy();
    }), this.mql.removeListener(this.listener), this.handlers.length = 0;
  },
  /*
      * Assesses the query, turning on all handlers if it matches, turning them off if it doesn't match
      */
  assess: function() {
    var e = this.matches() ? "on" : "off";
    Le(this.handlers, function(r) {
      r[e]();
    });
  }
};
var yr = Ne;
var mr = yr;
var _e = mt;
var wr = _e.each;
var at = _e.isFunction;
var Gr = _e.isArray;
function De() {
  if (typeof window < "u" && !window.matchMedia)
    throw new Error("matchMedia not present, legacy browsers require a polyfill");
  this.queries = {}, typeof window < "u" && (this.browserIsIncapable = !window.matchMedia("only all").matches);
}
De.prototype = {
  constructor: De,
  /**
   * Registers a handler for the given media query
   *
   * @param {string} q the media query
   * @param {object || Array || Function} options either a single query handler object, a function, or an array of query handlers
   * @param {function} options.match fired when query matched
   * @param {function} [options.unmatch] fired when a query is no longer matched
   * @param {function} [options.setup] fired when handler first triggered
   * @param {boolean} [options.deferSetup=false] whether setup should be run immediately or deferred until query is first matched
   * @param {boolean} [shouldDegrade=false] whether this particular media query should always run on incapable browsers
   */
  register: function(e, r, t) {
    var i = this.queries, a = t && this.browserIsIncapable;
    return i[e] || (i[e] = new mr(e, a)), at(r) && (r = { match: r }), Gr(r) || (r = [r]), wr(r, function(u) {
      at(u) && (u = { match: u }), i[e].addHandler(u);
    }), this;
  },
  /**
   * unregisters a query and all it's handlers, or a specific handler for a query
   *
   * @param {string} q the media query to target
   * @param {object || function} [handler] specific handler to unregister
   */
  unregister: function(e, r) {
    var t = this.queries[e];
    return t && (r ? t.removeHandler(r) : (t.clear(), delete this.queries[e])), this;
  }
};
var kr = De;
var br = kr;
var Tr = new br();
var xr = Be(Tr);
var Ir = function(e) {
  return e.replace(/[A-Z]/g, function(r) {
    return "-" + r.toLowerCase();
  }).toLowerCase();
};
var Cr = Ir;
var Lr = Cr;
var Mr = function(e) {
  var r = /[height|width]$/;
  return r.test(e);
};
var ut = function(e) {
  var r = "", t = Object.keys(e);
  return t.forEach(function(i, a) {
    var u = e[i];
    i = Lr(i), Mr(i) && typeof u == "number" && (u = u + "px"), u === true ? r += i : u === false ? r += "not " + i : r += "(" + i + ": " + u + ")", a < t.length - 1 && (r += " and ");
  }), r;
};
var Or = function(e) {
  var r = "";
  return typeof e == "string" ? e : e instanceof Array ? (e.forEach(function(t, i) {
    r += ut(t), i < e.length - 1 && (r += ", ");
  }), r) : ut(e);
};
var Er = Or;
var st = Be(Er);
var $r = defineComponent({
  __name: "VSlickArrow",
  props: cr,
  emits: [H.previous, H.next],
  setup(e, { emit: r }) {
    const t = e, i = r, a = computed(() => () => {
      t.disabled || i(t.type);
    }), u = computed(() => ({
      currentSlideGroupIndex: t.currentSlideGroupIndex,
      slideGroupCount: t.slideGroupCount,
      onClick: a.value,
      disabled: !t.disabled
    }));
    return (s, v) => s.type === unref(H).previous ? renderSlot(s.$slots, "prevArrow", normalizeProps(mergeProps({ key: 0 }, u.value)), () => [
      createBaseVNode("button", {
        type: "button",
        "data-role": "none",
        class: normalizeClass(["v-slick-arrow prev", { disabled: s.disabled }]),
        onClick: v[0] || (v[0] = //@ts-ignore
        (...k) => a.value && a.value(...k))
      }, toDisplayString(s.prevArrowLabel), 3)
    ], true) : renderSlot(s.$slots, "nextArrow", normalizeProps(mergeProps({ key: 1 }, u.value)), () => [
      createBaseVNode("button", {
        type: "button",
        "data-role": "none",
        class: normalizeClass(["v-slick-arrow next", { disabled: s.disabled }]),
        onClick: v[1] || (v[1] = //@ts-ignore
        (...k) => a.value && a.value(...k))
      }, toDisplayString(s.nextArrowLabel), 3)
    ], true);
  }
});
var Ve = (e, r) => {
  const t = e.__vccOpts || e;
  for (const [i, a] of r)
    t[i] = a;
  return t;
};
var dt = Ve($r, [["__scopeId", "data-v-ef343262"]]);
var Wr = ["onClick"];
var zr = ["onClick"];
var Ar = ["onClick"];
var Nr = defineComponent({
  __name: "VSlickTrack",
  props: dr,
  emits: ["childClick"],
  setup(e, { emit: r }) {
    const t = e, i = r, a = (f) => {
      let p = false, c = false, S = false, h;
      return t.centerMode ? (h = Math.floor(t.groupsToShow / 2), c = (f - t.currentSlideGroupIndex) % t.slideGroupCount === 0, f > t.currentSlideGroupIndex - h - 1 && f <= t.currentSlideGroupIndex + h && (p = true)) : p = t.currentSlideGroupIndex <= f && f < t.currentSlideGroupIndex + t.groupsToShow, S = f === t.currentSlideGroupIndex, Object.entries({
        active: p,
        center: c,
        current: S
      }).filter(([, y]) => y).map(([y]) => y);
    }, u = (f) => {
      let p = {};
      if ((t.variableWidth === void 0 || t.variableWidth === false) && (p.width = typeof t.slideGroupWidth == "number" ? `${t.slideGroupWidth}px` : t.slideGroupWidth), t.fade) {
        if (p.position = "relative", t.vertical) {
          const c = t.slideGroupHeight ? typeof t.slideGroupHeight == "string" ? parseFloat(t.slideGroupHeight) : t.slideGroupHeight : 0;
          p.top = `${-f * c}px`;
        } else {
          const c = t.slideGroupWidth ? typeof t.slideGroupWidth == "string" ? parseFloat(t.slideGroupWidth) : t.slideGroupWidth : 0, S = t.rtl ? f * c : -f * c;
          p.left = `${S}px`;
        }
        p.opacity = t.currentSlideGroupIndex === f ? 1 : 0, p.transition = "opacity " + t.speed + "ms " + t.cssEase + ", visibility " + t.speed + "ms " + t.cssEase, t.ignorePrefersReducedMotion && (p.transition += " !important");
      }
      return p;
    }, s = computed(() => t.rawSlideGroups.map((p, c) => {
      const S = u(c), h = a(c);
      t.fade && h.includes("active") && Object.assign(S, { zIndex: 1 });
      const y = {
        slides: [],
        key: `original-${c}`,
        class: h,
        style: S,
        attrs: {
          "data-index": c,
          "aria-hidden": `${!h.includes("active")}`
        },
        onClick: () => {
          i("childClick", {
            index: t.rtl && t.infinite ? t.slideGroupCount + c : c
          });
        }
      };
      return (!t.lazyLoad || t.lazyLoad && t.lazyLoadedList.indexOf(c) >= 0) && (y.slides = p), y;
    })), v = computed(() => !t.infinite || t.fade || t.slideGroupCount <= t.groupsToShow ? [] : t.rawSlideGroups.map((p, c) => {
      const S = t.slideGroupCount - c;
      if (S > Z(t)) return;
      const h = -S, y = {
        slides: [],
        key: `preclone-${h}`,
        class: a(h),
        style: u(c),
        attrs: {
          "data-index": h,
          "aria-hidden": "true"
        },
        onClick: () => {
          i("childClick", {
            index: h
          });
        }
      };
      return (h >= ht(t) || !t.lazyLoad || t.lazyLoad && t.lazyLoadedList.indexOf(c) >= 0) && (y.slides = p), y;
    }).filter((p) => p)), k = computed(() => !t.infinite || t.fade || t.slideGroupCount <= t.groupsToShow ? [] : t.rawSlideGroups.map((p, c) => {
      const S = t.slideGroupCount + c, h = {
        slides: [],
        key: `postclone-${S}`,
        class: a(S),
        style: u(c),
        attrs: {
          "data-index": S,
          "aria-hidden": t.infinite && t.slideGroupCount - t.currentSlideGroupIndex < t.groupsToShow && c < t.groupsToShow - (t.slideGroupCount - t.currentSlideGroupIndex) ? "false" : "true"
        },
        onClick: () => {
          i("childClick", {
            index: t.rtl ? t.slideGroupCount + S : S
          });
        }
      };
      return (S < gt(t) || !t.lazyLoad || t.lazyLoad && t.lazyLoadedList.indexOf(c) >= 0) && (h.slides = p), h;
    }));
    return (f, p) => (openBlock(), createElementBlock("div", {
      class: normalizeClass(["v-slick-track", { center: f.centerMode, vertical: f.vertical }]),
      style: normalizeStyle([f.trackStyle, f.detectingWidth ? { width: "0 !important" } : {}])
    }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(v.value, (c, S) => (openBlock(), createElementBlock("div", mergeProps({
        key: c.key,
        tabindex: "-1",
        class: [c.class, "v-slick-slide-group clone"],
        style: c.style,
        ref_for: true
      }, c.attrs, {
        onClick: c.onClick
      }), [
        (openBlock(true), createElementBlock(Fragment, null, renderList(c.slides, (h, y) => (openBlock(), createBlock(resolveDynamicComponent(h), {
          key: `slide-${S}-${y}` + (h.key ? `-${String(h.key)}` : "")
        }))), 128))
      ], 16, Wr))), 128)),
      (openBlock(true), createElementBlock(Fragment, null, renderList(s.value, (c, S) => (openBlock(), createElementBlock("div", mergeProps({
        key: c.key,
        tabindex: "-1",
        class: ["v-slick-slide-group", c.class],
        style: c.style,
        ref_for: true
      }, c.attrs, {
        onClick: c.onClick
      }), [
        (openBlock(true), createElementBlock(Fragment, null, renderList(c.slides, (h, y) => (openBlock(), createBlock(resolveDynamicComponent(h), {
          key: `slide-${S}-${y}` + (h.key ? `-${String(h.key)}` : "")
        }))), 128))
      ], 16, zr))), 128)),
      (openBlock(true), createElementBlock(Fragment, null, renderList(k.value, (c, S) => (openBlock(), createElementBlock("div", mergeProps({
        key: c.key,
        tabindex: "-1",
        class: [c.class, "v-slick-slide-group clone"],
        style: c.style,
        ref_for: true
      }, c.attrs, {
        onClick: c.onClick
      }), [
        (openBlock(true), createElementBlock(Fragment, null, renderList(c.slides, (h, y) => (openBlock(), createBlock(resolveDynamicComponent(h), {
          key: `slide-${S}-${y}` + (h.key ? `-${String(h.key)}` : "")
        }))), 128))
      ], 16, Ar))), 128))
    ], 6));
  }
});
var Dr = Ve(Nr, [["__scopeId", "data-v-5a37399b"]]);
var Pr = ["onClick"];
var Hr = defineComponent({
  __name: "VSlickDots",
  props: fr,
  emits: ["dotClick", "dotsOver", "dotsLeave"],
  setup(e) {
    const r = e, t = (i) => {
      const a = i * r.groupsToScroll, u = a + r.groupsToScroll - 1;
      return r.currentSlideGroupIndex >= a && r.currentSlideGroupIndex <= u;
    };
    return (i, a) => (openBlock(), createElementBlock("ul", {
      class: normalizeClass(i.dotsClass),
      style: { display: "block" },
      onMouseenter: a[0] || (a[0] = (u) => i.$emit("dotsLeave")),
      onMouseleave: a[1] || (a[1] = (u) => i.$emit("dotsLeave")),
      onMouseover: a[2] || (a[2] = (u) => i.$emit("dotsOver"))
    }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(i.pageCount, (u) => (openBlock(), createElementBlock("li", {
        key: u,
        class: normalizeClass({ active: t(u - 1) }),
        onClick: (s) => i.$emit("dotClick", {
          index: u - 1,
          groupsToScroll: i.groupsToScroll
        })
      }, [
        renderSlot(i.$slots, "customPaging", {
          page: u - 1
        }, () => [
          createBaseVNode("button", null, toDisplayString(u), 1)
        ])
      ], 10, Pr))), 128))
    ], 34));
  }
});
var jr = "Expected a function";
var ct = NaN;
var Br = "[object Symbol]";
var _r = /^\s+|\s+$/g;
var Vr = /^[-+]0x[0-9a-f]+$/i;
var Rr = /^0b[01]+$/i;
var Fr = /^0o[0-7]+$/i;
var Xr = parseInt;
var qr = typeof ge == "object" && ge && ge.Object === Object && ge;
var Yr = typeof self == "object" && self && self.Object === Object && self;
var Ur = qr || Yr || Function("return this")();
var Qr = Object.prototype;
var Kr = Qr.toString;
var Zr = Math.max;
var Jr = Math.min;
var Me = function() {
  return Ur.Date.now();
};
function eo(e, r, t) {
  var i, a, u, s, v, k, f = 0, p = false, c = false, S = true;
  if (typeof e != "function")
    throw new TypeError(jr);
  r = ft(r) || 0, Pe(t) && (p = !!t.leading, c = "maxWait" in t, u = c ? Zr(ft(t.maxWait) || 0, r) : u, S = "trailing" in t ? !!t.trailing : S);
  function h(b) {
    var $ = i, N = a;
    return i = a = void 0, f = b, s = e.apply(N, $), s;
  }
  function y(b) {
    return f = b, v = setTimeout(g, r), p ? h(b) : s;
  }
  function x(b) {
    var $ = b - k, N = b - f, _ = r - $;
    return c ? Jr(_, u - N) : _;
  }
  function M(b) {
    var $ = b - k, N = b - f;
    return k === void 0 || $ >= r || $ < 0 || c && N >= u;
  }
  function g() {
    var b = Me();
    if (M(b))
      return C(b);
    v = setTimeout(g, x(b));
  }
  function C(b) {
    return v = void 0, S && i ? h(b) : (i = a = void 0, s);
  }
  function B() {
    v !== void 0 && clearTimeout(v), f = 0, i = k = a = v = void 0;
  }
  function D() {
    return v === void 0 ? s : C(Me());
  }
  function A() {
    var b = Me(), $ = M(b);
    if (i = arguments, a = this, k = b, $) {
      if (v === void 0)
        return y(k);
      if (c)
        return v = setTimeout(g, r), h(k);
    }
    return v === void 0 && (v = setTimeout(g, r)), s;
  }
  return A.cancel = B, A.flush = D, A;
}
function Pe(e) {
  var r = typeof e;
  return !!e && (r == "object" || r == "function");
}
function to(e) {
  return !!e && typeof e == "object";
}
function ro(e) {
  return typeof e == "symbol" || to(e) && Kr.call(e) == Br;
}
function ft(e) {
  if (typeof e == "number")
    return e;
  if (ro(e))
    return ct;
  if (Pe(e)) {
    var r = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = Pe(r) ? r + "" : r;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(_r, "");
  var t = Rr.test(e);
  return t || Fr.test(e) ? Xr(e.slice(2), t ? 2 : 8) : Vr.test(e) ? ct : +e;
}
var oo = eo;
var io = Be(oo);
var no = ["dir"];
var lo = 50;
var ao = defineComponent({
  inheritAttrs: false,
  __name: "VSlickCarousel",
  props: ze,
  emits: [
    "init",
    "beforeChange",
    "afterChange",
    "lazyLoad",
    "lazyLoadError",
    "reInit",
    "edge",
    "swipe"
  ],
  setup(e, { expose: r, emit: t }) {
    var tt, rt, ot;
    const i = e, a = t, u = useSlots(), s = lr() ? xr : void 0;
    let v, k = null, f = null, p = [];
    const c = ref({
      ...((ot = (rt = (tt = getCurrentInstance()) == null ? void 0 : tt.vnode) == null ? void 0 : rt.props) == null ? void 0 : ot.style) || {}
    });
    let S = true, h = null, y = null, x = [];
    const M = (o, l) => {
      s && (s.register(o, l), x.push({ query: o, handler: l }));
    }, g = () => {
      x.forEach(
        ({ query: o, handler: l }) => s == null ? void 0 : s.unregister(o, l)
      ), x = [];
    }, C = () => {
      if (!i.responsive.length) return;
      const o = i.responsive.map((m) => m.breakpoint);
      o.sort((m, w) => m - w), o.forEach((m, w) => {
        const G = st({
          minWidth: w === 0 ? 0 : o[w - 1] + 1,
          maxWidth: m
        });
        M(G, () => {
          pe.value = m;
        });
      });
      const l = st({
        minWidth: o.slice(-1)[0]
      });
      M(l, () => {
        pe.value = void 0;
      });
    }, B = (o) => {
      const l = Kt(
        o,
        n.value.swipe,
        n.value.draggable
      );
      Object.assign(d.value, l);
    }, D = (o) => {
      var G;
      const l = Zt(o, {
        ...n.value,
        ...d.value,
        trackEl: (G = F.value) == null ? void 0 : G.$el,
        listEl: O.value,
        slideGroupIndex: d.value.currentSlideGroupIndex,
        slideGroupCount: E.value
      });
      if (!l) return;
      const { triggerSlideGroupHandler: m, ...w } = l;
      v = m, Object.assign(d.value, w), v !== void 0 && U(v);
    }, A = (o) => {
      var m;
      ar();
      const l = ir(o, {
        ...i,
        ...d.value,
        trackEl: (m = F.value) == null ? void 0 : m.$el,
        listEl: O.value,
        slideGroupIndex: d.value.currentSlideGroupIndex,
        slideGroupCount: E.value,
        onEdge: (w) => a("edge", w),
        swipeEvent: (w) => a("swipe", w)
      });
      l && (l.swiping && (S = false), Object.assign(d.value, l));
    }, b = () => {
      let o;
      if (n.value.rtl)
        o = d.value.currentSlideGroupIndex - n.value.groupsToScroll;
      else if (ke.value)
        o = d.value.currentSlideGroupIndex + n.value.groupsToScroll;
      else
        return false;
      U(o);
    }, $ = (o = null) => {
      d.value.autoplayTimer && (clearInterval(d.value.autoplayTimer), d.value.autoplayTimer = null);
      const l = d.value.autoplaying;
      o === T.paused ? d.value.autoplaying = T.paused : o === T.focused && (l === T.hovered || l === T.playing) ? d.value.autoplaying = T.focused : l === T.playing ? d.value.autoplaying = T.hovered : l === null && (d.value.autoplaying = null);
    }, N = (o) => {
      d.value.autoplayTimer && clearInterval(d.value.autoplayTimer);
      const l = d.value.autoplaying;
      if (o === T.update) {
        if (l === T.hovered || l === T.focused || l === T.paused)
          return;
      } else if (o === T.leave) {
        if (l === T.paused || l === T.focused)
          return;
      } else if (o === T.blur && (l === T.paused || l === T.hovered))
        return;
      d.value.autoplayTimer = setInterval(
        b,
        n.value.autoplaySpeed + 50
      ), d.value.autoplaying = T.playing;
    }, _ = () => {
      if (n.value.adaptiveHeight && O.value) {
        const o = O.value.querySelectorAll(
          ".v-slick-slide-group.active"
        );
        let l = 0;
        o.forEach((m) => {
          l = Math.max(l, m.offsetHeight);
        }), O.value.style.height = l + "px";
      }
    }, we = () => {
      n.value.autoplay && $(T.hovered);
    }, q = () => {
      n.value.autoplay && d.value.autoplaying === T.hovered && N(T.leave);
    }, Y = (o) => {
      S === false && (o.stopPropagation(), o.preventDefault()), S = true;
    }, wt = ({ index: o }) => {
      n.value.focusOnSelect && J({
        message: "children",
        index: o
      });
    }, Gt = (o) => {
      if (!n.value.accessibility) return;
      const l = Ft(
        o,
        n.value.accessibility,
        n.value.rtl
      );
      l && J({ message: l });
    }, Re = (o) => {
      if (!n.value.touchMove) return;
      const l = o.target;
      l != null && l.classList.contains("no-swipe") || B(o);
    }, Fe = (o) => {
      if (!d.value.dragging || !n.value.touchMove) return;
      const l = o.target;
      l != null && l.classList.contains("no-swipe") || A(o);
    }, Xe = (o) => {
      n.value.touchMove && D(o);
    }, qe = (o) => {
      !d.value.dragging || !n.value.touchMove || D(o);
    }, Ye = () => {
      n.value.pauseOnHover && we();
    }, kt = () => {
      n.value.pauseOnHover && q();
    }, bt = () => {
      n.value.pauseOnDotsHover && n.value.autoplay && $(T.hovered);
    }, Tt = () => {
      n.value.pauseOnDotsHover && n.value.autoplay && d.value.autoplaying === T.hovered && N(T.leave);
    }, xt = ({ index: o }) => {
      J({
        message: "dots",
        index: o
      });
    }, It = () => {
      J({
        message: H.next
      });
    }, Ct = () => {
      J({
        message: H.previous
      });
    }, J = (o, l = false) => {
      const m = {
        ...n.value,
        ...d.value,
        slideGroupCount: E.value
      }, w = Xt(
        m,
        o
      );
      w != null && U(
        w,
        l === true ? true : void 0
      );
    }, U = async (o, l = false) => {
      var he, ae;
      const { asNavFor: m, speed: w } = n.value, G = d.value.currentSlideGroupIndex, I = or({
        index: o,
        ...n.value,
        ...d.value,
        slideGroupCount: E.value,
        trackEl: (he = F.value) == null ? void 0 : he.$el,
        useCSSTransitions: n.value.useCSSTransitions && !l
      });
      if (!I) return;
      const { slidingState: z, afterSlidingState: L } = I;
      a(
        "beforeChange",
        G,
        z.currentSlideGroupIndex
      );
      const V = ((ae = z.lazyLoadedList) == null ? void 0 : ae.filter(
        (te) => d.value.lazyLoadedList.indexOf(te) < 0
      )) || [];
      V.length && a("lazyLoad", V), Object.assign(d.value, z), m && m.goTo(o), L && await new Promise((te) => {
        k = setTimeout(() => {
          const { animating: Nt, ...Dt } = L;
          (n.value.waitForAnimate || d.value.currentSlideGroupIndex === z.currentSlideGroupIndex) && Object.assign(d.value, Dt), p.push(
            setTimeout(() => {
              d.value.animating = Nt || false;
            })
          ), a("afterChange", z.currentSlideGroupIndex), k = null, te();
        }, w);
      });
    }, Ge = (o) => {
      var I, z;
      const l = nr({
        ...n.value,
        ...d.value,
        listEl: O.value,
        trackEl: (I = F.value) == null ? void 0 : I.$el,
        slides: ve.value
      }), m = {
        ...i,
        ...d,
        ...l,
        trackEl: (z = F.value) == null ? void 0 : z.$el,
        slideGroupCount: E.value
      }, w = fe(m), G = ce(m, w);
      (o || E.value !== m.slideGroupCount) && (l.trackStyle = G), Object.assign(d.value, l);
    }, Lt = async (o = {
      shouldSetTrackStyle: true
    }) => {
      !F.value || !F.value.$el || (n.value.widthDetection === oe.manual && o.isWindowResize && await Qe(), Ge(
        o.shouldSetTrackStyle || n.value.widthDetection === oe.manual && o.isWindowResize
      ), i.autoplay ? N(T.update) : $());
    }, ee = (o) => {
      h == null || h.cancel(), h = io(() => Lt(o), lo), h();
    }, Ue = () => ee({
      isWindowResize: true
    }), Mt = () => {
      n.value.autoplay && $(T.focused);
    }, Ot = () => {
      n.value.autoplay && d.value.autoplaying === T.focused && N(T.blur);
    }, Et = () => {
      const o = [], l = { ...n.value, ...d.value }, m = We({
        ...l,
        slideGroupCount: E.value
      }), w = Z({
        ...l,
        slideGroupCount: E.value
      });
      for (let G = d.value.currentSlideGroupIndex; G < E.value + m; G++)
        if (d.value.lazyLoadedList.indexOf(G) < 0) {
          o.push(G);
          break;
        }
      for (let G = d.value.currentSlideGroupIndex - 1; G >= -w; G--)
        if (d.value.lazyLoadedList.indexOf(G) < 0) {
          o.push(G);
          break;
        }
      o.length > 0 ? (d.value.lazyLoadedList = d.value.lazyLoadedList.concat(o), a("lazyLoad", o)) : f && (clearInterval(f), f = null);
    }, $t = () => {
      var w;
      const o = (w = O.value) == null ? void 0 : w.querySelectorAll(
        ".v-slick-slide-group img"
      ), l = (o == null ? void 0 : o.length) || 0;
      let m = 0;
      o == null || o.forEach((G) => {
        const I = () => {
          ++m >= l && ee();
        };
        if (!G.onclick)
          G.onclick = () => {
            var z;
            (z = G.closest(".v-slick-slide-group")) == null || z.focus();
          };
        else {
          const z = G.onclick.bind(G);
          G.onclick = (L) => {
            var V;
            z(L), (V = G.closest(".v-slick-slide-group")) == null || V.focus();
          };
        }
        if (G.onload)
          G.onload = I, G.onerror = () => {
            I(), a("lazyLoadError");
          };
        else {
          if (!n.value.lazyLoad) return;
          G.onload = () => {
            _(), p.push(setTimeout(ee, n.value.speed));
          };
        }
      });
    }, Qe = async () => (d.value.detectingWidth = true, new Promise(
      (o) => setTimeout(() => {
        var l;
        Object.assign(Ze.value, {
          width: `${(l = Ke.value) == null ? void 0 : l.offsetWidth}px`
        }), d.value.detectingWidth = false, o();
      })
    )), Wt = () => {
      const o = {
        ...n.value,
        ...d.value,
        slideGroupCount: E.value
      }, l = Z(o), m = We(o);
      if (n.value.variableWidth) {
        let w = [], G = [];
        const I = [];
        et.value.forEach((L) => {
          let V = 0;
          L.forEach((he) => {
            var te;
            const { width: ae } = ((te = he.props) == null ? void 0 : te.style) || {};
            ae && (V = Math.max(V, ae));
          }), I.push(V), w.push(V);
        });
        for (let L = 0; L < l; L++)
          G.push(I[I.length - 1 - L]), w.push(I[I.length - 1 - L]);
        for (let L = 0; L < m; L++)
          w.push(I[L]);
        for (let L = 0; L < d.value.currentSlideGroupIndex; L++)
          G.push(I[L]);
        w = w.filter((L) => L), G = G.filter((L) => L);
        const z = {
          width: `calc(${w.join(" + ")})`,
          left: `calc(${G.map((L) => `-${L}`).join(" + ")})`
        };
        if (n.value.centerMode) {
          const L = I[d.value.currentSlideGroupIndex];
          z.left = `calc(${G.map((V) => `-${V}`).join(" + ")} + (100% - ${L}) / 2 )`;
        }
        d.value.trackStyle = z;
      } else {
        const w = l + m + E.value, G = 100 / n.value.groupsToShow * w, I = 100 / w;
        let z = -I * (l + d.value.currentSlideGroupIndex) * G / 100;
        n.value.centerMode && (z += (100 - I * G / 100) / 2), d.value.slideGroupWidth = I + "%", d.value.trackStyle = {
          width: G + "%",
          left: z + "%"
        };
      }
    }, pe = ref(), Ke = ref(), Ze = ref({}), O = ref(), F = ref(), n = computed(() => {
      const o = lt(i);
      let l = { ...ur, ...o };
      if (pe.value) {
        const m = i.responsive.find(
          (w) => w.breakpoint === pe.value
        );
        l = {
          ...l,
          ...m == null ? void 0 : m.settings
        };
      }
      return l.centerMode && (l.groupsToScroll > 1 && true && console.warn(
        `centerMode is enabled: groupsToScroll should be 1; you are using ${l.groupsToScroll}`
      ), l.groupsToScroll = 1), l.fade && (l.groupsToShow > 1 && true && console.warn(
        `fade is enabled: groupsToShow should be 1; you are using ${l.groupsToShow}`
      ), l.groupsToScroll > 1 && true && console.warn(
        `fade is enabled: groupsToScroll should be 1; you are using ${l.groupsToScroll}`
      ), l.groupsToShow = 1, l.groupsToScroll = 1), l.slidesPerGroup > 1 && (l.variableWidth && true && console.warn("slidesPerGroup is bigger than 1: variableWidth is disabled"), l.variableWidth = false), l.vertical && l.rtl && (console.warn("vertical mode is enabled: rtl is disabled"), l.rtl = false), l;
    }), Je = computed(
      () => rr({
        ...n.value,
        ...d.value,
        slideGroupCount: E.value
      })
    ), ke = computed(
      () => je({
        ...n.value,
        ...d.value,
        slideGroupCount: E.value
      })
    ), be = computed(() => {
      if (n.value.infinite)
        return Math.ceil(E.value / n.value.groupsToScroll);
      let o = Math.ceil(
        (E.value - n.value.groupsToShow) / n.value.groupsToScroll
      ) + 1;
      return !n.value.infinite && n.value.groupsToShow > 1 && n.value.centerMode && o++, o < 0 ? 0 : o;
    }), ve = ref(u.default ? $e(u.default()) : []), d = ref({
      ...sr(),
      currentSlideGroupIndex: n.value.initialGroupIndex
    }), zt = computed(
      () => d.value.currentSlideGroupIndex
    ), At = computed(() => n.value.groupsToShow), E = computed(
      () => yt(ve.value.length, n.value.slidesPerGroup)
    ), et = computed(() => {
      const o = [], l = n.value.slidesPerGroup, m = E.value;
      for (let w = 0; w < m; w++) {
        const G = w * l, I = G + l;
        o.push(ve.value.slice(G, I));
      }
      return o;
    });
    return watch(
      () => i,
      () => {
        g(), C();
      },
      { deep: true }
    ), watch(
      n,
      (o, l) => {
        let m = false;
        for (const w of Object.keys(n.value)) {
          if (!o.hasOwnProperty(w)) {
            m = true;
            break;
          }
          if (!(typeof o[w] == "object" || typeof o[w] == "function") && o[w] !== l[w]) {
            m = true;
            break;
          }
        }
        Ge(m), d.value.currentSlideGroupIndex >= E.value && J({
          message: "index",
          index: E.value - o.groupsToShow
        }), o.autoplay ? N(T.update) : $(T.paused);
      },
      {
        deep: true
      }
    ), watch(
      () => {
        var o;
        return ((o = u.default) == null ? void 0 : o.call(u)) || [];
      },
      (o) => {
        ve.value = $e(o);
      }
    ), watch(
      () => [
        d.value.listHeight,
        n.value.centerMode,
        n.value.centerPadding,
        n.value.vertical
      ],
      ([o, l, m, w]) => {
        let G = {
          height: "auto"
        };
        w && (G = {
          height: `${o}px`
        });
        let I;
        l ? w ? I = {
          padding: m + " 0px"
        } : I = {
          padding: "0px " + m
        } : I = {
          padding: "0"
        }, c.value = {
          ...c.value,
          ...lt(G),
          ...I
        };
      }
    ), watch(
      () => [
        n.value.infinite,
        d.value.currentSlideGroupIndex,
        n.value.groupsToShow,
        E.value
      ],
      ([o, l, m, w]) => {
        o || l <= w - m + 1 || U(be.value - 1);
      }
    ), watch(
      () => d.value.dragging,
      (o) => {
        O.value && (o ? (O.value.onmousemove = Fe, O.value.ontouchmove = Fe, O.value.onmouseup = Xe, O.value.ontouchend = Xe, O.value.onmouseleave = qe, O.value.ontouchcancel = qe) : (O.value.onmousemove = null, O.value.ontouchmove = null, O.value.onmouseup = null, O.value.ontouchend = null, O.value.onmouseleave = null, O.value.ontouchcancel = null));
      }
    ), r({
      goTo: U,
      next: () => {
        U(
          d.value.currentSlideGroupIndex + n.value.groupsToScroll
        );
      },
      prev: () => {
        U(
          d.value.currentSlideGroupIndex - n.value.groupsToScroll
        );
      },
      canGoNext: ke,
      canGoPrev: Je,
      play: b,
      pause: $,
      autoPlay: N,
      slideGroupCount: E,
      currentSlideGroupIndex: zt,
      currentGroupsToShow: At,
      pageCount: be
    }), onMounted(async () => {
      var o;
      window.addEventListener("resize", Ue), n.value.widthDetection === oe.manual && await Qe(), Ge(true), _(), n.value.autoplay && N(T.update), n.value.lazyLoad === pt.progressive && (f = setInterval(Et, 1e3)), y = new ResizeObserver(() => {
        d.value.animating ? (ee({ shouldSetTrackStyle: false }), p.push(setTimeout(() => ee(), n.value.speed))) : ee();
      }), y.observe(O.value), (o = O.value) == null || o.querySelectorAll(".v-slick-slide-group").forEach((l) => {
        l.onfocus = n.value.pauseOnFocus ? Mt : null, l.onblur = n.value.pauseOnFocus ? Ot : null;
      });
    }), onUpdated(() => {
      if ($t(), a("reInit"), n.value.lazyLoad) {
        const o = He({
          ...n.value,
          ...d.value
        });
        o.length && (d.value.lazyLoadedList = d.value.lazyLoadedList.concat(o), a("lazyLoad", o));
      }
      _();
    }), onBeforeUnmount(() => {
      window.removeEventListener("resize", Ue), y == null || y.unobserve(O.value), k && clearTimeout(k), f && clearInterval(f), p.length && (p.forEach((o) => clearTimeout(o)), p = []), d.value.autoplayTimer && clearInterval(d.value.autoplayTimer);
    }), C(), Wt(), a("init"), (o, l) => (openBlock(), createElementBlock("div", {
      ref_key: "vSlickCarouselRef",
      ref: Ke,
      class: "v-slick-carousel",
      style: normalizeStyle(
        o.widthDetection === unref(oe).manual ? d.value.detectingWidth ? { width: "100%" } : Ze.value : {}
      )
    }, [
      createBaseVNode("div", {
        class: "v-slick-slider",
        dir: n.value.rtl ? "rtl" : "ltr"
      }, [
        n.value.arrows ? (openBlock(), createBlock(dt, {
          key: 0,
          type: unref(H).previous,
          "center-mode": n.value.centerMode,
          infinite: n.value.infinite,
          "groups-to-show": n.value.groupsToShow,
          "slide-group-count": E.value,
          "current-slide-group-index": d.value.currentSlideGroupIndex,
          disabled: !Je.value,
          onPrevious: Ct
        }, {
          prevArrow: withCtx((m) => [
            renderSlot(o.$slots, "prevArrow", normalizeProps(guardReactiveProps(m)), void 0, true)
          ]),
          _: 3
        }, 8, ["type", "center-mode", "infinite", "groups-to-show", "slide-group-count", "current-slide-group-index", "disabled"])) : createCommentVNode("", true),
        createBaseVNode("div", {
          ref_key: "vSlickListRef",
          ref: O,
          class: normalizeClass(["v-slick-list", { dragging: d.value.dragging }]),
          style: normalizeStyle(c.value),
          onClick: Y,
          onMousedown: Re,
          onTouchstartPassive: Re,
          onKeydown: Gt
        }, [
          createVNode(Dr, {
            ref_key: "vSlickTrackRef",
            ref: F,
            "center-mode": n.value.centerMode,
            "center-padding": n.value.centerPadding,
            "raw-slide-groups": et.value,
            "css-ease": o.cssEase,
            "current-slide-group-index": d.value.currentSlideGroupIndex,
            "detecting-width": d.value.detectingWidth,
            fade: n.value.fade,
            "ignore-prefers-reduced-motion": n.value.ignorePrefersReducedMotion,
            infinite: n.value.infinite,
            "lazy-load": n.value.lazyLoad,
            "lazy-loaded-list": d.value.lazyLoadedList,
            "list-height": d.value.listHeight,
            rtl: n.value.rtl,
            "slide-group-count": E.value,
            "slide-group-height": d.value.slideGroupHeight,
            "slide-group-width": d.value.slideGroupWidth,
            "groups-to-scroll": n.value.groupsToScroll,
            "groups-to-show": n.value.groupsToShow,
            speed: n.value.speed,
            "track-style": d.value.trackStyle,
            "variable-width": n.value.variableWidth,
            vertical: n.value.vertical,
            onMouseenter: Ye,
            onMouseleave: kt,
            onMouseover: Ye,
            onChildClick: wt
          }, null, 8, ["center-mode", "center-padding", "raw-slide-groups", "css-ease", "current-slide-group-index", "detecting-width", "fade", "ignore-prefers-reduced-motion", "infinite", "lazy-load", "lazy-loaded-list", "list-height", "rtl", "slide-group-count", "slide-group-height", "slide-group-width", "groups-to-scroll", "groups-to-show", "speed", "track-style", "variable-width", "vertical"])
        ], 38),
        n.value.arrows ? (openBlock(), createBlock(dt, {
          key: 1,
          type: unref(H).next,
          "center-mode": n.value.centerMode,
          infinite: n.value.infinite,
          "groups-to-show": n.value.groupsToShow,
          "slide-group-count": E.value,
          "current-slide-group-index": d.value.currentSlideGroupIndex,
          disabled: !ke.value,
          onNext: It
        }, {
          nextArrow: withCtx((m) => [
            renderSlot(o.$slots, "nextArrow", normalizeProps(guardReactiveProps(m)), void 0, true)
          ]),
          _: 3
        }, 8, ["type", "center-mode", "infinite", "groups-to-show", "slide-group-count", "current-slide-group-index", "disabled"])) : createCommentVNode("", true)
      ], 8, no),
      n.value.dots ? (openBlock(), createBlock(Hr, {
        key: 0,
        "current-slide-group-index": d.value.currentSlideGroupIndex,
        infinite: n.value.infinite,
        "slide-group-count": E.value,
        "groups-to-scroll": n.value.groupsToScroll,
        "groups-to-show": n.value.groupsToShow,
        "dots-class": n.value.dotsClass,
        "page-count": be.value,
        onDotClick: xt,
        onDotsOver: bt,
        onDotsLeave: Tt
      }, {
        customPaging: withCtx((m) => [
          renderSlot(o.$slots, "customPaging", normalizeProps(guardReactiveProps(m)), void 0, true)
        ]),
        _: 3
      }, 8, ["current-slide-group-index", "infinite", "slide-group-count", "groups-to-scroll", "groups-to-show", "dots-class", "page-count"])) : createCommentVNode("", true)
    ], 4));
  }
});
var so = Ve(ao, [["__scopeId", "data-v-b4e52e3f"]]);
export {
  pt as LazyLoadType,
  T as PlayingType,
  H as SlideNavigation,
  R as SwipeDirection,
  so as VSlickCarousel,
  oe as WidthDetection
};
//# sourceMappingURL=v-slick-carousel.js.map
